var documenterSearchIndex = {"docs":
[{"location":"man/examples_overview/","page":"Overview","title":"Overview","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"man/examples_overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"man/examples_overview/","page":"Overview","title":"Overview","text":"We organize the models by the type of nonlinearities (if there are some), and whether they are purely continuous or present discrete transitions, i.e. hybrid systems. We have added a column with the associated scientific domain, and another column with the number of state variables. Roughly speaking, a higher number of state variables usually correspnds to problems which are harder to solve, altough strictly speaking, this usually depends on the property to be verified.","category":"page"},{"location":"man/examples_overview/","page":"Overview","title":"Overview","text":"Column P.V. refers to the cases where the example is presented with at lest one instance with parameter variation.","category":"page"},{"location":"man/examples_overview/#Further-examples","page":"Overview","title":"Further examples","text":"","category":"section"},{"location":"man/examples_overview/","page":"Overview","title":"Overview","text":"In addition to those present in this manual, a larger collection of examples can be found in the models library ReachabilityModels.jl. For further instructions see the section Model library.","category":"page"},{"location":"man/examples_overview/#Linear-continuous","page":"Overview","title":"Linear continuous","text":"","category":"section"},{"location":"man/examples_overview/","page":"Overview","title":"Overview","text":"Name Area State dim.\nDamped oscillator Physics 2\nBuilding Mechanical Engineering 48\nTransmission line circuit Power Systems Stability 4 to 40\nInternational Space Station Aerospace Engineering 270\nModified Nodal Analysis 1 Electronics 1002\nModified Nodal Analysis 2 Electronics 10913\nHeat PDE Physics 125 to 125000","category":"page"},{"location":"man/examples_overview/#Linear-hybrid","page":"Overview","title":"Linear hybrid","text":"","category":"section"},{"location":"man/examples_overview/","page":"Overview","title":"Overview","text":"Name Area State dim.\nAmplifier circuit Electronic Engineering 2\nElectromechanic break Electronic Engineering \nGearbox Mechanical Engineering \nPlatoon Autonomous Driving \nPowertrain Mechanical Engineering ","category":"page"},{"location":"man/examples_overview/#Nonlinear-continuous","page":"Overview","title":"Nonlinear continuous","text":"","category":"section"},{"location":"man/examples_overview/","page":"Overview","title":"Overview","text":"Name Area State dim.\nBrusselator  \nLaub-Loomis Molecular Biology 7\nLorenz system  \nLotka-Volterra  \nProduction-Destruction Electrical engineering \nQuadrotor  \nSEIR Model  \nVan der Pol  ","category":"page"},{"location":"man/examples_overview/#Nonlinear-hybrid","page":"Overview","title":"Nonlinear hybrid","text":"","category":"section"},{"location":"man/examples_overview/","page":"Overview","title":"Overview","text":"Name Area State dim.\nSpacecraft  \nLotka-Volterra w/crossing Biology, Nonlinear physics ","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/ProductionDestruction/ProductionDestruction.jl\"","category":"page"},{"location":"models/ProductionDestruction/#Production-Destruction","page":"Production-Destruction","title":"Production-Destruction","text":"","category":"section"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"(Image: )","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"note: Overview\nSystem type: rational function\nState dimension: 3\nApplication domain: Chemical kinetics","category":"page"},{"location":"models/ProductionDestruction/#Model-description","page":"Production-Destruction","title":"Model description","text":"","category":"section"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"A production-destruction system consists of an ordinary differential equation and two constraints: positivity and conservativity. It means that the system states are quantities which are always positive and the sum of these quantities is constant. This particular family of systems is often used to test the stability of integration schemes.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"As proposed by Michaelis-Menten theory [KM18], a model for three quantities can be defined as follows:","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"   left beginarraylcl\n   dotx = dfrac-xy1+x \n   doty = dfracxy1+x - a y \n   dotz = ay\n   endarray right","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"with nominal values a = 03 and an initial condition `x(0) = 998, y(0) = 001 and z(0) = 001. In this model, x is the nutrients, y the phytoplankton and z the detritus. In this notebook we analyze the behavior of the system subject to uncertainties in the initial condition and/or the model's parameter a using forward reachability analysis.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"The solution should satisfy the following two constraints:","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Positivity: x(t), y(t), z(t) are positive, and\nConservativity: x(t) + y(t) + z(t) = 10 for all t ge 0.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"In this notebook we are interested in computing the reachable tube until the time horizon T=100, and to verify (or embed) the  constraints. Three setups are considered, depending on the source of bounded uncertainties which is taken into account:","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Case I: x(0) in 95 100, i.e., uncertainty on the initial condition;\nCase P: a in 0296 0304, i.e., uncertainty on the parameter;\nCase I & P: x(0) in 95 100 and a in 0296 0304, i.e., both uncertainties are mixed.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"In terms of objectives, at T = 100, the constraints 10 in x+y+z and x y z geq 0 have to be verified.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"The reachability settings considered above are a variation of those in [ARCHCOMP20_NLN]. Please note that variables x and y converge towards zero, so the final volume can be used as a quality measure of the overapproximation.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"In the next section we explain how to check whether the constraints are satisfied using LazySets.jl.","category":"page"},{"location":"models/ProductionDestruction/#Checking-satisfiability-with-sets","page":"Production-Destruction","title":"Checking satisfiability with sets","text":"","category":"section"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Two measures of quality of the approximation are considered: the volume of the box (x times y times z) enclosing the final state (at T = 100) and the total time of computation for evolution and verification. All of these results are obtained for the three setups.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Let us discuss the implementation of each constraint satisfaction problem. We begin by defining the positive orthant in three-dimensional space, positive_orthant, as an unbounded polyhedron in constraint representation.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"using ReachabilityAnalysis, Symbolics, Plots\n\n@variables x y z\nconst positive_orthant = HPolyhedron([x >= 0, y >= 0, z >= 0], [x, y, z])","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Given a set X subseteq mathbbR^n, to check whether the positivity constraint holds correspnods to checking wheter X is included in the positive orthant. This computation can be done efficiently using support functions, and it is available in LazySets.jl. Multiple dispatch takes care based on the types of the arguments in the call X ⊆ positive_orthant depending on the type of X.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"On the other hand, given a set X, a quick way to check the conservativity constraint is to first overapproximate X with a box, then represent such box as a product-of-intervals (IntervalBox) B, and finally take the Minkowski sum of each line segment, using sum(B). This check is only sufficient; splitting X can be used to refine the check.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"The verification problem is summarized in the function prod_dest_verif. It receives the solution of a reachability problem represented with a Taylor model flowpipe and two optional arguments that specify the time horizon T and the conservativity condition given a target state target, which defaults to 10. The function returns the tuple (flag, vol) where flag is true if and only if the positivity and conservativity conditions are satisfied at the time horizon T, which defaults to 100. The second output, vol, corresponds to the volume of the box overapproximation of the final reach-set.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"function prod_dest_verif(sol; T=100.0, target=10.0)\n\n    # convert to a zonotopic flowpipe\n    solz = overapproximate(sol, Zonotope)\n\n    # project the final reach-set onto the space variables x, y, z\n    X = project(solz(T), vars=(1, 2, 3))\n\n    # check that all variables are nonnegative\n    nonnegative = X ⊆ positive_orthant\n\n    # compute the volume of the last reach-set\n    H = overapproximate(X, Hyperrectangle)\n    vol = volume(H)\n\n    # check that that target belongs to the minkowski sum of the reach-sets projected in each coordinate\n    B = convert(IntervalBox, H) # get the product-of-intervals representation\n    contains_target = target ∈ sum(B)\n\n    return nonnegative && contains_target, vol\nend","category":"page"},{"location":"models/ProductionDestruction/#Case-I","page":"Production-Destruction","title":"Case I","text":"","category":"section"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Case I corresponds to initial states uncertainty. We begin by writing the system of ODEs in the function prod_dest_I!.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"@taylorize function prod_dest_I!(du, u, params, t)\n    local a = 0.3\n    x, y, z = u[1], u[2], u[3]\n\n    du[1] = - (x * y) / (1 + x)\n    du[2] = (x * y) / (1 + x) - a * y\n    du[3] = a * y\n    return du\nend","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"We define the initial states as the cartesian product of intervals.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"X0 = (9.5 .. 10.0) × (0.01 .. 0.01) × (0.01 .. 0.01)\nprob = @ivp(x'= prod_dest_I!(x), dim:3, x(0) ∈ X0)\n\nsolI = solve(prob, T=100.0, alg=TMJets(abstol=1e-11, orderT=7, orderQ=1));\nnothing #hide","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Verifying that the specification holds:","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"property, vol = prod_dest_verif(solI)","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Now we plot z (in the 0 11 range) w.r.t. time (in the 0 100 range).","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"plot(solI, vars=(0, 3), linecolor=:orange, color=:orange, alpha=0.3, lab=\"I\")","category":"page"},{"location":"models/ProductionDestruction/#Case-P","page":"Production-Destruction","title":"Case P","text":"","category":"section"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"For the case of an uncertain parameter, we add a new state variable that corresponds to a, with constant (zero) dynamics.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"@taylorize function prod_dest_IP!(du, u, params, t)\n    x, y, z, a = u[1], u[2], u[3], u[4]\n\n    du[1] = - (x * y) / (1 + x)\n    du[2] = (x * y) / (1 + x) - a * y\n    du[3] = a * y\n    du[4] = zero(x)\n    return du\nend\n\nX0 = (9.98 .. 9.98) × (0.01 .. 0.01) × (0.01 .. 0.01) × (0.296 .. 0.304)\nprob = @ivp(x'= prod_dest_IP!(x), dim:4, x(0) ∈ X0)\n\nsolP = solve(prob, T=100.0, alg=TMJets(abstol=1e-12, orderT=7, orderQ=1));\nnothing #hide","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Verifying that the specification holds:","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"property, vol = prod_dest_verif(solP)","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Now we plot z (in the 0 11 range) w.r.t. time (in the 0 100 range).","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"plot(solP, vars=(0, 3), linecolor=:blue, color=:blue, alpha=0.3, lab=\"P\")","category":"page"},{"location":"models/ProductionDestruction/#Case-I-and-P","page":"Production-Destruction","title":"Case I & P","text":"","category":"section"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"When uncertainty in both the intial states and the paramters are present, we can reuse the function prod_dest_IP!, but setting an uncertain initial condition and an uncertain parameter. Recall that we are interested in x(0) in 95 100 and a in 0296 0304.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"X0 = (9.5 .. 10.0) × (0.01 .. 0.01) × (0.01 .. 0.01) × (0.296 .. 0.304)\nprob = @ivp(x'= prod_dest_IP!(x), dim:4, x(0) ∈ X0)\n\nsolIP = solve(prob, T=100.0, alg=TMJets(abstol=1e-11, orderT=7, orderQ=1));\nnothing #hide","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Verifying that the specification holds:","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"property, vol = prod_dest_verif(solIP)","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"Now we plot z (in the 0 11 range) w.r.t. time (in the 0 100 range).","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"plot(solIP, vars=(0, 3), linecolor=:red, color=:red, alpha=0.3, lab=\"I & P\")","category":"page"},{"location":"models/ProductionDestruction/#Performance-optimization","page":"Production-Destruction","title":"Performance optimization","text":"","category":"section"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"We have observed that the specifications are satisfied in all cases. The question remains if we can tune the problem implementation such that we can verify these properties in less time. In this section we put into practice the ideas explained in Some common gotchas. First, consider the function prod_dest_I! defined above. The term du[1] = -x*y / (1+x) has the numerator and denominator in common with respect to du[2], so we can store those values in an auxiliary variable. Similar comments apply to the function with varying parameter a. The final functions are presented below.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"@taylorize function prod_dest_I_optimized!(du, u, params, t)\n    local a = 0.3\n    x, y, z = u[1], u[2], u[3]\n\n    num = x * y\n    den = 1 + x\n    aux = num/den\n    aux2 = a * y\n    du[1] = -aux\n    du[2] = aux - aux2\n    du[3] = aux2\n    return du\nend\n\n@taylorize function prod_dest_IP_optimized!(du, u, params, t)\n    x, y, z, a = u[1], u[2], u[3], u[4]\n\n    num = x * y\n    den = 1 + x\n    aux = num/den\n    aux2 = a * y\n    du[1] = -aux\n    du[2] = aux - aux2\n    du[3] = aux2\n    du[4] = zero(x)\n    return du\nend","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"With respect to parameter tuning, we have observed that for all three cases a good parameter choice is n_T = 7, n_Q = 1, and an adaptive absolute tolerance with initial value 10^-11 (resp 10^-12) for I and I and P (resp. P). This choice offers a good balance between runtime and precision.","category":"page"},{"location":"models/ProductionDestruction/#References","page":"Production-Destruction","title":"References","text":"","category":"section"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"[ARCHCOMP20_NLN]: ARCH-COMP20 Category Report: Continuous and Hybrid Systems with Nonlinear Dynamics. Luca Geretti, Julien Alexandre dit Sandretto, Matthias Althoff, Luis Benet, Alexandre Chapoutot, Xin Chen, Pieter Collins, Marcelo Forets, Daniel Freire, Fabian Immler, Niklas Kochdumper, David P. Sanders and Christian Schilling (2020) ARCH20. To appear in 7th International Workshop on Applied Verification of Continuous and Hybrid Systems. 7th International Workshop on Applied Verification of Continuous and Hybrid Systems (ARCH20), vol 74, pages 49–75. 10.29007/zkf6.","category":"page"},{"location":"models/ProductionDestruction/","page":"Production-Destruction","title":"Production-Destruction","text":"[KM18]: Kopecz, Stefan, and Andreas Meister. On order conditions for modified Patankar–Runge–Kutta schemes. Applied Numerical Mathematics 123 (2018): 159-179.","category":"page"},{"location":"models/SEIR/","page":"SEIR model","title":"SEIR model","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/SEIR/SEIR.jl\"","category":"page"},{"location":"models/SEIR/#SEIR","page":"SEIR model","title":"SEIR","text":"","category":"section"},{"location":"models/SEIR/","page":"SEIR model","title":"SEIR model","text":"(Image: )","category":"page"},{"location":"models/SEIR/","page":"SEIR model","title":"SEIR model","text":"note: Overview\nSystem type: Nonlinear system\nState dimension: 7\nApplication domain: Epidemiology","category":"page"},{"location":"models/SEIR/#Model-description","page":"SEIR model","title":"Model description","text":"","category":"section"},{"location":"models/SEIR/","page":"SEIR model","title":"SEIR model","text":"The SEIR Model is an Compartmental model, these try to predict things such as how a disease spreads, or the total number infected, or the duration of an epidemic, and to estimate various epidemiological parameters such as the reproductive number. The dynamics are described as follows:","category":"page"},{"location":"models/SEIR/","page":"SEIR model","title":"SEIR model","text":"  left beginarraylcl\n  fracdSdt  =  beta I S \n  fracdEdt  =  beta I S - alpha E \n  fracdIdt  =  -gamma I - alpha E \n  fracdRdt  =  gamma I\n  endarray right","category":"page"},{"location":"models/SEIR/","page":"SEIR model","title":"SEIR model","text":"where S is the stock of susceptible population, E is the stock of exposed populationI is the stock of infected, R is the stock of removed population (either by death or recovery), with S + E + I + R = N","category":"page"},{"location":"models/SEIR/","page":"SEIR model","title":"SEIR model","text":"using ReachabilityAnalysis, Plots\n\n@taylorize function seir2!(du,u,p,t)\n  S, E, I, R, α, β, γ = u\n\n  βIS = β * (I * S)\n  αE = α*E\n  γI = γ*I\n\n  du[1] = -βIS      # dS\n  du[2] = βIS - αE  # dE\n  du[3] = -γI + αE  # dI\n  du[4] = γI        # dR\n\n  #uncertain parameters\n  local zerou = zero(u[1])\n  du[5] = zerou\n  du[6] = zerou\n  du[7] = zerou\nend\n\nE₀ = 1e-4\nu₀ = [1-E₀, E₀, 0, 0]\nparam_error = 0.01\nα = 0.2 ± param_error\nβ = 1.0 ± 0.0\nγ = 0.5 ± param_error\np = [α, β, γ]\nX0 = IntervalBox(vcat(u₀, p));\nprob = @ivp(x' = seir2!(x), dim=7, x(0) ∈ X0);\nnothing #hide","category":"page"},{"location":"models/SEIR/#Reachability-settings","page":"SEIR model","title":"Reachability settings","text":"","category":"section"},{"location":"models/SEIR/","page":"SEIR model","title":"SEIR model","text":"The initial values used were E₀ = 1e-4 u₀ = 1-E₀ E₀ 0 0, α = 02  001 β = 10  00 γ = 05  001 and p = α β γ, for a time span of 200. The algorithm used was TMJets with n_T=7 and n_Q=1","category":"page"},{"location":"models/SEIR/#Results","page":"SEIR model","title":"Results","text":"","category":"section"},{"location":"models/SEIR/","page":"SEIR model","title":"SEIR model","text":"sol = solve(prob, tspan=(0.0, 200.0), alg=TMJets21a(orderT=7, orderQ=1));\nsolz = overapproximate(sol, Zonotope);\n\nLazySets.set_ztol(Float64, 1e-13)\nfig = plot(legend=:outerright)\nplot!(fig, solz, vars=(0, 1), color=:blue, lw=0.0, lab=\"S\")\nplot!(fig, solz, vars=(0, 2), color=:green, lw=0.0, lab=\"E\")\nplot!(fig, solz, vars=(0, 3), color=:red, lw=0.0, lab=\"I\")\nplot!(solz, vars=(0, 4), color=:grey, lw=0.0, lab=\"R\")\nfig","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/SquareWaveOscillator/SquareWaveOscillator.jl\"","category":"page"},{"location":"models/SquareWaveOscillator/#Square-Wave-Oscillator","page":"Square wave oscillator","title":"Square Wave Oscillator","text":"","category":"section"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"(Image: )","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"note: Overview\nSystem type: linear hybrid\nState dimension: 1\nApplication domain: Electronics","category":"page"},{"location":"models/SquareWaveOscillator/#Model-description","page":"Square wave oscillator","title":"Model description","text":"","category":"section"},{"location":"models/SquareWaveOscillator/#Hybrid-automaton-formulation","page":"Square wave oscillator","title":"Hybrid automaton formulation","text":"","category":"section"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"using ReachabilityAnalysis, Symbolics, Plots\n\nLazySets.set_ztol(Float64, 1e-15)\n\nfunction multistable_oscillator(; X0 = Interval(0.0, 0.05),\n                                  V₊ = +13.5, V₋ = -13.5,\n                                  R = 20.E3, C = 5.5556E-8,\n                                  R1 = 20.E3, R2 = 20.E3)\n\n    @variables x\n    τ = 1/(R*C)\n    α = R2/(R1+R2)\n\n    A = -τ\n    b = (τ/α) * V₊\n    I₊ = HalfSpace(x <= α*V₊)\n    m1 = @system(x' = Ax + b, x ∈ I₊)\n\n    b = (τ/α) * V₋\n    I₋ = HalfSpace(x >= α*V₋)\n    m2 = @system(x' = Ax + b, x ∈ I₋)\n\n    automaton = LightAutomaton(2)\n    add_transition!(automaton, 1, 2, 1)\n    g1 = Hyperplane(x == α*V₊)\n    r1 = ConstrainedIdentityMap(1, g1)\n\n    add_transition!(automaton, 2, 1, 2)\n    g2 = Hyperplane(x == α*V₋)\n    r2 = ConstrainedIdentityMap(1, g2)\n\n    modes = [m1, m2]\n    resetmaps = [r1, r2]\n    H = HybridSystem(automaton, modes, resetmaps)\n\n    # initial condition in mode 1\n    X0e = [(1, X0)]\n    return IVP(H, X0e)\nend","category":"page"},{"location":"models/SquareWaveOscillator/#Results","page":"Square wave oscillator","title":"Results","text":"","category":"section"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"prob = multistable_oscillator()\n\nsol = solve(prob, T=100e-4, alg=INT(δ=1.E-6), fixpoint_check=false);\n\nplot(sol, vars=(0, 1), xlab=\"t\", ylab=\"v-\")","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"tspan.(sol)","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"location.(sol)","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"Let us analyze in some detail the first transition. If we plot the last 10 reach-sets of the first flowpipe, we observe that only the last 3 actually intersect the guard:","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"plot(sol[1][end-10:end], vars=(0, 1), xlab=\"t\", ylab=\"v-\")\nplot!(x -> 6.75, xlims=(3.1e-4, 3.3e-4), lab=\"Guard\", lw=2.0, color=:red)","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"We now cluster those reach-sets into a single hyperrectangle:","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"Xc = cluster(sol[1], [318, 319, 320], BoxClustering(1))","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"Plotting Xc matches with the flowpipe after the jump:","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"plot(sol[1][end-10:end], vars=(0, 1))\nplot!(sol[2][1:10], vars=(0, 1))\nplot!(x -> 6.75, xlims=(3.1e-4, 3.3e-4), lab=\"Guard\", lw=2.0, color=:red)\nplot!(Xc[1], vars=(0, 1), c=:grey)","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"Finally, we note that the algorithm finds an invariant of the system after the first period. To activate such check pass the fixpoint_check=true flag to the hybrid solve API.","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"sol = solve(prob, T=100e-4, alg=INT(δ=1.E-6), fixpoint_check=true);\nnothing #hide","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"plot(sol, vars=(0, 1), xlab=\"t\", ylab=\"v-\")","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"When the fixpoint check is activated, the computation terminates as soon as the last reach-set is contained in a previously explored initial state.","category":"page"},{"location":"models/SquareWaveOscillator/","page":"Square wave oscillator","title":"Square wave oscillator","text":"tspan(sol)","category":"page"},{"location":"models/SquareWaveOscillator/#References","page":"Square wave oscillator","title":"References","text":"","category":"section"},{"location":"lib/solutions/","page":"Solutions","title":"Solutions","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"lib/solutions/#Abstract-interface","page":"Solutions","title":"Abstract interface","text":"","category":"section"},{"location":"lib/solutions/","page":"Solutions","title":"Solutions","text":"ReachabilityAnalysis.AbstractSolution","category":"page"},{"location":"lib/solutions/#ReachabilityAnalysis.AbstractSolution","page":"Solutions","title":"ReachabilityAnalysis.AbstractSolution","text":"AbstractSolution\n\nAbstract supertype of all solution types of a rechability problem.\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#Solution-of-a-reachability-problem","page":"Solutions","title":"Solution of a reachability problem","text":"","category":"section"},{"location":"lib/solutions/","page":"Solutions","title":"Solutions","text":"ReachabilityAnalysis.ReachSolution","category":"page"},{"location":"lib/solutions/#ReachabilityAnalysis.ReachSolution","page":"Solutions","title":"ReachabilityAnalysis.ReachSolution","text":"ReachSolution{FT<:AbstractFlowpipe, ST<:AbstractPost} <: AbstractSolution\n\nType that wraps the solution of a reachability problem as a sequence of lazy sets, and a dictionary of options.\n\nFields\n\nXk       – the list of AbstractReachSets\nalg      – algorihm used\noptions  – the dictionary of options\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/","page":"Solutions","title":"Solutions","text":"TODO: document other methods in solutions.jl.","category":"page"},{"location":"man/library/#Model-library","page":"Model library","title":"Model library","text":"","category":"section"},{"location":"man/library/","page":"Model library","title":"Model library","text":"The library ReachabilityModels.jl contains a collection of pre-made models that can be found in books, articles or other publicly available software related to reachability analysis. As it is explained in the documentation of that library, once installed use it as:","category":"page"},{"location":"man/library/","page":"Model library","title":"Model library","text":"using ReachabilityModels, Plots\n\nprob = fetch_model(\"building\") # initial-value problem\n\nsol = solve(prob, T=5.0); # solve it using default options\n\nplot(sol, vars=(0, 25)) # plot the solution","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"man/linear/#Linear-ordinary-differential-equations","page":"Linear ODEs","title":"Linear ordinary differential equations","text":"","category":"section"},{"location":"man/linear/#Conservative-time-discretization","page":"Linear ODEs","title":"Conservative time discretization","text":"","category":"section"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"Algorithms implementing conservative time discretization can be used from the discretize(ivp::IVP, δ, alg::AbstractApproximationModel) function. Set-based conservative discretization of a continuous-time initial value problem into a discrete-time problem. This function receives three inputs: the initial value problem (`ivp) for a linear ODE in canonical form, (e.g. the system returned by normalize); the step-size (δ), and the algorithm (alg) used to compute the approximation model.","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"subtypes(ReachabilityAnalysis.AbstractApproximationModel)","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"The output of a discretization is a new initial value problem of a discrete system. Different approximation algorithms and their respective options are described in the docstring of each method, e.g. Forward.","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"Initial-value problems considered in this function are of the form","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"x = Ax(t) + u(t)qquad x(0)  mathcalX_0qquad (1)","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"and where u(t)  U(k) add where U(k)_k is a sequence of sets of non-deterministic inputs and mathcalX_0 is the set of initial states. Recall that this initial-value problem is called homogeneous whenever U is the empty set. Other problems, e.g. x = Ax(t) + Bu(t) can be brought to the canonical form with the function normalize.","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"The initial value problem returned by this function consists of a set discretized (also called bloated) initial states Ω₀, together with the coefficient matrix Φ = e^Aδ and a transformed sequence of inputs if U is non-empty.","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"Two main variations of this algorithm are considered: dense time case and discrete time case.","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"In the dense time case, the transformation is such that the trajectories","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"of the given continuous system are included in the computed flowpipe of the discretized system. More precisely, given a step size δ and the system (1) conservative set-based discretization function computes a set, Ω₀, that guarantees to contain all the trajectories of (1) starting at any x(0)  mathcalX_0 and for any input function that satisfies u(t)  U(1), for any t  0 δ. If U is time-varying, this function also discretizes the inputs for k  0.","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"In the discrete time case, there is no bloating of the initial states and the","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"input is assumed to remain constant between sampled times. Use the algorithm NoBloating() for this setting. If U is time-varying, this function also discretizes the inputs for k  0.","category":"page"},{"location":"man/linear/","page":"Linear ODEs","title":"Linear ODEs","text":"There are algorithms to obatin such transformations, called approximation models in the technical literature. For references to the original papers, see the docstring of each concrete subtype of AbstractApproximationModel.","category":"page"},{"location":"lib/systems/#Representation-of-linear-systems","page":"Systems","title":"Representation of linear systems","text":"","category":"section"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"MathematicalSystems.jl provides some convenience types and methods to work with mathematical systems models. Every system inherits from AbstractSystem.","category":"page"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"We support the following two concrete types of systems.","category":"page"},{"location":"lib/systems/#Discrete-system","page":"Systems","title":"Discrete system","text":"","category":"section"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"A discrete system consists of a matrix representing the system dynamics, a set of initial states, a set of nondeterministic inputs, and a discretization step δ.","category":"page"},{"location":"lib/systems/#Continuous-system","page":"Systems","title":"Continuous system","text":"","category":"section"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"A continuous system consists of a matrix representing the system dynamics, a set of initial states, and a set of nondeterministic inputs.","category":"page"},{"location":"lib/systems/#Nondeterministic-inputs","page":"Systems","title":"Nondeterministic inputs","text":"","category":"section"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"The above systems may contain nondeterministic inputs, which are wrapped in special types. Every nondeterministic input representation inherits from NonDeterministicInput.","category":"page"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"The inputs are closely related to a DiscreteSystem in the sense that for each discrete time step the input set may change. We support iteration through the inputs over time.","category":"page"},{"location":"lib/systems/#Constant-nondeterministic-inputs","page":"Systems","title":"Constant nondeterministic inputs","text":"","category":"section"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"Constant nondeterministic inputs are chosen from a set of values that does not change over time. Note that, while the set is constant, the inputs themselves vary over time.","category":"page"},{"location":"lib/systems/#Time-varying-nondeterministic-inputs","page":"Systems","title":"Time-varying nondeterministic inputs","text":"","category":"section"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"Time-varying nondeterministic inputs are chosen from a set of values that changes over time (with each time step).","category":"page"},{"location":"lib/systems/#Normalization","page":"Systems","title":"Normalization","text":"","category":"section"},{"location":"lib/systems/#Second-order-systems","page":"Systems","title":"Second order systems","text":"","category":"section"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"A second order system is one of the form","category":"page"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"    Mx(t) + Cx(t) + Kx(t) = f(t)","category":"page"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"where x(t) in mathbbR^n is the state vector and f  mathbbR to mathbbR^n is the forcing term. Here M, C and K are often called the mass matrix, viscosity matrix and stiffness matrix respectively. These names are adopted from physical applications, particularly from structural mechanics. Assuming that the matrix M is invertible, we can transform the second order system to a first order system introducing auxiliary variables, x(t) = x(t)v(t)^T, where v(t) = x(t) is the vector of velocities. Then,","category":"page"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"    x(t) = Ax(t) + Bf(t)","category":"page"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"where","category":"page"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"A = beginpmatrix\n0  I  -M^-1K  -M^-1C\nendpmatrixqquad B = beginpmatrix\n0   M^-1\nendpmatrix","category":"page"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"See the SecondOrder documentation in MathematicalSystems.jl for additional details in second order ODEs types.","category":"page"},{"location":"lib/systems/","page":"Systems","title":"Systems","text":"note: Note\nA similar relation can be obtained using the alternative convention v(t)x(t)^T. Use derivatives_first=true in the normalize function to swap between these conventions (it is set to false by default).","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"man/nonlinear/#Nonlinear-ordinary-differential-equations","page":"Nonlinear ODEs","title":"Nonlinear ordinary differential equations","text":"","category":"section"},{"location":"man/nonlinear/#Overview","page":"Nonlinear ODEs","title":"Overview","text":"","category":"section"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Reachability analysis applies to nonlinear systems, i.e. those where the right-hand side of the ODE is a nonlinear function of the state variables. Such systems play a central role in applied mathematics. In this section we explain how to solve nonlinear reachability problems using ReachabilityAnalysis.jl and comment on some noteworthy differences between the user interface of nonlinear vs. linear systems. Since nonlinear reachability methods suffer from wrapping effects, we explain some common techniques to improve error bounds, such as splitting and refinement. Computing accurately and efficiently the sets of states reachable by nonlinear ODEs is a hard mathematical and computational problem. The methods available in this library are just a small portion of the active and rapidly evolving research literature.","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"In the rest of this section we take, as our running example, the well-known Lotka-Volterra equations. The two-dimensional Lotka-Volterra system depicts the populations change of a class of predators and a class of preys. The growth rate of preys' population x over time is given by","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"dotx = xcdot (alpha - beta cdot y)","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"wherein  alpha beta are constant parameters and y is the population of predators. This equation states that the number of preys grows exponentially without predation. On the other hand, the population growth of predators is governed by the differential equation","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"doty = -ycdot (gamma - deltacdot x)","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"wherein  gamma delta are constant parameters.","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"A typical choice of parameter values is alpha = 15, beta = 1, gamma = 3 and delta = 1. In the next section we consider these values, and compute the set of states reachable varying the initial condition. After, we assume that the paramters are only known within given intervals, and compute the flowpipe for all possible values of the parameters and initial conditions.","category":"page"},{"location":"man/nonlinear/#Problem-formulation","page":"Nonlinear ODEs","title":"Problem formulation","text":"","category":"section"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"nonlinear systems can be computed by stating and solving an initial-value problem for the given , similarly to the case of linear systems, but using different algorithms","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"The first set We introduce the vector \\\n","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"using ReachabilityAnalysis\n\n@taylorize function lotka_volterra!(du, u, p, t)\n    local α, β, γ, δ = 1.5, 1.0, 3.0, 1.0\n    x, y = u\n    du[1] = x * (α - β*y)\n    du[2] = -y * (γ - δ*x)\nend","category":"page"},{"location":"man/nonlinear/#Computing-with-Taylor-models","page":"Nonlinear ODEs","title":"Computing with Taylor models","text":"","category":"section"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"The reachability settings are taken from this resource.","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We consider the initial set  xin 4852 y in 1822.","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"X₀ = Hyperrectangle(low=[4.8, 1.8], high=[5.2, 2.2])\n\nprob = @ivp(x' = lotka_volterra!(x), dim: 2, x(0) ∈ X₀)","category":"page"},{"location":"man/nonlinear/#Results","page":"Nonlinear ODEs","title":"Results","text":"","category":"section"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We compute the flowpipe using the TMJets algorithm for the time horizon 05:","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"sol = solve(prob, T=5.0)\n\nsetrep(sol)","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We can change to the zonotopic overapproximation of the flowpipe using the overapproximate function:","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"sol = overapproximate(sol, Zonotope)\n\nsetrep(sol)","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Finally we plot the solution in phase-space:","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"using Plots\n\nplot(sol, vars=(1, 2), xlab=\"x\", ylab=\"y\", lw=0.2, color=:lightblue, lab=\"Flowpipe\")\nplot!(X₀, color=:orange, lab=\"Xo\")","category":"page"},{"location":"man/nonlinear/#Domain-splitting","page":"Nonlinear ODEs","title":"Domain splitting","text":"","category":"section"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"A common technique to reduce wrapping effects is to split the set of initial states. If an initial-value problem has been setup with an array of sets, then the flowpipe starting from each initial set scomputed in parallel, using Julia's built-in multithreaded support.","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"note: Note\nTo turn off multithreading, pass the multithreaded=false option flag to solve method. It is true by default.","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"note: Note\nTo change the number of threads being used, change the THREADS flag in . . .","category":"page"},{"location":"man/nonlinear/#Some-common-gotchas","page":"Nonlinear ODEs","title":"Some common gotchas","text":"","category":"section"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We end this section with some technical aspects regarding the formulation of initial-value problems for nonlinear systems.","category":"page"},{"location":"man/nonlinear/#What-is-@taylorize?-Do-I-need-it?","page":"Nonlinear ODEs","title":"What is @taylorize? Do I need it?","text":"","category":"section"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"@taylorize is a macro which parses the functions containing the ODEs to be integrated, allowing to speed up repeated evaluations. The macro is defined in TaylorIntegration.jl, see @taylorize's documentation in TaylorIntegration.jl for further details. Since it is an optimization, it is not mandatory, though it is recommended as it helps to reduce the number of allocations and as a consequence it usually gives a performance boost.","category":"page"},{"location":"man/nonlinear/#How-can-I-get-the-most-out-of-@taylorize?","page":"Nonlinear ODEs","title":"How can I get the most out of @taylorize?","text":"","category":"section"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"The main advice is to refactor expressions involving several terms into smaller expressions which involve at most two arguments, making appropriate use of parentheses if needed. For further limitations and advice see this section of TaylorInegrations.jl's documentation.","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Example. Here is an example that uses some of the above recommendations. Start with f! defined below:","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"@taylorize function f!(du, u, params, t)\n    local a = 0.3\n    x, y, z = u[1], u[2], u[3]\n\n    du[1] = -x * y/(1 + x)\n    du[2] = x * y/(1 + x) - a * y\n    du[3] = a * y * y\n    return du\nend","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Observe that the terms x * y can be factored out into a new auxiliary variable aux, and all intermediate operations can be arranged to only involve two arguments, using parentheses:","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"@taylorize function g!(du, u, params, t)\n    local a = 0.3\n    x, y, z = u[1], u[2], u[3]\n\n    num = x * y\n    den = 1 + x\n    aux = num/den\n    du[1] = -aux\n    du[2] = aux - a * (y * y)\n    du[3] = a * (y * y)\n    return du\nend","category":"page"},{"location":"man/nonlinear/#How-are-solutions-obtained-with-Taylor-models-methods-plotted?","page":"Nonlinear ODEs","title":"How are solutions obtained with Taylor models methods plotted?","text":"","category":"section"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Flowpipes computed using algorithm TMJets (or its variations), use Taylor model reach-set representations (TaylorModelReachSet), which define an implicit set in time and in space. Since exact visualization of such objects is difficult (and often unnecessary), we resort to an outer approximation with simpler sets. Either for plotting or performing set-based operations, we can overapproximate a TaylorModelReachSet with other set representations – usually, convex sets such as boxes or zonotopes–. The command overapproximate(sol, Zonotope) applies overapproximate(Ri, Zonotope) for each reach-set Ri in the solution sol.","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"By default, when plotting the solution obtained with such solvers, the zonotopic overapproximation of the flowpipe is used, with a single zonotope per Taylor model reach-set. Such approximation, while it is generally coarse, is often sufficient for visualization purposes.","category":"page"},{"location":"man/nonlinear/#Equations-with-constant-terms-(BoundsError)","page":"Nonlinear ODEs","title":"Equations with constant terms (BoundsError)","text":"","category":"section"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Equations that involve constant terms may give a BoundsError. This is a known bug (cf. issue #179) and it is related to cases in which the update rule for the right-hand side does not have the expected coefficient type. The current solution is to change terms like du[1] = 1.0 into du[1] = 1.0 + zero(u[1]), i.e. let Julia's promotion mechanism take care by adding the given numeric constant with the zero element of the type of u.","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Example. Consider the function f!:","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"@taylorize function f!(du, u, p, t)\n    du[1] = u[3]^3 - u[2] + u[4]\n    du[2] = u[3]\n    du[3] = 2.0\n    du[4] = u[4]\n    return du\nend","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Integrating this function will likely fail with a BoundsError. However, we can re-write it in this way:","category":"page"},{"location":"man/nonlinear/","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"@taylorize function f!(du, u, p, t)\n    local two = 2.0 + zero(u[1])\n    du[1] = u[3]^3 - u[2] + u[4]\n    du[2] = u[3]\n    du[3] = two\n    du[4] = u[4]\n    return du\nend","category":"page"},{"location":"lib/algorithms/GLGM06/","page":"GLGM06","title":"GLGM06","text":"GLGM06","category":"page"},{"location":"lib/algorithms/GLGM06/#ReachabilityAnalysis.GLGM06","page":"GLGM06","title":"ReachabilityAnalysis.GLGM06","text":"GLGM06{N, AM, S, D, NG, P, RM} <: AbstractContinuousPost\n\nImplementation of Girard - Le Guernic - Maler algorithm for reachability of linear systems using zonotopes.\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: Forward) approximation model;                       see Notes below for possible options\nmax_order        – (optional, default: 5) maximum zonotope order\nstatic           – (optional, default: false) if true, convert the problem data                       to statically sized arrays\ndim              – (optional default: missing) ambient dimension\nngens            – (optional, default: missing) number of generators\npreallocate      – (optional, default: true) if true, use the implementation                       which preallocates the zonotopes prior to applying the update rule\nreduction_method    – (optional, default: GIR05()) zonotope order reduction method used\ndisjointness_method – (optional, default: NoEnclosure()) method to check                          disjointness between the reach-set and the invariant\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\nS  – value type associated to the static option\nD  – value type associated to the dimension of the system\nNG – value type associated to the number of generators\nP  – value type associated to the preallocate option\nRM – type associated to the reduction method\n\nThe sole parameter which doesn't have a default value is the step-size, associated to the type parameter N. Parameters D and NG are optionally specified (default to Missing). These parameters are needed for implementations that require the size of the zonotopes to be known (fixed) at compile time, namely the static=true version of this algorithm. Otherwise, the number of generators is not necessarily fixed.\n\nThe default approximation model is\n\napprox_model=Forward(sih=:concrete, exp=:base, setops=:lazy)\n\nHere, Forward refers to the forward-time adaptation of the approximation model from Lemma 3 in [FRE11]. Some of the options to compute this approximation can be specified, see the documentation of Forward for details.\n\nReferences\n\nThe main ideas behind this algorithm can be found in [GIR05] and [GLGM06]. These methods are discussed at length in the dissertation [LG09].\n\nRegarding the zonotope order reduction methods, we refer to [COMB03], [GIR05] and the review article [YS18].\n\nRegarding the approximation model, we use an adaptation of a result in [FRE11].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/BOX/","page":"BOX","title":"BOX","text":"BOX","category":"page"},{"location":"lib/algorithms/BOX/#ReachabilityAnalysis.BOX","page":"BOX","title":"ReachabilityAnalysis.BOX","text":"BOX{N, AM, S, D, R} <: AbstractContinuousPost\n\nImplementation of a reachability method for linear systems using box approximations.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\nstatic\ndim          – (optional default: missing) ambient dimension\nrecursive    – (optional default: false) if true, use the implementation that                   recursively computes each reach-set; otherwise, use the implementation                   that unwraps the sequence until the initial set\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\nS  – value type for the static option\nD  – value type for the dimension\nR  – value type for the recursive option\n\nThe default approximation model is:\n\nForward(sih=:concrete, exp=:base, setops=:lazy)\n\nThis algorithm solves the set-based recurrence equation X_k+1 = ΦX_k  V_k by computing a tight hyperrectangular over-approximation of X_k+1 at each step k  mathbbN. The recursive implementation uses the previously computed set X_k to compute X_k+1. However, it is known that this method incurs wrapping effects. The non-recursive implementation instead computes X_k+1 by unwrapping the discrete recurrence until X_0 = Ω₀, at the expense of computing powers of the matrix Φ. These ideas are discussed in [BFFPSV18].\n\nReferences\n\nThis algorithm is essentially a non-decomposed version of the method in [BFFPSV18], using hyperrectangles as set representation. For a general introduction we refer to the dissertation [LG09].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in [FRE11].\n\n\n\n\n\n","category":"type"},{"location":"man/parametric/","page":"Parametric reachability","title":"Parametric reachability","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"man/parametric/#Parametric-reachability","page":"Parametric reachability","title":"Parametric reachability","text":"","category":"section"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/Brusselator/Brusselator.jl\"","category":"page"},{"location":"models/Brusselator/#Brusselator","page":"Brusselator","title":"Brusselator","text":"","category":"section"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"(Image: )","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"note: Overview\nSystem type: polynomial continuous system\nState dimension: 2\nApplication domain: Chemical kinetics","category":"page"},{"location":"models/Brusselator/#Model-description","page":"Brusselator","title":"Model description","text":"","category":"section"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"A chemical reaction is said to be autocatalytic if one of the reaction products is also a catalyst for the same or a coupled reaction, and such a reaction is called an autocatalytic reaction. We refer to the wikipedia article Autocatalysis for details.","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"The Brusselator is a mathematical model for a class of autocatalytic reactions. The dynamics of the Brusselator is given by the two-dimensional ODE","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"  left beginarraylcl dotx  =  A + x^2cdot y - Bcdot x - x \n   doty  =  Bcdot x - x^2cdot y endarray right","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"The numerical values for the model's constants (in their respective units) are given in the following table.","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"Quantity Value\nA 1\nB 1.5","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"using ReachabilityAnalysis\n\nconst A = 1.0\nconst B = 1.5\nconst B1 = B + 1\n\n@taylorize function brusselator!(du, u, p, t)\n    x, y = u\n    x² = x * x\n    aux = x² * y\n    du[1] = A + aux - B1*x\n    du[2] = B*x - aux\n    return du\nend","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"tip: Performance tip\nThe auxiliary variables B1, x² and aux have been defined to make better use of @taylorize and help to reduce allocations.","category":"page"},{"location":"models/Brusselator/#Reachability-settings","page":"Brusselator","title":"Reachability settings","text":"","category":"section"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"The initial set is defined by x in 08 1, y in 0 02. These settings are taken from [CAS13].","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"U₀ = (0.8 .. 1.0) × (0.0 .. 0.2);\nprob = @ivp(u' = brusselator!(U), u(0) ∈ U₀, dim: 2);\nnothing #hide","category":"page"},{"location":"models/Brusselator/#Results","page":"Brusselator","title":"Results","text":"","category":"section"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"We use TMJets algorithm with sixth-order expansion in time and second order expansion in the spatial variables.","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"sol = solve(prob, T=18.0, alg=TMJets20(orderT=6, orderQ=2));\nnothing #hide","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"using Plots\n\nplot(sol, vars=(1, 2), xlab=\"x\", ylab=\"y\", lw=0.2, color=:blue, lab=\"Flowpipe\", legend=:bottomright)\nplot!(U₀, color=:orange, lab=\"Uo\")","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"We observe that the system converges to the equilibrium point (1.0, 1.5).","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"Below we plot the flowpipes projected into the time domain.","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"plot(sol, vars=(0, 1), xlab=\"t\", lw=0.2, color=:blue, lab=\"x(t)\", legend=:bottomright)\nplot!(sol, vars=(0, 2), xlab=\"t\", lw=0.2, color=:red, lab=\"y(t)\")","category":"page"},{"location":"models/Brusselator/#Changing-the-initial-volume","page":"Brusselator","title":"Changing the initial volume","text":"","category":"section"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"The model was considered in [GCLASG20] but using a different set of initial conditions. Let us parametrize the initial states as a ball centered at x = y = 1 and radius r  0:","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"U0(r) = Singleton([1.0, 1.0]) ⊕ BallInf(zeros(2), r)","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"The parametric initial-value problem is defined accordingly.","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"bruss(r) = @ivp(u' = brusselator!(u), u(0) ∈ U0(r), dim: 2)","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"First we solve for r = 001:","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"sol_01 = solve(bruss(0.01), T=30.0, alg=TMJets20(orderT=6, orderQ=2))\n\nLazySets.set_ztol(Float64, 1e-15)\n\nplot(sol_01, vars=(1, 2), xlab=\"x\", ylab=\"y\", lw=0.2, color=:blue, lab=\"Flowpipe (r = 0.01)\", legend=:bottomright)\n\nplot!(U0(0.01), color=:orange, lab=\"Uo\", xlims=(0.6, 1.3))","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"We observe that the wrapping effect is controlled and the flowpipe doesn't blow up even for the large time horizon T = 300. Next we plot the flowpipe zoomed to the last portion and compare r = 001 with a set of larger initial states, r = 01.","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"sol_1 = solve(bruss(0.1), T=30.0, alg=TMJets20(orderT=6, orderQ=2))\n\nfig = plot(xlab=\"x\", ylab=\"y\", xlims=(0.9, 1.05), ylims=(1.43, 1.57), legend=:bottomright)\n\nplot(sol_1, vars=(1, 2), lw=0.2, color=:red, lab=\"r = 0.1\", alpha=.4)\n\nplot!(sol_01, vars=(1, 2), lw=0.2, color=:blue, lab=\"r = 0.01\")","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"The volume at time T = 90 can be obtained by evaluating the flowpipe and computing the volume of the hyperrectangular overapproximation:","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"vol_01 = overapproximate(sol_01(9.0), Hyperrectangle) |> set |> volume","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"vol_1 = overapproximate(sol_1(9.0), Hyperrectangle) |> set |> volume","category":"page"},{"location":"models/Brusselator/#References","page":"Brusselator","title":"References","text":"","category":"section"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"[CAS13]: X. Chen, E. Abraham, S. Sankaranarayanan. Flow: An Analyzer for Non-Linear Hybrid Systems.* In Proceedings of the 25th International Conference on Computer Aided Verification (CAV’13). Volume 8044 of LNCS, pages 258-263, Springer, 2013.","category":"page"},{"location":"models/Brusselator/","page":"Brusselator","title":"Brusselator","text":"[GCLASG20]: S. Gruenbacher, J. Cyranka, M. Lechner, Md. Ariful Islam,, Scott A. Smolka, R. Grosu Lagrangian Reachtubes: The Next Generation. arXiv: 2012.07458","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/Platoon/Platoon.jl\"","category":"page"},{"location":"models/Platoon/#Vehicle-Platoon-Model","page":"Platoon","title":"Vehicle Platoon Model","text":"","category":"section"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"(Image: )","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"note: Overview\nSystem type: affine with hybrid dynamics\nState dimension: 9 + 1\nApplication domain: Autonomous Driving","category":"page"},{"location":"models/Platoon/#Model-description","page":"Platoon","title":"Model description","text":"","category":"section"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"This benchmark considers a platoon of three vehicles following each other. This benchmark considers loss of communication between vehicles. The model has two modes, connected and disconnected. Three scenarios are considered for the loss of communication:","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"PLAA01 (arbitrary loss) The loss of communication can occur at any time. This       includes the possibility of no communication at all.","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"PLADxy (loss at deterministic times) The loss of communication occurs at fixed       points in time, which are determined by clock constraints c_1 and c_2.       The clock t is reset when communication is lost and when it is re-established.       Note that the transitions have must-semantics, i.e., they take place as soon       as possible. We will consider PLAD01: c1 = c_2 = 5.","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"PLANxy (loss at nondeterministic times) The loss of communication occurs at       any time t  t_b t_c. The clock t is reset when communication is lost       and when it is reestablished. Communication is reestablished at any time       t  0 t_r. This scenario covers loss of communication after an       arbitrarily long time t  t_c by reestablishing communication in zero time.       We will consider PLAN01: tb = 10, tc = 20, tr = 20.","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"The Julia model is developed next. It's convenient to create two independent functions, platoon_connected and platoon_disconnected, which describe the dynamics of the connected (resp. disconnected) modes. These functions are connected in the platoon function using a hybrid automaton with two modes and two discrete transitions, see the following diagram.","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"(Image: )","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"On the left, the system can switch arbitrarily between the modes. In the middle, mode switches are only possible at given points in time, i.e. deterministic switching. On the right, mode switches are only possible during given time intervals. In this notebook we will only consider the case of deterministic switching.","category":"page"},{"location":"models/Platoon/#Dynamics-of-the-\"connected\"-platoon","page":"Platoon","title":"Dynamics of the \"connected\" platoon","text":"","category":"section"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"using ReachabilityAnalysis, SparseArrays, Symbolics\n\nconst var = @variables x[1:9] t\n\nfunction platoon_connected(; deterministic_switching::Bool=true,\n                             c1=5.0)  # clock constraints\n    n = 9 + 1\n\n    # x' = Ax + Bu + c\n    A = Matrix{Float64}(undef, n, n)\n    A[1, :] = [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0]\n    A[2, :] = [0, 0, -1.0, 0, 0, 0, 0, 0, 0, 0]\n    A[3, :] = [1.6050, 4.8680, -3.5754, -0.8198, 0.4270, -0.0450, -0.1942,  0.3626, -0.0946, 0.]\n    A[4, :] = [0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0,]\n    A[5, :] = [0, 0, 1.0, 0, 0, -1.0, 0, 0, 0, 0]\n    A[6, :] = [0.8718, 3.8140, -0.0754,  1.1936, 3.6258, -3.2396, -0.5950,  0.1294, -0.0796, 0.]\n    A[7, :] = [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]\n    A[8, :] = [0, 0, 0, 0, 0, 1.0, 0, 0, -1.0, 0]\n    A[9, :] = [0.7132, 3.5730, -0.0964,  0.8472, 3.2568, -0.0876,  1.2726,  3.0720, -3.1356, 0.]\n    A[10, :] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0]; # t' = 1\n\n    if deterministic_switching\n        invariant = HalfSpace(t <= c1, var)\n    else\n        invariant = Universe(n)\n    end\n\n    # acceleration of the lead vehicle + time\n    B = sparse([2], [1], [1.0], n, 1)\n    U = Hyperrectangle(low=[-9.], high=[1.])\n    c = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0]\n    @system(x' = Ax + Bu + c, x ∈ invariant, u ∈ U)\nend","category":"page"},{"location":"models/Platoon/#Dynamics-of-the-\"disconnected\"-platoon","page":"Platoon","title":"Dynamics of the \"disconnected\" platoon","text":"","category":"section"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"function platoon_disconnected(; deterministic_switching::Bool=true,\n                                c2=5.0)  # clock constraints\n    n = 10 # 9 dimensions + time\n\n    # x' = Ax + Bu + c\n    A = Matrix{Float64}(undef, n, n)\n    A[1, :] = [0, 1.0, 0, 0, 0, 0, 0, 0, 0, 0]\n    A[2, :] = [0, 0, -1.0, 0, 0, 0, 0, 0, 0, 0]\n    A[3, :] = [1.6050, 4.8680, -3.5754, 0, 0, 0, 0, 0, 0, 0]\n    A[4, :] = [0, 0, 0, 0, 1.0, 0, 0, 0, 0, 0,]\n    A[5, :] = [0, 0, 1.0, 0, 0, -1.0, 0, 0, 0, 0]\n    A[6, :] = [0, 0, 0,  1.1936, 3.6258, -3.2396, 0, 0, 0, 0.]\n    A[7, :] = [0, 0, 0, 0, 0, 0, 0, 1.0, 0, 0]\n    A[8, :] = [0, 0, 0, 0, 0, 1.0, 0, 0, -1.0, 0]\n    A[9, :] = [0.7132, 3.5730, -0.0964,  0.8472, 3.2568, -0.0876,  1.2726,  3.0720, -3.1356, 0.]\n    A[10, :] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0]; # t' = 1\n\n    if deterministic_switching\n        invariant = HalfSpace(t <= c2, var)\n    else\n        invariant = Universe(n)\n    end\n\n    # acceleration of the lead vehicle + time\n    B = sparse([2], [1], [1.0], n, 1)\n    U = Hyperrectangle(low=[-9.], high=[1.])\n    c = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0]\n    @system(x' = Ax + Bu + c, x ∈ invariant, u ∈ U)\nend","category":"page"},{"location":"models/Platoon/#Hybrid-system","page":"Platoon","title":"Hybrid system","text":"","category":"section"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"function platoon(; deterministic_switching::Bool=true,\n                   c1=5.0,  # clock constraints\n                   c2=5.0,  # clock constraints\n                   tb=10.0,  # lower bound for loss of communication\n                   tc=20.0, tr=20.0) # upper bound for loss of communication (tc) and reset time (tr)\n\n    # three variables for each vehicle, (ei, d(et)/dt, ai) for\n    # (spacing error, relative velocity, speed), and the last dimension is time\n    n = 9 + 1\n\n    # transition graph\n    automaton = LightAutomaton(2)\n    add_transition!(automaton, 1, 2, 1)\n    add_transition!(automaton, 2, 1, 2)\n\n    # modes\n    mode1 = platoon_connected(deterministic_switching=deterministic_switching, c1=c1)\n    mode2 = platoon_disconnected(deterministic_switching=deterministic_switching, c2=c2)\n    modes = [mode1, mode2]\n\n    # common reset\n    reset = Dict(n => 0.)\n\n    # transition l1 -> l2\n    if deterministic_switching\n        guard = Hyperplane(t == c1, var)\n    else\n        guard = HPolyhedron([tb <= t, t <= tc], var)\n    end\n    t1 = ConstrainedResetMap(n, guard, reset)\n\n    # transition l2 -> l1\n    if deterministic_switching\n        guard = Hyperplane(t == c2, var)\n    else\n        guard = HalfSpace(t <= tr, var)\n    end\n    t2 = ConstrainedResetMap(n, guard, reset)\n    resetmaps = [t1, t2]\n\n    H = HybridSystem(automaton, modes, resetmaps, [AutonomousSwitching()])\n\n    # initial condition is at the orgin in mode 1\n    X0 = BallInf(zeros(n), 0.0)\n    initial_condition = [(1, X0)]\n\n    return IVP(H, initial_condition)\nend","category":"page"},{"location":"models/Platoon/#Safety-specifications","page":"Platoon","title":"Safety specifications","text":"","category":"section"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"The verification goal is to check whether the minimum distance between vehicles is preserved. The choice of the coordinate system is such that the minimum distance is a negative value.","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"BNDxy: Bounded time (no explicit bound on the number of transitions): For all t  0 20 s,","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"x_1(t)  d_min m\nx_4(t)  d_min m\nx_7(t)  d_min m","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"BND42: d_min = 42.","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"BND30: d_min = 30.","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"function dmin_specification(sol, dmin)\n    return (-ρ(sparsevec([1], [-1.0], 10), sol) > -dmin) &&\n           (-ρ(sparsevec([4], [-1.0], 10), sol) > -dmin) &&\n           (-ρ(sparsevec([7], [-1.0], 10), sol) > -dmin)\nend","category":"page"},{"location":"models/Platoon/#Results","page":"Platoon","title":"Results","text":"","category":"section"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"We will only consider the case of deterministic switching in this notebook. We consider two scenarios of increasing difficulty, BND42 and BND30.","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"prob_PLAD01 = platoon();\n\nconst boxdirs = BoxDirections(10)\nconst octdirs = OctDirections(10);\nnothing #hide","category":"page"},{"location":"models/Platoon/#PLAD01-BND42","page":"Platoon","title":"PLAD01 - BND42","text":"","category":"section"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"This scenario can be solved using a hyperrectangular set representation with step size δ = 001.  We use a template that contains all box (i.e., canonical) directions in the ambient space of the state-space, mathbbR^10. There are 20 such directions, two for each coordinate:","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"length(boxdirs)","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"alg = BOX(δ=0.01)\nsol_PLAD01_BND42 = solve(prob_PLAD01,\n                         alg=alg,\n                         clustering_method=BoxClustering(1),\n                         intersection_method=TemplateHullIntersection(boxdirs),\n                         intersect_source_invariant=false,\n                         tspan = (0.0 .. 20.0));\nnothing #hide","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"Let's verify that the specification holds:","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"dmin_specification(sol_PLAD01_BND42, 42)","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"In more detail we can check how is the flowpipe from violating the property. The specification requires that each of the follwing quantities is greater than -dmin = -42.","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"Minimum of x_1(t):","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"-ρ(sparsevec([1], [-1.0], 10), sol_PLAD01_BND42)","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"Minimum of x_4(t):","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"-ρ(sparsevec([4], [-1.0], 10), sol_PLAD01_BND42)","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"Minimum of x_7(t):","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"-ρ(sparsevec([7], [-1.0], 10), sol_PLAD01_BND42)","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"We plot variable x_1 vs time.","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"using Plots, LaTeXStrings\n\nplot(sol_PLAD01_BND42, vars=(0, 1), xlab=L\"t\", ylab=L\"x_1\", title=\"PLAD01 - BND42\", lw=0.1)\nplot!(x->x, x->-42., 0., 20., linewidth=2, color=\"red\", linestyle=:dash, leg=nothing)","category":"page"},{"location":"models/Platoon/#PLAD01-BND30","page":"Platoon","title":"PLAD01 - BND30","text":"","category":"section"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"Note that the previous solution obtained for PLAD01 - BND42 does not verify the BND30 specifications since, for example, the minimum of variable x_4(t) is  -3552, which is below the given bound -d_min = -30. As a consequence, to prove the safety properties for this scenario we have to use a solver with more precision. Instead of the BOX algorithm, we propose to use LGG09 with step-size δ=003 and octagonal template directions. There are 200 such directions:","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"length(octdirs)","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"tip: Performance tip\n","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"The increase in the number of directions implies an increase in runtime. Since evaluating the 200 directions of the template is quite expensive, we try using a concrete set after the discretization, instead of using a lazy discretization. This is achieved by passing the option approx_model=Forward(setops=octdirs) to the LGG09 algorithm, specifying that we want to oveapproximate the initial set of the set-based recurrence, that we call Ω0, with an octagonal template. It turns out in this example that the option gives a gain in runtime of 30, without a noticeable loss in precision.","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"alg = LGG09(δ=0.03, template=octdirs, approx_model=Forward(setops=octdirs));\nsol_PLAD01_BND30 = solve(prob_PLAD01,\n                         alg=alg,\n                         clustering_method=LazyClustering(1),\n                         intersection_method=TemplateHullIntersection(octdirs),\n                         intersect_source_invariant=false,\n                         tspan = (0.0 .. 20.0));\nnothing #hide","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"Verifying that the specification holds:","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"dmin_specification(sol_PLAD01_BND30, 30)","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"Let's check in more detail how close is the flowpipe to the safety conditions:","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"Minimum of x_1(t):","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"-ρ(sparsevec([1], [-1.0], 10), sol_PLAD01_BND30)","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"Minimum of x_4(t):","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"-ρ(sparsevec([4], [-1.0], 10), sol_PLAD01_BND30)","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"Minimum of x_7(t):","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"-ρ(sparsevec([7], [-1.0], 10), sol_PLAD01_BND30)","category":"page"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"plot(sol_PLAD01_BND30, vars=(0, 1), xlab=L\"t\", ylab=L\"x_1\", title=\"PLAD01 - BND30\", lw=0.1)\nplot!(x->x, x->-30., 0., 20., linewidth=2, color=\"red\", linestyle=:dash, leg=nothing)","category":"page"},{"location":"models/Platoon/#References","page":"Platoon","title":"References","text":"","category":"section"},{"location":"models/Platoon/","page":"Platoon","title":"Platoon","text":"[^]:","category":"page"},{"location":"man/hybrid/","page":"Hybrid systems","title":"Hybrid systems","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"man/hybrid/#Hybrid-systems","page":"Hybrid systems","title":"Hybrid systems","text":"","category":"section"},{"location":"man/hybrid/#Introduction","page":"Hybrid systems","title":"Introduction","text":"","category":"section"},{"location":"man/hybrid/","page":"Hybrid systems","title":"Hybrid systems","text":"Our running example is the bouncing ball model; although it is a very hybrid automaton, it can be used to introduce the main notions involved in hybrid systems reachability.","category":"page"},{"location":"man/hybrid/","page":"Hybrid systems","title":"Hybrid systems","text":"(Image: Hybrid automaton of the bouncing ball model)","category":"page"},{"location":"man/hybrid/#Formalism","page":"Hybrid systems","title":"Formalism","text":"","category":"section"},{"location":"man/hybrid/","page":"Hybrid systems","title":"Hybrid systems","text":"TODO: definition of HA","category":"page"},{"location":"man/hybrid/#Hybrid-solver-algorithm","page":"Hybrid systems","title":"Hybrid solver algorithm","text":"","category":"section"},{"location":"man/hybrid/","page":"Hybrid systems","title":"Hybrid systems","text":"TODO: high-level description of the hybrid solve","category":"page"},{"location":"man/hybrid/#Flowpipe-guard-intersections","page":"Hybrid systems","title":"Flowpipe-guard intersections","text":"","category":"section"},{"location":"man/hybrid/","page":"Hybrid systems","title":"Hybrid systems","text":"In this section we illustrate the available methods to compute flowpipe-guard intersections. We will see how to use the function cluster to select a clustering strategies to cope with the case when there are several intersecting sets. We will also show examples of choosing different intersection templates.","category":"page"},{"location":"man/hybrid/","page":"Hybrid systems","title":"Hybrid systems","text":"We'll take for our running example a two-dimensional rotating system with dynamics","category":"page"},{"location":"man/hybrid/","page":"Hybrid systems","title":"Hybrid systems","text":" beginaligned\n   dotx = y \n   doty = - x\nendaligned","category":"page"},{"location":"man/hybrid/","page":"Hybrid systems","title":"Hybrid systems","text":"and define the guard G (x y) in mathbbR^2 x  13 .","category":"page"},{"location":"man/hybrid/#Customizing-the-solver","page":"Hybrid systems","title":"Customizing the solver","text":"","category":"section"},{"location":"man/hybrid/","page":"Hybrid systems","title":"Hybrid systems","text":"TODO: further examples on how to customize the discrete post-operator","category":"page"},{"location":"lib/algorithms/BFFPSV18/#BFFPSV18","page":"BFFPSV18","title":"BFFPSV18","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/","page":"BFFPSV18","title":"BFFPSV18","text":"BFFPSV18","category":"page"},{"location":"lib/algorithms/BFFPSV18/#ReachabilityAnalysis.BFFPSV18","page":"BFFPSV18","title":"ReachabilityAnalysis.BFFPSV18","text":"BFFPSV18{N, ST, AM, IDX, BLK, RBLK, CBLK} <: AbstractContinuousPost\n\nImplementation of the reachability method for linear systems using block decompositions.\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: Forward) approximation model;                       see Notes below for possible options\nvars             – vector with the variables of interest\nblock_indices    – vector of integers to index each block that contains a variable of interest\nrow_blocks       – vector of integer vectors to index variables associated to blocks of interest\ncolumn_blocks    – vector of integer vectors to index variables in the partition\nlazy_initial_set – (optional, default: false) if true, use a lazy decomposition of the initial states                       after discretization\nlazy_input    – (optional, default: false) if true, use a lazy decomposition of the input set                     after discretization\nsparse        – (optional, default: false) if true, assume that the state transition                     matrix is sparse\nview          – (optional, default: false) if true, use implementaton that                    uses arrays views\n\nmatrix is sparse\n\nSee the Examples section below for some concrete examples of these options.\n\nNotes\n\nThis algorithm solves the set-based recurrence equation X_k+1 = ΦX_k  V_k by using block decompositions. The algorithm was introduced in [BFFPSV18].\n\nComments about some fields:\n\nN    – number type of the step-size, e.g. Float64\nST   – set representation used; this is either a concrete LazySet subtype,           eg. Interval{Float64, IntervalArithmetic.Interval{Float64}}, or a tuple           of concrete LazySet subtypes that is commensurate with the partition\n\nThe default approximation model is:\n\nForward(sih=:concrete, exp=:base, setops=:lazy)\n\nTODO:\n\nclarify assumption about contiguous blocks\n\nExamples\n\nReferences\n\nThis algorithm is essentially an extension of the method in [BFFPSV18]. Blocks can have different dimensions and the set represenation can be different for each block.\n\nFor a general introduction we refer to the dissertation [SCHI18].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in [FRE11].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/BFFPSV18/#Reachable-states-approximation","page":"BFFPSV18","title":"Reachable states approximation","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/","page":"BFFPSV18","title":"BFFPSV18","text":"In a nutshell, we overapproximate the reachable states of an affine system by solving a set-based recurrence. The key idea is that we first decompose the system into (low-dimensional) subsystems and later compose the results as a Cartesian product. Thus we have to solve many cheap problems instead of one hard problem. Since solving the recurrence scales superlinearly with the dimension, this approach is very scalable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Decomposition-error","page":"BFFPSV18","title":"Decomposition error","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition typically involves a loss in precision, and so does this approach. The good thing is that we can decompose the recurrence as well, which allows us to analyze each of the subsystems independently by only referring to the initial states of the other subsystems. Consequently, there are two main sources for precision loss:","category":"page"},{"location":"lib/algorithms/BFFPSV18/","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition of the initial states: If two subsystems are interdependent initially.\nRepresentation of the reachable states as a Cartesian product: If two subsystems are interdependent in the dynamics.\nRepresentation of the reachable states in general: The reachable states of affine systems cannot be represented precisely in all cases. This is a problem that all approaches suffer from. We overapproximate the reachable states by (unions of) convex polytopes.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Checking-safety-properties","page":"BFFPSV18","title":"Checking safety properties","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/","page":"BFFPSV18","title":"BFFPSV18","text":"The problem of checking a safety property can be reduced to a reachability problem. We provide special support for this reduction by inlining the property check into the reachable states computation. This has two benefits:","category":"page"},{"location":"lib/algorithms/BFFPSV18/","page":"BFFPSV18","title":"BFFPSV18","text":"We fail fast when the property is violated in our abstraction.\nThe check is usually cheaper than computing the full reachable states. This is because we are often only interested in an upper or lower bound of a variable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Lazy-sets","page":"BFFPSV18","title":"Lazy sets","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/","page":"BFFPSV18","title":"BFFPSV18","text":"To represent sets of states, we use the LazySets package which provides exact but lazy (i.e. symbolic) representations of common sets.","category":"page"},{"location":"lib/algorithms/TMJets/","page":"TMJets","title":"TMJets","text":"TMJets\nTMJets20\nTMJets21a\nTMJets21b","category":"page"},{"location":"lib/algorithms/TMJets/#ReachabilityAnalysis.TMJets","page":"TMJets","title":"ReachabilityAnalysis.TMJets","text":"TMJets\n\nThe algorithm TMJets defaults to TMJets21b.\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/TMJets/#ReachabilityAnalysis.TMJets20","page":"TMJets","title":"ReachabilityAnalysis.TMJets20","text":"TMJets20{N, DM<:AbstractDisjointnessMethod} <: AbstractContinuousPost\n\nValidated integration using Taylor models.\n\nFields\n\norderQ       – (optional, default: 2) order of the Taylor models for jet transport variables\norderT       – (optional, default: 8) order of the Taylor model in time\nabstol       – (optional, default: 1e-10) absolute tolerance\nmaxsteps     – (optional, default: 2000) maximum number of steps in the                    validated integration x = f(x)\nadaptive     – (optional, default: true) if true, try decreasing the absolute                    tolerance each time step validation fails, until min_abs_tol is reached\nminabstol    – (optional, default: 1e-29) minimum absolute tolerance for the adaptive algorithm\ndisjointness – (optional, default: ZonotopeEnclosure()) defines the method to                    perform the disjointness check between the taylor model flowpipe and the invariant\n\nNotes\n\nThe argument disjointness allows to control how are disjointness checks computed, in the case where the invariant is not universal. In particular, ZonotopeEnclosure() pre-processes the taylor model with a zonotopic overapproximation, then performs the disjointness check with that zonotope and the invariant. For other options, see the documentation of AbstractDisjointnessMethod.\n\nThis algorithm is an adaptation of the implementation in TaylorModels.jl (see copyright license in the file reach.jl of the current folder). The package TaylorIntegration.jl is used for jet-transport of ODEs using the Taylor method, and TaylorSeries.jl is used to work with truncated Taylor series.\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/TMJets/#ReachabilityAnalysis.TMJets21a","page":"TMJets","title":"ReachabilityAnalysis.TMJets21a","text":"TMJets21a{N, DM<:AbstractDisjointnessMethod} <: AbstractContinuousPost\n\nSet propagation using Taylor models with the function validated_integ in TaylorModels.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/TMJets/#ReachabilityAnalysis.TMJets21b","page":"TMJets","title":"ReachabilityAnalysis.TMJets21b","text":"TMJets21b{N, DM<:AbstractDisjointnessMethod} <: AbstractContinuousPost\n\nSet propagation using Taylor models with the function validated_integ in TaylorModels.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/","page":"Internal functions and macros","title":"Internal functions and macros","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/internals/#Internal-functions-and-macros","page":"Internal functions and macros","title":"Internal functions and macros","text":"","category":"section"},{"location":"lib/internals/","page":"Internal functions and macros","title":"Internal functions and macros","text":"This section of the manual includes some internal (i.e. unexported) functions and macros used within the library.","category":"page"},{"location":"lib/internals/","page":"Internal functions and macros","title":"Internal functions and macros","text":"Pages = [\"internals.md\"]\nDepth = 3","category":"page"},{"location":"lib/internals/#Function-annotations","page":"Internal functions and macros","title":"Function annotations","text":"","category":"section"},{"location":"lib/internals/","page":"Internal functions and macros","title":"Internal functions and macros","text":"@requires\n@commutative","category":"page"},{"location":"lib/internals/#ReachabilityAnalysis.@requires","page":"Internal functions and macros","title":"ReachabilityAnalysis.@requires","text":"@requires(module_name)\n\nConvenience macro to annotate that a package is required to use a certain function.\n\nInput\n\nmodule_name – name of the required package\n\nOutput\n\nThe macro expands to an assertion that checks whether the module module_name is known in the calling scope.\n\nNotes\n\nUsage:\n\nfunction foo(...)\n    @require MyPackage\n    ... # functionality that requires MyPackage to be loaded\nend\n\n\n\n\n\n","category":"macro"},{"location":"lib/internals/#ReachabilityAnalysis.@commutative","page":"Internal functions and macros","title":"ReachabilityAnalysis.@commutative","text":"@commutative(FUN)\n\nMacro to declare that a given function FUN is commutative, returning the original FUN and a new method of FUN where the first and second arguments are swapped.\n\nInput\n\nFUN – function name\n\nOutput\n\nA quoted expression containing the function definitions.\n\n\n\n\n\n","category":"macro"},{"location":"lib/internals/#Algorithm-defaults","page":"Internal functions and macros","title":"Algorithm defaults","text":"","category":"section"},{"location":"lib/internals/","page":"Internal functions and macros","title":"Internal functions and macros","text":"_default_cpost","category":"page"},{"location":"lib/internals/#ReachabilityAnalysis._default_cpost","page":"Internal functions and macros","title":"ReachabilityAnalysis._default_cpost","text":"_default_cpost(ivp::IVP{<:AbstractContinuousSystem}, tspan; kwargs...)\n\nInput\n\nivp   – initial-value problem\ntspan – time-span\n\nOutput\n\nA continuous post-operator that can handle the given initial-value problem.\n\nNotes\n\nIf the system is affine, then:\n\nIf it is one-dimensional, algorithm INT is used, otherwise,\nAlgorithm GLGM06 is used.\n\nIf the system is not affine, then the algorithm TMJets is used.\n\n\n\n\n\n","category":"function"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/Lorenz/Lorenz.jl\"","category":"page"},{"location":"models/Lorenz/#Lorenz-equations","page":"Lorenz system","title":"Lorenz equations","text":"","category":"section"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"(Image: )","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"note: Overview\nSystem type: Continuous blackbox system\nState dimension: 3\nApplication domain: Atmospheric convection","category":"page"},{"location":"models/Lorenz/#Model-description","page":"Lorenz system","title":"Model description","text":"","category":"section"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"The model is a system of three ordinary differential equations now known as the Lorenz equations:","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"  beginarraylcl\n  dfracdxdt  =  sigma (y-x)  \n  dfracdydt  =  x(rho - z) - y  \n  dfracdzdt  =  xy-beta z\n  endarray","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"The equations relate the properties of a two-dimensional fluid layer uniformly warmed from below and cooled from above. In particular, the equations describe the rate of change of three quantities with respect to time:x is proportional to the rate of convection, y to the horizontal temperature variation, and z to the vertical temperature variation. The constants sigma , rho , and beta  are system parameters proportional to the Prandtl number, Rayleigh number, and certain physical dimensions of the layer itself.","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"using ReachabilityAnalysis, Plots\n\n@taylorize function lorenz!(dx, x, params, t)\n    local σ = 10.0\n    local β = 8.0 / 3.0\n    local ρ = 28.0\n    dx[1] = σ * (x[2] - x[1])\n    dx[2] = x[1] * (ρ - x[3]) - x[2]\n    dx[3] = x[1] * x[2] - β * x[3]\n    return dx\nend","category":"page"},{"location":"models/Lorenz/#Reachability-settings","page":"Lorenz system","title":"Reachability settings","text":"","category":"section"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"The initial values considered are X_0 in 09 11 times 0 0 times 0 0, for a time span of 10.","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"X0 = Hyperrectangle(low=[0.9, 0.0, 0.0], high=[1.1, 0.0, 0.0])\nprob = @ivp(x' = lorenz!(x), dim=3, x(0) ∈ X0);\nnothing #hide","category":"page"},{"location":"models/Lorenz/#Results","page":"Lorenz system","title":"Results","text":"","category":"section"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"We compute the flowpipe using the TMJets algorithm with n_T=10 and n_Q=2.","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"alg = TMJets(abstol=1e-15, orderT=10, orderQ=2, maxsteps=50_000);\n\nsol = solve(prob, T=10.0, alg=alg);\n\nsolz = overapproximate(sol, Zonotope);\nnothing #hide","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"plot(solz, vars=(0, 1), xlab=\"t\", ylab=\"x\")","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"It is apparent by inspection that variable x(t) does not exceed 20.0 in the computed time span:","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"plot(solz(0.0 .. 1.5), vars=(0, 1), xlab=\"t\", ylab=\"x\", lw=0.0)\nplot!(x -> 20.0, c=:red, xlims=(0.0, 1.5), lab=\"\")","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"We can prove that it is the case by computing the support function of the flowpipe along direction [1.0, 0.0, 0.0]:","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"ρ([1.0, 0.0, 0.0], solz(0.0 .. 1.5))","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"In a similar fashion, we can compute extremal values of variable y(t):","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"plot(solz, vars=(0, 2), xlab=\"t\", ylab=\"y\")","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"Since we have computed overapproximations of the exact flowipe, the following quantities are a lower bound on the exact minimum (resp. an uppper bound on the exact maximum):","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"-ρ([0.0, -1.0, 0.0], solz)\n\nρ([0.0, 1.0, 0.0], solz)","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"plot(solz, vars=(0, 3), xlab=\"t\", ylab=\"z\")","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"Below we plot the flowpipe projected on the (1, 3) plane.","category":"page"},{"location":"models/Lorenz/","page":"Lorenz system","title":"Lorenz system","text":"plot(solz, vars=(1, 3))","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/OpAmp/OpAmp.jl\"","category":"page"},{"location":"models/OpAmp/#Amplifier-circuit","page":"Operational amplifier","title":"Amplifier circuit","text":"","category":"section"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"(Image: )","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"note: Overview\nSystem type: linear continuous system with piecewise-linear input\nState dimension: 2\nApplication domain: Electrical Engineering","category":"page"},{"location":"models/OpAmp/#Operational-amplifiers","page":"Operational amplifier","title":"Operational amplifiers","text":"","category":"section"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"Operational amplifiers (\"op-amp\") are electronic devices to amplify an input voltage signal. They are widely used to construct filters that remove a desired range of frequencies from the input signal.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"The schematic diagram of an op-amp is shown below. It has two terminals:","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"input side (left)\noutput terminal (right)","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"(Image: )","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"The output voltage is e_o = K(e_B - e_A), where K is the voltage gain of the op-amp. K is usually vey large (the order of 10^5 V  V).","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"In the ideal op-amp scenario, the following assumptions hold:","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"The input terminals of the op-amp draw negligible current.\nThe voltage difference at the input terminals e_B - e_A is zero.\nThe gain K is infinite.","category":"page"},{"location":"models/OpAmp/#Inverting-amplifier","page":"Operational amplifier","title":"Inverting amplifier","text":"","category":"section"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"Consider the following circuit, which consists of an ideal op-amp in the so-called inverting configuration.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"(Image: )","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"It is not hard to show [KLU15] that the output satisfies the following ODE:","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"   dfracde_o(t)dt = -dfrac1R_2 Ce_o(t) - dfrac1R_1Ce_in(t)","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"The circuit exhibits a transient behavior because of the capacitor connected in parallel to the op-amp. In the stationary limit t to infty, dfracde_o(t)dt = 0 and e_o = - fracR_2R_1 e_in. The gain is thus - fracR_2R_1 and the minus sign is the reason that this circuit is called inverting amplifier.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"The output voltage e_o(t) depends on the input voltage e_in(t). In order to highlight some typical assumptions on the inputs, in the rest of this notebook we model the input voltage in different ways:","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"Non-deterministic input with bounded range. This is the most general case, in which e_in(t) in E_in, with E_in subseteq mathbbR is an interval for the set of admissible inputs. This approach guarantees that the flowpipe covers all possible trajectories for any bounded, measurable, function e_in(t) satisfying the constraint e_in(t) in E_in for all t of the given time span.\nConstant input, a special case such that e_in(t) in E_in and e_in(t) is constant along trajectories.\nTime-varying input i.e. such that it is given by a (possibly time-varying) predefined function e_in(t) that is given by the solution of some ODE. In particular, we consider linear and exponential input functions.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"We will consider one by one the different approaches described above in the simple inverting amplifier circuit.","category":"page"},{"location":"models/OpAmp/#Non-deterministic-input","page":"Operational amplifier","title":"Non-deterministic input","text":"","category":"section"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"It is convenient to define constants α and β such that","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"dfracde_o(t)dt = α e_o(t) + β e_in(t).","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"In this section we assume that e_in(t) can be any (measurable) function whose range is contained in the set E_in.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"using ReachabilityAnalysis, Plots, LaTeXStrings\n\nfunction opamp_nondet(; X0 = Interval(0.0, 0.0),\n                        R₁ = 2., R₂ = 6., C = 1.e-3,\n                        Ein = Interval(1.9, 2.1))\n\n    α = hcat(-1/(R₂ * C))\n    β = hcat(-1/(R₁ * C))\n\n    # continuous evolution\n    invariant = Universe(1) # no state constraint\n    sys = @system(eout' = α*eout + β*ein, ein ∈ Ein, eout ∈ invariant)\n\n    # initial-value problem\n    return @ivp(sys, x(0) ∈ X0)\nend","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"sol_nondet = solve(opamp_nondet(), T=0.1, alg=INT(δ=1e-4));\nnothing #hide","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"tip: Performance tip\nWe have chosen the algorithm INT as it is the best choice in terms of efficiency for one-dimensional ODEs.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"fig = plot()\nplot!(fig, sol_nondet, vars=(0, 1), xlab=L\"t\", ylab=L\"e_{out}\", title=\"Solution for non-deterministic input\", lw=0.2)","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"The solution sol_nondet assumed that the initial state is at the origin. Now we solve for three different initial conditions of increasing width.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"fig = plot(xlab=L\"t\", ylab=L\"e_{out}(t)\", title=\"Solution for non-deterministic input\")\n\nΔt = 0 .. 0.04\n\nsol = solve(opamp_nondet(X0=Interval(-1.0, 1.0)), T=0.1, alg=INT(δ=1e-4));\nplot!(fig, sol(Δt), vars=(0, 1), lab=\"X0 = -1 .. 1\", lw=0.2)\n\nsol = solve(opamp_nondet(X0=Interval(-0.5, 0.5)), T=0.1, alg=INT(δ=1e-4));\nplot!(fig, sol(Δt), vars=(0, 1), lab=\"X0 = -0.5 .. 0.5\", lw=0.2)\n\nsol = solve(opamp_nondet(), T=0.1, alg=INT(δ=1e-4));\nplot!(fig, sol(Δt), vars=(0, 1), lab=\"X0 = 0\", lw=0.2)\n\nfig","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"tip: Visualization tip\nThe order in which we have defined the plots is such that the flowpipe with largest width comes first, so it doesn't overlap with those which are strictly included in it. This way, the final plot more clearly reveals the different flowpipes by their color.","category":"page"},{"location":"models/OpAmp/#Constant-input","page":"Operational amplifier","title":"Constant input","text":"","category":"section"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"We model the input voltage e_in(t) with a family of ODEs of the form","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"dfracd e_in(t)dt = gamma e_in(t) + delta.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"There are two distinct behaviors depending on the parameters gamma and delta:","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"gamma = delta = 0: e_in(t) = e_in 0 i.e. the input is constant over the given domain.\ngamma = 0: linear with rate delta, it is given by e_in(t) = delta t + e_in 0.\ngamma neq 0: exponential with rate gamma, it is given by e_in(t) = (e_in 0 + delta  gamma)e^gamma t - delta  gamma.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"Moreover, it is natural to assume that the input saturates at a given threshold value. The following function, opamp_with_saturation, models the system as a hybrid automaton with two modes: in the first mode, the input signal e_in(t) varies according to the specified dynamics, and in the second mode, the input signal saturates and ceases to increase (or decrease, depding on the signs chosen).","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"In this section we consider the constant input scenario,","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"e_in(0)  E_in 0, e_in(t) constant.\ndelta = 0\ngamma = 0","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"In the following section we consider the other cases.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"using Symbolics\n\nfunction opamp_with_saturation(; X0 = BallInf(zeros(2), 0.0),\n                                 R₁ = 2., R₂ = 6., C = 1.e-3,\n                                 γ = 100., δ = 100., Es = 2.)\n    var = @variables eₒ ein\n    α = hcat(-1/(R₂ * C))\n    β = hcat(-1/(R₁ * C))\n\n    # transition graph\n    automaton = LightAutomaton(2)\n    add_transition!(automaton, 1, 2, 1)\n\n    # modes\n    A = [α β; 0. γ]\n    b = [0.; δ]\n    invariant = HalfSpace(ein <= Es, var)\n    mode1 = @system(x' = Ax + b, x ∈ invariant)\n    A = [α β; 0. 0.];\n    mode2 = @system(x' = Ax, x ∈ Universe(2))\n    modes = [mode1, mode2]\n\n    # transition mode1 -> mode2 (saturation)\n    guard = Hyperplane(ein == Es, var)\n    t1 = @map(x -> x, dim:2, x ∈ guard)\n    resetmaps = [t1]\n\n    H = HybridSystem(automaton, modes, resetmaps, [AutonomousSwitching()])\n\n    # initial condition is at the origin in mode 1\n    initial_condition = [(1, X0)]\n    return IVP(H, initial_condition)\nend","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"Observe that in the model defined above, the first coordinate of the state-space corresponds to the output e_o(t), while the second coordinate, e_in(t), corresponds to the input signal e_in(t).","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"We specify that the initial condition is such that e_o(0) is at the origin, and e_in(0)  14  16.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"X0 = Hyperrectangle([0., 1.5], [0.0, 0.1]);\nnothing #hide","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"The value of the saturation constant Es is chosen to be sufficiently high such that the system doesn't transition to mode 2.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"prob_const = opamp_with_saturation(X0=X0, γ = 0., δ = 0., Es = 3.)\nsol_const = solve(prob_const, T=0.1, alg=BOX(δ=1e-4));\nnothing #hide","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"plot(sol_const, vars=(0, 2), xlab=L\"t\", ylab=L\"e_{in}(t)\", title=\"Constant input signal\", lw=0.2)\nplot!(x->x, x->1.5, 0., 0.1, line=2, color=\"red\", linestyle=:dash, legend=nothing)","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"plot(sol_const, vars=(0, 1), xlab=L\"t\", ylab=L\"e_{out}(t)\", title=\"Solution for constant input\", lw=0.2)","category":"page"},{"location":"models/OpAmp/#Time-varying-input","page":"Operational amplifier","title":"Time-varying input","text":"","category":"section"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"For the time-varying with a prescribed function case, we consider two scenarios:","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"Linearly increasing input voltage: delta neq 0, gamma = 0.\nExponentially increasing input voltage (up to saturation at Es = 1.0): delta neq 0, gamma  0.","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"For both cases we consider that set of initial states is the origin:","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"X0 = Singleton(zeros(2));\nnothing #hide","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"We solve both instances by choosing som values of δ and γ:","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"# linearly increasing input signal\nprob_lin = opamp_with_saturation(X0=X0, γ=0., δ=100., Es=1.);\nsol_lin = solve(prob_lin, T=0.1, alg=BOX(δ=1e-4));\n\n# exponentially increasing input signal\nprob_exp = opamp_with_saturation(X0=X0, γ=-100., δ=100., Es=3.);\nsol_exp = solve(prob_exp, T=0.1, alg=BOX(δ=1e-4));\nnothing #hide","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"plot(sol_lin, vars=(0, 2), xlab=L\"t\", ylab=L\"e_{in}(t)\", title=\"Linear input w/saturation\", lw=0.2)","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"plot(sol_exp, vars=(0, 2), xlab=L\"t\", ylab=L\"e_{in}(t)\", title=\"Exponential input\", lw=0.2)","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"plot(sol_lin, vars=(0, 1), xlab=L\"t\", ylab=L\"e_{out}(t)\", title=\"Solution for linear input\", lw=0.2)","category":"page"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"plot(sol_exp, vars=(0, 1), xlab=L\"t\", ylab=L\"e_{out}(t)\", title=\"Solution for exponential input\", lw=0.2)","category":"page"},{"location":"models/OpAmp/#References","page":"Operational amplifier","title":"References","text":"","category":"section"},{"location":"models/OpAmp/","page":"Operational amplifier","title":"Operational amplifier","text":"[KLU15]: Kluever, C. A. (2015). Dynamic systems: modeling, simulation, and control. John Wiley & Sons.","category":"page"},{"location":"lib/algorithms/VREP/","page":"VREP","title":"VREP","text":"VREP","category":"page"},{"location":"lib/algorithms/VREP/#ReachabilityAnalysis.VREP","page":"VREP","title":"ReachabilityAnalysis.VREP","text":"VREP{N, AM, S, D} <: AbstractContinuousPost\n\nImplementation of a linear reachability solver using the vertex representation.\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/VREP/#Method","page":"VREP","title":"Method","text":"","category":"section"},{"location":"lib/algorithms/VREP/","page":"VREP","title":"VREP","text":"This algorithm solves the recurrence relation","category":"page"},{"location":"lib/algorithms/VREP/","page":"VREP","title":"VREP","text":"X_k+1 = Phi X_k oplus V_k","category":"page"},{"location":"lib/algorithms/VREP/","page":"VREP","title":"VREP","text":"using the vertex representation of the sets involved. If the system is homogeneous, i.e. V_k =  for all k geq 0, then the number of vertices of the sequence doesn't increase. On the other hand, the number of vertices of X_k increases hence the method requires doing some conservative reduction strategy.","category":"page"},{"location":"lib/algorithms/VREP/","page":"VREP","title":"VREP","text":"The method is aimed towards small dimensional systems – typically n  15 – which show a substantial benefit by using heap-allocated statically sized arrays through the StaticArrays.jl package. To use static arrays, pass the option static=true. Optionally, a dimension field can be passed to the VREP algorithm constructor too using the dim keyword argument. (It is sometimes useful that Julia is able to infer the set representation, or type, of the output flowpipe based only on the algorithm choice, but since the length of a vector is stored as type information for the case of static arrays, it has to be given in advance.)","category":"page"},{"location":"lib/algorithms/VREP/#Specifying-the-backend","page":"VREP","title":"Specifying the backend","text":"","category":"section"},{"location":"lib/algorithms/VREP/","page":"VREP","title":"VREP","text":"If the dimension of the system is two, VREP uses efficient algorithms for convex polygons (e.g. convex hull, Minkowski sum) implemented in LazySets.jl. On the other hand, for systems of dimension higher than two, concrete polyhedral computations use the Polyhedra.jl libary which itself relies on specific backends, which can be specified with the backend keyword argument in the VREP algorithm constructor. Such backend is used in the discretization phase. Actually, Polyhedra.jl features a default solver (hence it doesn't require additional packages apart from Polyhedra.jl itself), although for efficiency reasons we suggest to use CDDLib.jl. For example, to use CDDLib in a 4-dimensional system, do","category":"page"},{"location":"lib/algorithms/VREP/","page":"VREP","title":"VREP","text":"using ReachabilityAnalysis, Polyhedra, CDDLib\n\n# ... define model ...\n# prob = @ivp(...)\nalg = VREP(δ=1e-3, static=true, dim=4, backend=CDDLib.Library()))\nsolve(prob, tspan=(0.0, 1.0), alg=alg)","category":"page"},{"location":"lib/algorithms/VREP/","page":"VREP","title":"VREP","text":"Other backends are available e.g. QHull.jl.","category":"page"},{"location":"lib/projections/","page":"Projections","title":"Projections","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/projections/#Projections","page":"Projections","title":"Projections","text":"","category":"section"},{"location":"lib/projections/#Concrete-projection","page":"Projections","title":"Concrete projection","text":"","category":"section"},{"location":"lib/projections/","page":"Projections","title":"Projections","text":"TODO: document project","category":"page"},{"location":"lib/projections/#Lazy-projection","page":"Projections","title":"Lazy projection","text":"","category":"section"},{"location":"lib/projections/","page":"Projections","title":"Projections","text":"TODO: document Projection","category":"page"},{"location":"man/clocked/","page":"Clocked systems","title":"Clocked systems","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"man/clocked/#Clocked-hybrid-systems","page":"Clocked systems","title":"Clocked hybrid systems","text":"","category":"section"},{"location":"man/clocked/#Time-triggered-LHA","page":"Clocked systems","title":"Time-triggered LHA","text":"","category":"section"},{"location":"man/clocked/","page":"Clocked systems","title":"Clocked systems","text":"So far we have focused on transitions that involve \"spatial\" variables. If the system under consideration has transitions governed by time variables, i.e. by variables whose dynamics are of the form t = 1, then decoupling the spatial variables with the clock variables gives a computational advantage. We refer to [[HG19]].","category":"page"},{"location":"man/clocked/","page":"Clocked systems","title":"Clocked systems","text":"(Image: Hybrid automaton of the clocked model)","category":"page"},{"location":"man/clocked/","page":"Clocked systems","title":"Clocked systems","text":"(Image: Timeline of relevant events)","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/Quadrotor/Quadrotor.jl\"","category":"page"},{"location":"models/Quadrotor/#Quadrotor","page":"Quadrotor","title":"Quadrotor","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"(Image: )","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"note: Overview\nSystem type: polynomial continuous system\nState dimension: 2\nApplication domain: Chemical kinetics","category":"page"},{"location":"models/Quadrotor/#Model-description","page":"Quadrotor","title":"Model description","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"We study the dynamics of a quadrotor as derived in [xxx]. Let us first introduce the variables required to describe the model: the inertial (north) position x_1, the inertial (east) position x_2, the altitude x_3, the longitudinal velocity x_4, the lateral velocity x_5, the vertical velocity x_6, the roll angle x_7, the pitch angle x_8, the yaw angle x_9, the roll rate x_10, the pitch rate x_11, and the yaw rate x_12. We further  require the following parameters: gravity constant g = 981 [m/s^2], radius of center mass R = 01 [m], distance of motors to center mass l = 05 [m], motor mass M_rotor = 01 [kg], center mass M = 1 [kg], and total mass m = M + 4M_rotor.","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"From the above parameters we can compute the moments of inertia as","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"beginarraylcll\nJ_x  =  frac25 M R^2 + 2 l^2 M_rotor \nJ_y  =  J_x \nJ_z  =  frac25 M R^2 + 4 l^2 M_rotor\nendarray","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"Finally, we can write the set of ordinary differential equations for the quadrotor according to [xxx]:","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"left\nbeginarraylcl\ndotx_1  =  cos(x_8)cos(x_9)x_4 + Big(sin(x_7)sin(x_8)cos(x_9) - cos(x_7)sin(x_9)Big)x_5 \n  + Big(cos(x_7)sin(x_8)cos(x_9) + sin(x_7)sin(x_9)Big)x_6 \ndotx_2  =  cos(x_8)sin(x_9)x_4 + Big(sin(x_7)sin(x_8)sin(x_9) + cos(x_7)cos(x_9)Big)x_5 \n  + Big(cos(x_7)sin(x_8)sin(x_9) - sin(x_7)cos(x_9)Big)x_6 \ndotx_3  =  sin(x_8)x_4 - sin(x_7)cos(x_8)x_5 - cos(x_7)cos(x_8)x_6 \ndotx_4  =  x_12x_5 - x_11x_6 - gsin(x_8) \ndotx_5  =  x_10x_6 - x_12x_4 + gcos(x_8)sin(x_7) \ndotx_6  =  x_11x_4 - x_10x_5 + gcos(x_8)cos(x_7) - fracFm \ndotx_7  =  x_10 + sin(x_7)tan(x_8)x_11 + cos(x_7)tan(x_8)x_12 \ndotx_8  =  cos(x_7)x_11 - sin(x_7)x_12 \ndotx_9  =  fracsin(x_7)cos(x_8)x_11 + fraccos(x_7)cos(x_8)x_12 \ndotx_10  =  fracJ_y - J_zJ_xx_11x_12 + frac1J_xtau_phi \ndotx_11  =  fracJ_z - J_xJ_yx_10x_12 + frac1J_ytau_theta \ndotx_12  =  fracJ_x - J_yJ_zx_10x_11 + frac1J_ztau_psi\nendarray\nright","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"To check interesting control specifications, we stabilize the quadrotor using simple PD controllers for height, roll, and pitch. The inputs to the controller are the desired values for height, roll, and pitch u_1, u_2, and u_3, respectively. The equations of the controllers are:","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"beginarraylcll\nF  =  m  g - 10(x_3 - u_1) + 3x_6   (textheight control) \ntau_phi  =  -(x_7 - u_2) - x_10  (textroll control) \ntau_theta  =  -(x_8 - u_3) - x_11  (textpitch control)\nendarray","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"We leave the heading uncontrolled so that we set tau_psi = 0.","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"using ReachabilityAnalysis\nusing ReachabilityAnalysis: is_intersection_empty","category":"page"},{"location":"models/Quadrotor/#Reachability-settings","page":"Quadrotor","title":"Reachability settings","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"#The task is to change the height from ``0``~[m] to ``1``~[m] within ``5``~[s].","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"A goal region 098102 of the height x_3 has to be reached within 5~[s] and the height has to stay below 14 for all times. After 1~[s] the height should stay above 09~[m]. The initial value for the position and velocities (i.e., from x_1 to x_6) is uncertain and given by -DeltaDelta~[m], with Delta=04. All other variables are initialized to 0. This preliminary analysis must be followed by a corresponding evolution for Delta = 01 and Delta= 08 while keeping all the settings the same. No goals are specified for these cases: the objective instead is to understand the scalability of each tool with fixed settings.","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"parameters of the model","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"const g = 9.81           # gravity constant in m/s^2\nconst R = 0.1            # radius of center mass in m\nconst l = 0.5            # distance of motors to center mass in m\nconst Mrotor = 0.1       # motor mass in kg\nconst M = 1.0            # center mass in kg\nconst m = M + 4*Mrotor   # total mass in kg\nconst mg = m*g","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"moments of inertia","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"const Jx = (2/5)*M*R^2 + 2*l^2*Mrotor\nconst Jy = Jx\nconst Jz = (2/5)*M*R^2 + 4*l^2*Mrotor\nconst Cyzx = (Jy - Jz)/Jx\nconst Czxy = (Jz - Jx)/Jy\nconst Cxyz = 0.0 #(Jx - Jy)/Jz","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"considering the control parameters as parameters","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"const u₁ = 1.0\nconst u₂ = 0.0\nconst u₃ = 0.0\n\nconst Tspan = (0.0, 5.0)\nconst v3 = LazySets.SingleEntryVector(3, 12, 1.0)\n\n@inline function quad_property(solz)\n    tf = tend(solz)\n\n    #Condition: b1 = (x[3] < 1.4) for all time\n    unsafe1 = HalfSpace(-v3, -1.4) # unsafe: -x3 <= -1.4\n    b1 =  all([is_intersection_empty(unsafe1, set(R)) for R in solz(0.0 .. tf)])\n    #b1 = ρ(v3, solz) < 1.4\n\n    #Condition: x[3] > 0.9 for t ≥ 1.0\n    unsafe2 = HalfSpace(v3, 0.9) # unsafe: x3 <= 0.9\n    b2 = all([is_intersection_empty(unsafe2, set(R)) for R in solz(1.0 .. tf)])\n\n    #Condition: x[3] ⊆ Interval(0.98, 1.02) for t ≥ 5.0 (t=5 is `tf`)\n    b3 = set(project(solz[end], vars=(3))) ⊆ Interval(0.98, 1.02)\n\n    return b1 && b2 && b3\nend\n\n@taylorize function quadrotor!(dx, x, params, t)\n    #unwrap the variables and the controllers; the last three are the controllers\n    #x₁, x₂, x₃, x₄, x₅, x₆, x₇, x₈, x₉, x₁₀, x₁₁, x₁₂, u₁, u₂, u₃ = x\n    x₁  = x[1]\n    x₂  = x[2]\n    x₃  = x[3]\n    x₄  = x[4]\n    x₅  = x[5]\n    x₆  = x[6]\n    x₇  = x[7]\n    x₈  = x[8]\n    x₉  = x[9]\n    x₁₀ = x[10]\n    x₁₁ = x[11]\n    x₁₂ = x[12]\n\n    #equations of the controllers\n    F = (mg - 10*(x₃ - u₁)) + 3*x₆  # height control\n    τϕ = -(x₇ - u₂) - x₁₀            # roll control\n    τθ = -(x₈ - u₃) - x₁₁            # pitch control\n    local τψ = 0.0                   # heading is uncontrolled\n\n    Tx = τϕ/Jx\n    Ty = τθ/Jy\n    Tz = τψ/Jz\n    F_m = F/m\n\n    #Some abbreviations\n    sx7 = sin(x₇)\n    cx7 = cos(x₇)\n    sx8 = sin(x₈)\n    cx8 = cos(x₈)\n    sx9 = sin(x₉)\n    cx9 = cos(x₉)\n\n    sx7sx9 = sx7*sx9\n    sx7cx9 = sx7*cx9\n    cx7sx9 = cx7*sx9\n    cx7cx9 = cx7*cx9\n    sx7cx8 = sx7*cx8\n    cx7cx8 = cx7*cx8\n    sx7_cx8 = sx7/cx8\n    cx7_cx8 = cx7/cx8\n\n    x4cx8 = cx8*x₄\n\n    p11 = sx7_cx8*x₁₁\n    p12 = cx7_cx8*x₁₂\n    xdot9 = p11 + p12\n\n    #differential equations for the quadrotor\n\n    dx[1] = (cx9*x4cx8 + (sx7cx9*sx8 - cx7sx9)*x₅) + (cx7cx9*sx8 + sx7sx9)*x₆\n    dx[2] = (sx9*x4cx8 + (sx7sx9*sx8 + cx7cx9)*x₅) + (cx7sx9*sx8 - sx7cx9)*x₆\n    dx[3] = (sx8*x₄ - sx7cx8*x₅) - cx7cx8*x₆\n    dx[4] = (x₁₂*x₅ - x₁₁*x₆) - g*sx8\n    dx[5] = (x₁₀*x₆ - x₁₂*x₄) + g*sx7cx8\n    dx[6] = (x₁₁*x₄ - x₁₀*x₅) + (g*cx7cx8 - F_m)\n    dx[7] = x₁₀ + sx8*xdot9\n    dx[8] = cx7*x₁₁ - sx7*x₁₂\n    dx[9] = xdot9\n    dx[10] = Cyzx * (x₁₁ * x₁₂) + Tx\n    dx[11] = Czxy * (x₁₀ * x₁₂) + Ty\n    dx[12] = Cxyz * (x₁₀ * x₁₁) + Tz\n\n    return dx\nend\n\nfunction quadrotor(; T=5.0, plot_vars=[0, 3],\n                property=quad_property,\n                project_reachset=true,\n                Wpos = 0.4, Wvel = 0.4)\n\n    #initial conditions\n    X0c = zeros(12)\n    ΔX0 = [Wpos, Wpos, Wpos, Wvel, Wvel, Wvel, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    X0 = Hyperrectangle(X0c, ΔX0)\n\n    #initial-value problem\n    prob = @ivp(x' = quadrotor!(x), dim: 12, x(0) ∈ X0);\n\n    return prob\nend","category":"page"},{"location":"models/Quadrotor/#Results","page":"Quadrotor","title":"Results","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"cases = [\"Δ=0.1\", \"Δ=0.4\", \"Δ=0.8\"];\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"","category":"page"},{"location":"models/Quadrotor/#Case-1:-smaller-uncertainty","page":"Quadrotor","title":"Case 1: smaller uncertainty","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"Wpos = 0.1\nWvel = 0.1\nprob = quadrotor(project_reachset=false, Wpos=Wpos, Wvel=Wvel)\nalg = TMJets(abstol=1e-7, orderT=5, orderQ=1, adaptive=false)","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"Warm-up run","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"sol1 = solve(prob, tspan=Tspan, alg=alg);\nsolz1 = overapproximate(sol1, Zonotope);\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"","category":"page"},{"location":"models/Quadrotor/#Case-2:-intermediate-uncertainty","page":"Quadrotor","title":"Case 2: intermediate uncertainty","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"Wpos = 0.4\nWvel = 0.4\nprob = quadrotor(project_reachset=false, Wpos=Wpos, Wvel=Wvel)\nalg = TMJets(abstol=1e-7, orderT=5, orderQ=1, adaptive=false)","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"warm-up run","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"sol2 = solve(prob, tspan=Tspan, alg=alg);\nsolz2 = overapproximate(sol2, Zonotope);\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"verify that specification holds","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"#property = quad_property(solz2)\n#println(\"Validate property, case $(cases[2]) : $(property)\")","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"","category":"page"},{"location":"models/Quadrotor/#Case-3:-large-uncertainty","page":"Quadrotor","title":"Case 3: large uncertainty","text":"","category":"section"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"Wpos = 0.8\nWvel = 0.8\nprob = quadrotor(project_reachset=false, Wpos=Wpos, Wvel=Wvel)\nalg = TMJets(abstol=1e-7, orderT=5, orderQ=1, adaptive=false)","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"Warm-up run","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"sol3 = solve(prob, tspan=Tspan, alg=alg);\nsolz3 = overapproximate(sol3, Zonotope);\nnothing #hide","category":"page"},{"location":"models/Quadrotor/","page":"Quadrotor","title":"Quadrotor","text":"using Plots\n\nPlots.plot(solz3,  vars=(0, 3), linecolor=\"green\",  color=:green,  alpha=0.8)\nPlots.plot!(solz2, vars=(0, 3), linecolor=\"blue\",   color=:blue,   alpha=0.8)\nPlots.plot!(solz1, vars=(0, 3), linecolor=\"yellow\", color=:yellow, alpha=0.8,\n    xlab=\"t\", ylab=\"x3\",\n    xtick=[0., 1., 2., 3., 4., 5.], ytick=[-1., -0.5, 0., 0.5, 1., 1.5],\n    xlims=(0., 5.), ylims=(-1., 1.5))","category":"page"},{"location":"models/Heat3D/","page":"Heat PDE","title":"Heat PDE","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/Heat3D/Heat3D.jl\"","category":"page"},{"location":"models/Heat3D/#Heat-PDE","page":"Heat PDE","title":"Heat PDE","text":"","category":"section"},{"location":"models/Heat3D/","page":"Heat PDE","title":"Heat PDE","text":"(Image: )","category":"page"},{"location":"models/Heat3D/","page":"Heat PDE","title":"Heat PDE","text":"note: Overview\nSystem type: Affine system\nState dimension: 48\nApplication domain: Mechanical Engineering","category":"page"},{"location":"models/Heat3D/#Model-description","page":"Heat PDE","title":"Model description","text":"","category":"section"},{"location":"models/Heat3D/","page":"Heat PDE","title":"Heat PDE","text":"The system is described by the linear differential equations:","category":"page"},{"location":"models/Heat3D/","page":"Heat PDE","title":"Heat PDE","text":"  beginarraylcl\n  dotx(t) = Ax(t) + Bu(t)qquad u(t) in mathcalU \n  y(t) = C x(t)\n  endarray","category":"page"},{"location":"models/Heat3D/","page":"Heat PDE","title":"Heat PDE","text":"There are two versions of this benchmark:","category":"page"},{"location":"models/Heat3D/","page":"Heat PDE","title":"Heat PDE","text":"(time-varying inputs): The inputs can change arbitrarily over time: forall t u(t)in mathcalU.\n(constant inputs): The inputs are uncertain only in their initial value, and  constant over time: u(0)in mathcalU, dot u (t)= 0.","category":"page"},{"location":"models/Heat3D/","page":"Heat PDE","title":"Heat PDE","text":"using ReachabilityAnalysis, SparseArrays, JLD2\n\nexamples_dir = normpath(@__DIR__, \"..\", \"..\", \"..\", \"examples\")\nHEAT01_path = joinpath(examples_dir, \"Heat3D\", \"HEAT01.jld2\")","category":"page"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"man/benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"man/benchmarks/#Scalability-evaluation","page":"Benchmarks","title":"Scalability evaluation","text":"","category":"section"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Scalability is very important in the applicability of a tool. For illustration purposes, in this section we consider the scalability of the hybrid reachability solver, using different algorithm choices, for the filtered switched oscillator model from [FRE11]. The model consists of a two-dimensional switched oscillator and a parametric number of filters which are used to smooth the oscilllator's state. An interesting aspect of the model is that it is scalable: the total number of continuous variables can be made arbitrarily large. Moreover, this is a challenging benchmark since several dozens of reach-sets may take each discrete jumps, hence clustering methods are indispensible.","category":"page"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The continuous variables x and y are used to denote the state of the oscillator, and the remaining m variables are used for the state of the filters. In this evaluation we consider that the number of filters ranges from 64 to 1024. To measure the quality of the approximations, we consider the safety property given by y(t)  05 for all t  0 T.","category":"page"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The filtered oscillator was also studied in [BFFPS19] to test the scalability of a new scheme that exploits the sparsity of the hybrid automaton to efficiently compute flowpipe-guard intersections. Such scheme is not considered in this section.","category":"page"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Recall that for a system of n variables, a box overapproximation requires to compute n samples of the approximation boundary, whereas an octagon requires O(n^2) many. Hence, using an octagon template, while gives tighter results in general, may incur in much higher computational cost if n is high.","category":"page"},{"location":"man/benchmarks/#Model","page":"Benchmarks","title":"Model","text":"","category":"section"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using ReachabilityAnalysis\n\none_loop_iteration = false\nn0 = 4\nn1 = (one_loop_iteration ? n0 + 1 : n0)\nn = n1 + 2\nz = zeros(n1)\n\n## common flow\nA = zeros(n, n)\nA[1,1], A[2,2] = -2., -1.\nA[3,1], A[3,3] = 5., -5.\nfor i = 4 : n-1\n    A[i,i-1], A[i,i] = 5., -5.\nend\n\nfunction mode1(z)\n    b = [1.4; -0.7; z]\n    X = HPolyhedron([HalfSpace([-0.714286; -1.0; z], 0.0),  # 0.714286*x + y >= 0\n                     HalfSpace([1.0; 0.0; z], 0.0)])  # x <= 0\n    @system(x' = Ax + b, x ∈ X)\nend\n\nfunction mode2(z)\n    b = [-1.4; 0.7; z]\n    X = HPolyhedron([HalfSpace([1.0; 0.0; z], 0.0),  # x <= 0\n                     HalfSpace([0.714286; 1.0; z], 0.0)])  # 0.714286*x + y <= 0\n    @system(x' = Ax + b, x ∈ X)\nend\n\nfunction mode3(z)\n    b = [1.4; -0.7; z]\n    X = HPolyhedron([HalfSpace([-1.0; 0.0; z], 0.0),  # x >= 0\n                     HalfSpace([-0.714286; -1.0; z], 0.0)])  # 0.714286*x + y >= 0\n    @system(x' = Ax + b, x ∈ X)\nend\n\nfunction mode4(z, one_loop_iteration)\n    b = [-1.4; 0.7; z]\n    X = HPolyhedron([HalfSpace([0.714286; 1.0; z], 0.0),  # 0.714286*x + y <= 0\n                     HalfSpace([-1.0; 0.0; z], 0.0)])  # x >= 0\n\n    if one_loop_iteration\n        ## k <= 2 (2.1 to avoid numerical issues)\n        addconstraint!(X, HalfSpace([zeros(n-1); 1.], 2.1))\n    end\n    @system(x' = Ax + b, x ∈ X)\nend\n\n\nfunction filtered_oscillator_hybrid(n0, one_loop_iteration)\n\n    n1 = (one_loop_iteration ? n0 + 1 : n0)\n    n = n1 + 2\n    z = zeros(n1)\n\n    ## transition graph (automaton)\n    a = LightAutomaton(4)\n    add_transition!(a, 3, 4, 1)\n    add_transition!(a, 4, 2, 2)\n    add_transition!(a, 2, 1, 3)\n    add_transition!(a, 1, 3, 4)\n\n    mode1 = mode1(z)\n    mode2 = mode2(z)\n    mode3 = mode3(z)\n    mode4 = mode4(z, one_loop_iteration)\n    m = [mode1, mode2, mode3, mode4]\n\n    ## transitions\n\n    ## transition l3 -> l4\n    X_l3l4 = HPolyhedron([HalfSpace([-1.0; 0.0; z], 0.0),  # x >= 0\n                          HalfSpace([-0.714286; -1.0; z], 0.0),  # 0.714286*x + y >= 0\n                          HalfSpace([0.714286; 1.0; z], 0.0)])  # 0.714286*x + y <= 0\n    if one_loop_iteration\n        A_trans_34 = Matrix(1.0I, n, n)\n        A_trans_34[n, n] = 2.  # k' = k * 2\n        r1 = ConstrainedLinearMap(A_trans_34, X_l3l4)\n    else\n        r1 = ConstrainedIdentityMap(n, X_l3l4)\n    end\n\n    ## transition l4 -> l2\n    X_l4l2 = HPolyhedron([HalfSpace([0.714286; 1.0; z], 0.0),  # 0.714286*x + y <= 0\n                          HalfSpace([-1.0; 0.0; z], 0.0),  # x >= 0\n                          HalfSpace([1.0; 0.0; z], 0.0)])  # x <= 0\n    r2 = ConstrainedIdentityMap(n, X_l4l2)\n\n    ## transition l2 -> l1\n    X_l2l1 = HPolyhedron([HalfSpace([1.0; 0.0; z], 0.0),  # x <= 0\n                          HalfSpace([-0.714286; -1.0; z], 0.0),  # 0.714286*x + y >= 0\n                          HalfSpace([0.714286; 1.0; z], 0.0)])  # 0.714286*x + y <= 0\n    r3 = ConstrainedIdentityMap(n, X_l2l1)\n\n    ## transition l1 -> l3\n    X_l1l3 = HPolyhedron([HalfSpace([-0.714286; -1.0; z], 0.0),  # 0.714286*x + y >= 0\n                          HalfSpace([-1.0; 0.0; z], 0.0),  # x >= 0\n                          HalfSpace([1.0; 0.0; z], 0.0)])  # x <= 0\n    r4 = ConstrainedIdentityMap(n, X_l1l3)\n\n    r = [r1, r2, r3, r4]\n\n    ## switchings\n    s = [HybridSystems.AutonomousSwitching()]\n\n    return HybridSystem(a, m, r, s)\nend\n\nfunction fosc(X0; n0::Int=4, one_loop_iteration::Bool=false)\n    H = filtered_oscillator_hybrid(n0, one_loop_iteration)\n    return IVP(H, [(1, X0)])\nend","category":"page"},{"location":"man/benchmarks/#Benchmark-repository","page":"Benchmarks","title":"Benchmark repository","text":"","category":"section"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmark suite of JuliaReach is available at the ReachabilityBenchmarks repository.","category":"page"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The repository includes:","category":"page"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Benchmarks for all models in the ReachabilityAnalysis.jl test suite.\nBenchmarks for models which are not part of the ReachabilityAnalysis.jl test suite, and are used to detect regressions (i.e. examples that accidentally run slower, due to changes in core downstream libraries such as LazySets.jl).\nThe SLICOT models, from the SLICOT Model and Controller Reduction Toolbox, which reflect real world applications with dimensions ranging from several dozens to over 10.000.","category":"page"},{"location":"man/benchmarks/#Repeatability-evaluations","page":"Benchmarks","title":"Repeatability evaluations","text":"","category":"section"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Traditionally, re-creation of computational results in research work is a challenging task because details of the implementation are unavoidably absent in the paper. Some authors post their code and data to their websites, but there is little formal incentive to do so and no easy way to determine whether others can actually use the result. As a consequence, computational results often become non reproducible – even by the research group which originally produced them – after just a few years.","category":"page"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"More recently, scientific conferences encourage and sometimes require that authors improve the reproducibility of their computational results by providing suitable reproducibility evaluation (RE) packages. Such RE are self-contained codes that can be used to run and reproduce the results from the paper in a host machine. Fortunately, the tools available for the Julia language are very convenenient to prepare and distribute RE packages. The following RE packages are available:","category":"page"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"ARCH2020 NLN RE – Repeatability Evaluation package for the ARCH2020 Nonlinear Continuous and Hybrid Systems Competition.\nARCH2020 AFF RE – Repeatability Evaluation package for the ARCH2020 Linear and Hybrid Systems Competition.\nHSCC2019 RE – Repeatability Evaluation (RE) package for the paper JuliaReach: a Toolbox for Set-Based Reachability published at the HSCC'2019 conference.\nARCH2019 RE – Repeatability Evaluation package for the ARCH2019 Competition.\nARCH2018 RE – Repeatability Evaluation package for the ARCH2018 Competition.","category":"page"},{"location":"man/benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"For installation instructions, see the README file in each package. We have examples using virtual machines, and also using Docker containers for RE packages. The advantage of using a Docker container is that downloading the necessary requirements (including Julia itself) is an automated process.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/VanDerPol/VanDerPol.jl\"","category":"page"},{"location":"models/VanDerPol/#Van-der-Pol-oscillator","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"","category":"section"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"(Image: )","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"note: Overview\nSystem type: polynomial continuous system\nState dimension: 2\nApplication domain: Nonlinear physics","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"The Van der Pol oscillator was introduced by the Dutch physicist Balthasar van der Pol. This is a famous model, typically investigated in the study of nonlinear dynamics. The model presents non-conservative oscillations with non-linear damping. In the past, it has been of relevance in several practical problems of engineering such as circuits containing vacuum tubes. For more information on the model see the wikipedia article Van der Pol oscillator.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"In this notebook we compute the evolution of the limit cycle in the phase plane for a set of initial conditions. For such set, we consider a safety condition originally from [ARCHCOMP19LIN], that aims at verifying that there is no solution starting from the initial set that exceeds a prescribed upper bound on the velocity y(t) = x(t) at all times in the given time span. Moreover, we also illustrate the computation of an invariant set using the obtained flowipe. Finally, we study the limit cycle à la Poincaré, by defining a function that computes the cross section of the flowpipe at each revolution. Interestingly, this method gives an algorithmic proof that the safety condition obtained previously is actually verified at all times, i.e. over the unbounded time horizon 0 infty).","category":"page"},{"location":"models/VanDerPol/#Dynamics","page":"Van der Pol oscillator","title":"Dynamics","text":"","category":"section"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"The dynamics of the Van der Pol oscillator are described by the following ODE with two variables:","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"beginaligned\n  dotx = y \n  doty = mu (1 - x^2) y - x\nendaligned","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"The system has a stable limit cycle. Such limit cycle becomes increasingly sharp for higher values of μ. Here we consider the parameter μ = 1.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"using ReachabilityAnalysis, Plots\n\n@taylorize function vanderpol!(dx, x, params, t)\n    local μ = 1.0\n    dx[1] = x[2]\n    dx[2] = (μ * x[2]) * (1 - x[1]^2) - x[1]\n    return dx\nend","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"tip: Performance tip\nAdvanced users may want to consider the section Some common gotchas to improve the code that is generated by @taylorize by re-writing the right-hand side of dx[2] with the use of auxiliary variables.","category":"page"},{"location":"models/VanDerPol/#Safety-verification","page":"Van der Pol oscillator","title":"Safety verification","text":"","category":"section"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"We set the initial condition x(0)  125 155, y(0)  235245. The unsafe set is given by y  275 for a time span 0 7. In other words, we would like to prove that there doesn't exist a solution of the model with a y value which is greater than 2.75, for any initial condition on the given domain. The time horizon of T = 7 is chosen such that the oscillator can do at least one full cycle.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"We proceed by defining the initial conditions as a hyperrectangular set according to the problem's specifications. Then we build the initial-value problem and pass it to the solve function. We specify using TMJets algorithm with default options.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"X0 = Hyperrectangle(low=[1.25, 2.35], high=[1.55, 2.45])\nprob = @ivp(x' = vanderpol!(x), dim=2, x(0) ∈ X0)\nsol = solve(prob, T=7.0, alg=TMJets(abstol=1e-12));\nnothing #hide","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"For further computations, it is convenient to work with a zonotopic overapproximation of the flowpipe.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"solz = overapproximate(sol, Zonotope);\nnothing #hide","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"The maximum value of variable y is obtained by computing the support function of the flowpipe along direction 0 1:","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"ρ([0.0, 1.0], solz)","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"That shows that the property is satisfied. Below we plot the flowpipe in the x-y plane, together with the horizontal line y = 275.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"plot(solz, vars=(1, 2), lw=0.2, xlims=(-2.5, 2.5), xlab=\"x\", ylab=\"y\")\nplot!(x -> 2.75, color=:red, lab=\"y = 2.75\", style=:dash, legend=:bottomright)","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"We can also plot the state variables x(t) and y(t) as a function of time (recall that 0 in vars is used to denote the time variable):","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"plot(solz, vars=(0, 1), lw=0.2, xlab=\"t\", ylab=\"x\")","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"plot(solz, vars=(0, 2), lw=0.2,  xlab=\"t\", ylab=\"y\")","category":"page"},{"location":"models/VanDerPol/#Invariant-Set","page":"Van der Pol oscillator","title":"Invariant Set","text":"","category":"section"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"We can use the reachability result to examine an invariant of the system. In other words, we can algorithmically prove that the flowpipe re-enters from where it started after giving one loop, using inclusion checks.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"plot(solz, vars=(1, 2), lw=0.2, xlims=(0.0, 2.5), ylims=(1.6, 2.8), xlab=\"x\", ylab=\"y\")\nplot!(X0, color=:orange, lab=\"X0\")\nplot!(solz[1:13], vars=(1, 2), color=:green, lw=1.0, alpha=0.5, lab=\"F[1:13]\")\nplot!(solz[388], vars=(1, 2), color=:red, lw=1.0, alpha=0.6, lab=\"F[388]\")","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"It is seen that the reach-set corresponding to the time-span","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"tspan(solz[388])","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"is included in the set union F1 cup cdots cup F13 of previously computed reach-sets. Notice that all future trajectories starting from the 388-th reach-set are already covered by the flowpipe. Therefore, we can claim that an invariant set was found.","category":"page"},{"location":"models/VanDerPol/#Limit-cycle","page":"Van der Pol oscillator","title":"Limit cycle","text":"","category":"section"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"To examine the limit cycle we can intersect a line segment perpendicular to the flowpipe, that will allow us to get a cross-section of the sets in order to prove that after one cycle the intersection segment actually shrinks. This approach is similar to the method of Poincaré sections.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"line = LineSegment([1, 2.], [2., 2.5])\nplot(solz, vars=(1, 2), lw=0.2, xlims=(0.0, 2.5), ylims=(1.6, 2.8), xlab=\"x\", ylab=\"y\")\nplot!(X0, color=:orange, lab=\"X0\")\nplot!(solz[1:13], vars=(1, 2), color=:green, lw=1.0, alpha=0.5, lab=\"F[1:13]\")\nplot!(solz[388], vars=(1, 2), color=:red, lw=1.0, alpha=0.6, lab=\"F[388]\")\nplot!(line, lw=2.0)","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"Then we can define a function to get the cross section of the flowpipe. The function needs the flowpipe, a line segment that cuts the flowpipe and the indices of the subsets to cut.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"function cross_section(line::LineSegment, fp, idx)\n    p = VPolygon()\n    for i in idx\n        x = intersection(line, set(fp[i]))\n        if !isempty(x)\n            p = convex_hull(p, x)\n        end\n    end\n    vl = vertices_list(p)\n    @assert length(vl) == 2\n    return LineSegment(vl[1], vl[2])\nend","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"Then we can get the cross section of the first five sets and the last set, calling them i1 and i2 respectively.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"ifirst = cross_section(line, solz, 1:13)\nilast = cross_section(line, solz, [388])","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"We can also calculate the length of each cross section, remember that the system is 2D, so the cross section will be a line segment.","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"lfirst = norm(ifirst.q - ifirst.p)","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"llast = norm(ilast.q - ilast.p);\nnothing #hide","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"plot(ifirst, lw=3.0, alpha=1.0, label=\"First subsets\", legend=:bottomright)\nplot!(ilast, lw=5.0, alpha=1.0, label=\"Last subset\")","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"The inclusion check succeeds:","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"ilast ⊆ ifirst","category":"page"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"We can see, the cross section of the last subset is a subset of the first few sets, thus, the cycle will continue, presumably getting smaller each revolution.","category":"page"},{"location":"models/VanDerPol/#References","page":"Van der Pol oscillator","title":"References","text":"","category":"section"},{"location":"models/VanDerPol/","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"[ARCHCOMP19LIN]: Althoff, M., Bak, S., Forets, M., Frehse, G., Kochdumper, N., Ray, R., ... & Schupp, S. (2019, May). ARCH-COMP19 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics. In ARCH@ CPSIoTWeek (pp. 14-40).","category":"page"},{"location":"man/backwards/","page":"Backwards reachability","title":"Backwards reachability","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"man/backwards/#Backwards-reachability","page":"Backwards reachability","title":"Backwards reachability","text":"","category":"section"},{"location":"man/backwards/","page":"Backwards reachability","title":"Backwards reachability","text":"using ReachabilityAnalysis, Plots\n\n@taylorize function rotating!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -u[1]\nend\n\n# A = [0. 1.0; -1 0]\n# prob = @ivp(x' = Ax, x(0) ∈ BallInf(ones(2), 0.5))\nprob = @ivp(x' = rotating!(x), dim: 2, x(0) ∈ BallInf(ones(2), 0.5))\n\nsol_forward = solve(prob, tspan=(0.0, 5.0));\nsol_backward = solve(prob, tspan=(5.0, 0.0));\n\nsolz_forward = overapproximate(sol_forward, Zonotope)\nsolz_backward = overapproximate(sol_backward, Zonotope);","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/TransmissionLine/TransmissionLine.jl\"","category":"page"},{"location":"models/TransmissionLine/#Transmission-line-circuit","page":"Transmision line","title":"Transmission line circuit","text":"","category":"section"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"(Image: )","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"note: Overview\nSystem type: linear continuous system\nState dimension: parametric, typically between 4 to 40\nApplication domain: Power Systems Stability","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"We consider the transmission line model used in [AKS11]. The RLC circuit of the transmission line is shown below. In the circuit, U_in is the voltage at the sending end, and U_out is the voltage at the receiving end.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"(Image: )","category":"page"},{"location":"models/TransmissionLine/#Model-description","page":"Transmision line","title":"Model description","text":"","category":"section"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"For reference to understand this model we refer to any standard textbook on electrical circuits. The electrical elements law for resistors (R), inductors (L) and capacitors (C) are studied, for instance, in Chapter 3 of [K15].","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"Let's assume that the network consists of η  2 nodes. There are η dynamic equations for the capacitor voltages and eta dynamic equations for the circuit currents. Therefore, the state vector can be represented as","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"x = U_1 U_2  U_η I_1 I_2  I_η^T","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"and the state dimension is 2η.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"Analysis of the first node. When writing the equations for the voltages and currents, we should pay attention to the sign choices in given circuit, which do not exactly match the convention in text-books (in the sense that U_1s positive terminal is at the bottom, as indicated by the arrows). Let R_d denote the driver resistance's current. By Kirchhoff's voltage law,","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"U_in = R_d I_1 + LI_1 - U_1","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"therefore","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"boxedI_1 = dfracU_in + U_1L - dfracR_dLI_1","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"By Kirchhoff's current law, and if I_1 C denotes the current through the capacitor C, connected to the first node,","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"   I_1 = I_2 + I_C 1","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"and","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"I_C 1 = -CU_1","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"then","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"   boxedU_1 = fracI_2 - I_1C","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"Analysis of the intermediate nodes. Other node's equations are obtained in a similar fashion. For instance, for the second loop one has","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"-U_1 = RI_2 + LI_2 - U_2 Rightarrow I_2 = dfracU_2-U_1L - fracRLI_2","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"for the current's equation, and","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"   I_2 C = I_2 - I_3Rightarrow U_2 = fracI_3 - I_2C","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"for the voltage's equation.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"Generalizing for arbitrary l = 2 ldots eta - 1 is trivial and gives:","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"    boxedI_l = dfracU_l - U_l-1L - fracRLI_l \n    boxedU_l = dfracI_l+1 - I_lC","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"Analysis of the last node. The last node corresponds to the case l = eta","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"boxedI_eta = dfracU_eta - U_eta-1L - fracRLI_eta \nboxedU_out = U_out = - fracI_etaC","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"System of linear ODEs. Recall that that the stateset is mathbbR^2eta, where the state variables are x = U_1 U_2 ldots U_eta I_1 I_2 ldots I_eta^T. The system can be written as a block-diagonal system of linear ODEs,","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"x(t) = Ax(t) + BU_in(t)","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"using the results in the previous section.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"The coefficients matrix A can be written as a block-diagonal matrix. There exist useful constructors in the base package LinearAlgebra that greatly simplify building matrices with special shape, as in our case, such as diagonal and band matrices, using the types Diagonal and Bidiagonal in our case.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"using ReachabilityAnalysis, LinearAlgebra, SparseArrays\n\nfunction tline(;η=3, R=1.00, Rd=10.0, L=1e-10, C=1e-13 * 4.00)\n    A₁₁ = zeros(η, η)\n    A₁₂ = Bidiagonal(fill(-1/C, η), fill(1/C, η-1), :U)\n    A₂₁ = Bidiagonal(fill(1/L, η), fill(-1/L, η-1), :L)\n    A₂₂ = Diagonal(vcat(-Rd/L, fill(-R/L, η-1)))\n    A  = [A₁₁ A₁₂; A₂₁ A₂₂]\n    B = sparse([η+1], [1], 1/L, 2η, 1)\n    return A, B\nend","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"We can visualize the structure of the cofficients matrix A for the case eta = 20 with spy plot:","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"using Plots\n\nA, _ = tline(η=20)\nspy(A, legend=nothing, markersize=2.0, title=\"Sparsity pattern of A\", xlab=\"columns\", ylab=\"rows\")","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"Notice that the matrix coefficients are rather big, hence it is convenient to rescale the system for numerical stability. Let α  0 be a scaling factor, and let tildex(t) = x(alpha t). By the chain rule,","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"tildex(t) = alpha x(alpha t) = alpha A x(alpha t) + alpha B U_in(alpha t) = tildeA tildex(t) + tildeB tildeU_in(t)","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"where tildeA = alpha A and tildeB = alpha B.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"function scale!(s, α=1.0)\n    s.A .*= α\n    s.B .*= α\n    return s\nend","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"Note that under this transformation, the time horizon has to be transformed as well, through tildeT = alpha T.","category":"page"},{"location":"models/TransmissionLine/#Reachability-settings","page":"Transmision line","title":"Reachability settings","text":"","category":"section"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"The transmission line parameters used in this model are displayed in the following table.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"resistance in [Ω] driver resistance in [Ω] Inductance in [H] Capacitance in [F]\nR = 1.00 Rdriver = 10.0 L = 1e−10 C = 4e−13","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"The steady state is obtained by zeroing the left-hand side of the ODE, which gives","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"   0 = x = Ax_infty + Bu_0 Rightarrow x_infty = -A^-1B u_0","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"The initial set under consideration corresponds to the steady state for input voltages U_in ss = -02 02. Moreover, an uncertainty is added so that the initial currents are also uncertain. The set of initial states is then","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"   x(0) in mathcalX_0 = -A^-1 B  U_in ss oplus (0001)","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"where (ϵ) is the infinity-norm ball of center zero and radius ϵ.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"The time horizon is chosen as T = 07 seconds. We consider a scaling factor alpha = 1e-9.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"We are interested in the step response to an input voltage U_in(t), constant for t in 0 T over the domain U_in = 099 101.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"We consider the case of eta = 20 nodes as in [AKS11], such that the system has n = 40 state variables.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"η = 20 # order\nn = 2η # state-space dimension\nA, B = tline(η=η);\n\nUin_ss = Interval(-0.2, 0.2)\n□(ϵ) = BallInf(zeros(n), ϵ)\nX0 = -inv(Matrix(A)) * B * Uin_ss ⊕ □(0.001);\n\nUin = Interval(0.99, 1.01)\ns = @system(x'= A*x + B*u, x ∈ Universe(n), u ∈ Uin)\nα = 1e-9 # scaling factor\nscale!(s, α);\n\nT = 0.7 * 1e-11 # time horizon\nP = InitialValueProblem(s, X0);\nnothing #hide","category":"page"},{"location":"models/TransmissionLine/#Results","page":"Transmision line","title":"Results","text":"","category":"section"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"We solve system using a step size of δ=1e-3 and the box algorithm.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"sol = solve(P, T=0.7, alg=BOX(δ=1e-3));\nnothing #hide","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"To get the variable U_out we have to project onto the η-th coordinate and invert the sign of the flowpipe.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"Uout_vs_t = @. (-1.0) * project(sol, η);\nnothing #hide","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"plot(Uout_vs_t, vars=(0, η), color=:blue, xlab=\"t\", ylab=\"Uout\", alpha=.5, lw=0.5)","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"tip: Technical note\nSince we are only interested in the behavior of U_out, we can use algorithm BFFPSV18 with the options alg=BFFPSV18(δ=1e-3, dim=statedim(P), vars=[η])), which will use an interval (1D) decomposition of the state space and only compute the flowpipe associated with variable eta.","category":"page"},{"location":"models/TransmissionLine/#References","page":"Transmision line","title":"References","text":"","category":"section"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"[AKS11]: Althoff, Matthias, Bruce H. Krogh, and Olaf Stursberg. Analyzing reachability of linear dynamic systems with parametric uncertainties.. Modeling, Design, and Simulation of Systems with Uncertainties. Springer, Berlin, Heidelberg, 2011. 69-94.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"[K15]: Kluever, Craig A. Dynamic systems: modeling, simulation, and control.. John Wiley & Sons, 2015.","category":"page"},{"location":"models/TransmissionLine/","page":"Transmision line","title":"Transmision line","text":"[GLG08]: Girard, Antoine, and Colas Le Guernic. Efficient reachability analysis for linear systems using support functions. IFAC Proceedings Volumes 41.2 (2008): 8966-8971.","category":"page"},{"location":"man/introduction/#Introduction","page":"-","title":"Introduction","text":"","category":"section"},{"location":"man/introduction/","page":"-","title":"-","text":"In simple terms, reachability analysis is concerned with studying the sets of states that a system can reach, starting from a set of initial states and under the influence of a set of input trajectories and parameter values.","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"Our first example is the one-dimensional scalar differential equation","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"x(t) = -x(t)qquad 0  t  T = 40","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"with initial condition x(0)  045 055. We can solve the problem as follows:","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"using ReachabilityAnalysis, Plots\n\n# define the initial-value problem\nprob = @ivp(x' = -x, x(0) ∈ 0.45 .. 0.55)\n\n# solve it\nsol = solve(prob, T=4.0)\n\n# plot the solution, where the index 0 corresponds to the \"time\" variable\nplot(sol, vars=(0, 1), label=\"Flowpipe\", xlab=\"t\", ylab=\"x(t)\", linewidth=0.3)\n\n# also plot the analytic solution\nf(t, x0) = x0 * exp(-t)\nplot!(t -> f(t, 0.45), xlims=(0, 4), label=\"Analytic sol., x(0) = 0.45\", color=\"red\")\nplot!(t -> f(t, 0.55), xlims=(0, 4), label=\"Analytic sol., x(0) = 0.55\", color=\"red\")","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"In practice, analytic solutons of ODEs are unknown. However, in this simple case we knew that for an initial point x_0 in mathbbR, the solution is x(t) = x_0 e^-t so we plotted the trajectories associated to the extremal values in the given initial interval.","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"We have seen how to compute the set of all reachable stataes within the time-span 0  t  T = 40. The reachability approach guarantees that the trajectories are always included in the resulting flowpipe. In the following section we introduce the terminology used in reachability analysis and formulate the reachability problem for a general class of mathematical systems. Further examples on how to use the library for other types of systems can be found in later sections of the manual, or you can directly jump to the [Overview] part.","category":"page"},{"location":"man/introduction/#Terminology","page":"-","title":"Terminology","text":"","category":"section"},{"location":"man/introduction/","page":"-","title":"-","text":"The reachable set at a given time point delta in mathbbR, also known as the reach-set for the ODE","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"x(t) = f(x(t) u(t) p(t) t)","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"is defined by","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"mathcalR(δ) = left x(δ) = int_0^δ f(x(t) u(t) p(t) t) dt x(0)  X_0 u(t)  mathcalU p(t)  mathcalP right","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"Here X_0 denotes the set of initial states, mathcalU denotes the input set, and mathcalP denotes the parameter values. For practical problems, the set mathcalR(δ) cannot be obtained exactly, and reachability methods aim at computing suitable over-approximations (or under-approximations) of it.","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"We define the reachable set associated to a time interval 0 δ, also known as the flowpipe, as","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"mathcalF(0 δ) = _t in 0 δ mathcalR(t)","category":"page"},{"location":"man/introduction/","page":"-","title":"-","text":"Reachability methods are used to compute rigorous approximations of the flowpipe for continuous or hybrid systems, in bounded time or unbounded time horizon. Here we use the term rigorous in the formal, or mathematical sense, that no solution \"escapes\" the flowpipe, for any trajectory that satisfies the constraints (initial states, inputs, and noise).","category":"page"},{"location":"man/introduction/#Safety-verification","page":"-","title":"Safety verification","text":"","category":"section"},{"location":"man/introduction/","page":"-","title":"-","text":"On the other hand, the amount of computation required depends heavily on the particular problem statement. One notable example is safety verification, which simply stated requires to prove that the flowpipe does not intersect a region of \"bad states\". In this setting, one can often reason about the flowpipe lazily, i.e. without actually computing it in full.","category":"page"},{"location":"man/introduction/#Hybrid-systems","page":"-","title":"Hybrid systems","text":"","category":"section"},{"location":"man/introduction/","page":"-","title":"-","text":"Up to now we have discussed about the continuous case only, but there is a rich literature in hybrid systems reachability; hybrid here means those dynamical systems which are given by one or more continuous-time dynamics (often, systems of ODEs in each mode or location) coupled with discrete transitions between continuous modes. In our context it is standard to model these systems using the terminology of hybrid automata, and we also model hybrid systems with such framework in this library. The concept of reach-set, flowpipe and safety verification are naturally extended to hybrid automata, although there is the additional complication that the flowpipe must include the behaviors for all possible transitions between discrete modes that are compatible with the dynamics.","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"ORBIT","category":"page"},{"location":"lib/algorithms/ORBIT/#ReachabilityAnalysis.ORBIT","page":"ORBIT","title":"ReachabilityAnalysis.ORBIT","text":"ORBIT{N, VT, AM} <: AbstractContinuousPost\n\nImplementation of discrete-time integration for deterministic linear ODEs for singleton initial conditions and singleton input sets.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: NoBloating) approximation model\n\nThe type fields are:\n\nN   – number type of the step-size\nAM  – type of the approximation model\n\nNotes\n\nReachability solutions computed with the ORBIT algorithm have its own plot recipe, producing a scatter plot. Use the markershape option to change the shape of the markers used for the scatter plot. To \"connect\" the points, use the option seriestype=:path. For additional options see the Plots.jl documentation.\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/ORBIT/#Method","page":"ORBIT","title":"Method","text":"","category":"section"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"Consider the ODE","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"x(t) = Ax(t) + u qquad x_0 in mathbbR^nqquad (1)","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"with A in mathbbR^ntimes n and u in mathbbR^n. The analytic solution at delta  0 is known to be","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"x(delta) = e^Adeltax_0 + int_0^delta e^A(delta - s) uds","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"Let us introduce the matrices Phi(A delta) = e^Adelta and Phi_1(A delta) = int_0^delta e^A(delta - s) ds. The computation of these matrices will be discussed later.","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"Since u is assumed constant,","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"x(delta) = Phi x_0 + v","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"where we have defined v = Phi_1(A delta) u. To get the exact solution at t = 2delta, note that by time invariance of Eq. (1),","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"x(2delta) = e^Adelta x(delta) + int_0^delta e^A(delta - s)u ds","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"hence","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"x(2delta) = Phi (Phi x_0 + v) + v = Phi^2 x_0 + Phi v + v","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"The solution at subsequent multiples of the step-size delta is achieved by applying the preceding rule iteratlvely. For any k geq 1, we obtain","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"x(kdelta) = Phi^k x_0 + sum_i=0^k-1 Phi^i vqquad k geq 1","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"Before considering the computation of Phi and Phi_1, note that the method admits a straightforward generalization for non-constant inputs. Indeed, if u  0 Tto mathbbR^n is a piecewise-constant function, there always exists a sufficiently small step-size delta such that the following premise holds. Assume that u_1 u_2 ldots u_N subseteq mathbbR^n is the range of values of the input, where u(t) = u_k for t in (k-1)delta kdelta), k = 1 ldots N, and let v_k = Phi_1(u_k delta) for all k = 1ldots N. Then it holds that x(delta) = Phi x_0 + v_1, x(2delta) = Phi^2 x_0 + Phi v_1+ v_2, and","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"x(kdelta) = Phi^k x_0 + sum_i=0^k-1 Phi^i v_k-iqquad k = 1ldots N","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"The matrix Phi = e^Adelta can be evaluated in different ways, using the function _exp:","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"(1) method=:base uses Julia's built-in implementation (if method = :base),","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"(2) method = :lazy uses a lazy wrapper of the matrix exponential which is then evaluted using Krylov subspace methods.","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"Method (1) is the default method. Method (2) is particularly useful to work with very large and sparse matrices (e.g. typically of order n > 2000). Evaluation of Phi_1(u delta) is available through the function Φ₁. Two implementations are available:","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"(1) If the coefficients matrix A is invertible, then the integral is equivalent to computing A^-1(e^Adelta - I).","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"(2) In general, Phi_1(u delta) can be obtained as a sub-block of a larger matrix. See [FRE11] for details.","category":"page"},{"location":"lib/algorithms/ORBIT/","page":"ORBIT","title":"ORBIT","text":"Method (2) is the default method, although there are cases in which method (1) is more convenient. For example, if we are only interested in singleton inputs and A is invertible, it is possible to compute Phi_1(A delta) u  efficiently without actually inverting the matrix A in full.","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/ISS/ISS.jl\"","category":"page"},{"location":"models/ISS/#Structural-Model","page":"Structural Model","title":"Structural Model","text":"","category":"section"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"(Image: )","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"note: Overview\nSystem type: linear time-invariant continuous system\nState dimension: 270\nApplication domain: Aerospace Engineering","category":"page"},{"location":"models/ISS/#Model-description","page":"Structural Model","title":"Model description","text":"","category":"section"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"This is a model of component 1r (Russian service module) of the International Space Station [ASG00]. It has 270 states, 3 inputs and 3 outputs  The model consists of a continuous linear time-invariant system","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"  beginarraylcl\n  dotx(t) = Ax(t) + Bu(t) \n  y(t)  =  C x(t)\n  endarray","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"It was proposed as a benchmark in ARCH 2016 [TLT16]. The matrix dimensiones are A  mathbbR^270times 270, B  mathbbR^270times 3 and C  mathbbR^3times 270.","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"The matrices A, B, and C are available in MATLAB format (Image: ) (iss.mat). For convenience such .mat file has been converted to the JLD2 format and stored in the file iss.jld2.","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"using ReachabilityAnalysis, JLD2\nusing ReachabilityAnalysis: add_dimension\n\nLazySets.set_ztol(Float64, 1e-15);\n\nexamples_dir = normpath(@__DIR__, \"..\", \"..\", \"..\", \"examples\")\nISS_path = joinpath(examples_dir, \"ISS\", \"ISS.jld2\")\n\n@load ISS_path C;\nconst C3 = C[3, :]; # variable y₃\nconst C3_ext = vcat(C3, fill(0.0, 3));\nnothing #hide","category":"page"},{"location":"models/ISS/#Reachability-settings","page":"Structural Model","title":"Reachability settings","text":"","category":"section"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"Initially all the variables are in the range -00001 00001, and the inputs are bounded: u_1(t)  0 01, u_2(t)  08 1, and u_3 is in 09 1. The time bound is 20.","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"There are two versions of this benchmark, ISSF01 (time-varying inputs) and ISSC01 (constant inputs).","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"ISSF01 (time-varying inputs): In this setting, the inputs can change arbitrarily over time: forall t u(t) in mathcalU.\nISSC01 (constant inputs): The inputs are uncertain only in their initial value, and constant over time: u(0)in mathcalU, dot u(t)= 0.","category":"page"},{"location":"models/ISS/#Specifications","page":"Structural Model","title":"Specifications","text":"","category":"section"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"The verification goal is to check the ranges reachable by the output y_3(t), which is a linear combination of the state variables. In addition to the safety specification, for each version there is an UNSAT instance that serves as sanity checks to ensure that the model and the tool work as intended. But there is a caveat: In principle, verifying an UNSAT instance only makes sense formally if a witness is provided (counter-example, under-approximation, etc.).","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"Since this library currently doesn't have the capability of verifying UNSAT instances, we run the tool with the same accuracy settings on an SAT-UNSAT pair of instances. The SAT instance demonstrates that the over-approximation is not too coarse, and the UNSAT instance demonstrates that the over-approximation is indeed conservative, at least in the narrow sense of the specification.","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"ISS01: Bounded time, safe property: For all t  0 20, y_3(t)  00007 00007.        This property is used with the uncertain input case (ISSF01) and assumed to be satisfied.\nISS02: Bounded time, safe property: For all t  0 20, y_3(t)  00005 00005.        This property is used with the constant input case (ISSC01) and assumed to be satisfied.\nISU01: Bounded time, unsafe property: For all t  0 20, y_3 (t)  00005 00005.        This property is used with the uncertain input case (ISSF01) and assumed to be unsatisfied.\nISU02: Bounded time, unsafe property: For all t  0 20, y_3 (t)  000017 000017.        This property is used with the constant input case (ISSC01) and assumed to be unsatisfied.","category":"page"},{"location":"models/ISS/#Results","page":"Structural Model","title":"Results","text":"","category":"section"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"The specification involves only the output y(t) = C_3 x(t), where C_3 denotes the third row of the output matrix C  mathbbR^3times 270. Hence, it is sufficient to compute the flowpipe associated to y(t) directly, without the need of actually computing the full 270-dimensional flowpipe associated to all state variables. The flowpipe associated to a linear combination of state variables can be computed efficiently using the support-function based algorithm [LGG09]. The idea is to define a template polyhedron with only two supporting directions, namely C_3 and -C_3.","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"The step sizes chosen are 610^-4 for ISSF01 and 110^-2 for ISSC01.","category":"page"},{"location":"models/ISS/#ISSF01","page":"Structural Model","title":"ISSF01","text":"","category":"section"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"In this scenario the inputs can change arbitrarily over time and are only bound to the given input range U.","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"function ISSF01()\n    @load ISS_path A B\n\n    U = Hyperrectangle(low=[0.0, 0.8, 0.9], high=[0.1, 1., 1.])\n    X0 = BallInf(zeros(size(A, 1)), 0.0001)\n    return @ivp(x' = A*x + B*u, x(0) ∈ X0, u ∈ U, x ∈ Universe(270))\nend","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"dirs = CustomDirections([C3, -C3]);\nprob_ISSF01 = ISSF01();\nsol_ISSF01 = solve(prob_ISSF01, T=20.0, alg=LGG09(δ=6e-4, template=dirs, sparse=true, cache=false));\nnothing #hide","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"The solution sol_ISSF01 is now a 270-dimensional set that (only) contains template reach-sets for the linear combination C_3 x(t),","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"dim(sol_ISSF01)","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"For visualization, it is necessary to specify that we want to plot \"time\" vs. y_3(t). We can transform the flowpipe on the output y_3(t) by \"flattening\" the flowpipe along directions dirs.","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"πsol_ISSF01 = flatten(sol_ISSF01);\nnothing #hide","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"Now πsol_ISSF01 is a one-dimensional flowpipe,","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"dim(πsol_ISSF01)","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"tip: Performance tip\nNote that projecting the solution along direction C_3 corresponds to computing  the min and max bounds for each reach-set X, that is, Interval(-ρ(-C3, X), ρ(C3, X)).  However, the method flatten(sol_ISSF01, rows=(1, 2)) is more efficient since it uses  the matrix of support function evaluations obtained by LGG09 along directions  C_3 and -C_3.","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"using Plots, Plots.PlotMeasures, LaTeXStrings\n\nfig = Plots.plot();\nPlots.plot!(fig, πsol_ISSF01[1:10:end], vars=(0, 1), linecolor=:blue, color=:blue, alpha=0.8,\n     xlab=L\"t\",\n     ylab=L\"y_{3}\",\n     xtick=[0, 5, 10, 15, 20.], ytick=[-0.00075, -0.0005, -0.00025, 0, 0.00025, 0.0005, 0.00075],\n     xlims=(0., 20.), ylims=(-0.00075, 0.00075),\n     bottom_margin=6mm, left_margin=2mm, right_margin=4mm, top_margin=3mm);\nfig","category":"page"},{"location":"models/ISS/#ISSC01","page":"Structural Model","title":"ISSC01","text":"","category":"section"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"In this scenario the inputs are uncertain only in their initial value and constant over time.","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"function ISSC01()\n    @load ISS_path A B\n\n    A_ext = add_dimension(A, 3)\n    A_ext[1:270, 271:273] = B\n\n    U = Hyperrectangle(low=[0.0, 0.8, 0.9], high=[0.1, 1., 1.])\n    X0 = BallInf(zeros(size(A, 1)), 0.0001)\n    X0 = X0 * U\n    return @ivp(x' = A_ext*x, x(0) ∈ X0)\nend","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"dirs = CustomDirections([C3_ext, -C3_ext]);\nprob_ISSC01 = ISSC01();\nsol_ISSC01 = solve(prob_ISSC01, T=20.0, alg=LGG09(δ=0.01, template=dirs, sparse=true, cache=false));\nnothing #hide","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"We can flatten the flowpipe to the output y_3(t) as before:","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"πsol_ISSC01 = flatten(sol_ISSC01);\n\nfig = Plots.plot();\nPlots.plot!(fig, πsol_ISSC01, vars=(0, 1), linecolor=:blue, color=:blue, alpha=0.8, lw=1.0,\n    xlab=L\"t\",\n    ylab=L\"y_{3}\",\n    xtick=[0, 5, 10, 15, 20.], ytick=[-0.0002, -0.0001, 0.0, 0.0001, 0.0002],\n    xlims=(0., 20.), ylims=(-0.0002, 0.0002),\n    bottom_margin=6mm, left_margin=2mm, right_margin=4mm, top_margin=3mm)\nfig","category":"page"},{"location":"models/ISS/#References","page":"Structural Model","title":"References","text":"","category":"section"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"[ASG00]: Antoulas, Athanasios C., Danny C. Sorensen, and Serkan Gugercin. A survey of model reduction methods for large-scale systems. 2000.","category":"page"},{"location":"models/ISS/","page":"Structural Model","title":"Structural Model","text":"[TLT16]: Tran, Hoang-Dung, Luan Viet Nguyen, and Taylor T. Johnson. Large-scale linear systems from order-reduction (benchmark proposal). 3rd Applied Verification for Continuous and Hybrid Systems Workshop (ARCH), Vienna, Austria. 2016.","category":"page"},{"location":"lib/algorithms/INT/","page":"INT","title":"INT","text":"INT","category":"page"},{"location":"lib/algorithms/INT/#ReachabilityAnalysis.INT","page":"INT","title":"ReachabilityAnalysis.INT","text":"INT{N, AM} <: AbstractContinuousPost\n\nImplementation of a reachability method for linear one-dimensional systems interval arithmetic.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\n\nThe default approximation model used in this algorithm is:\n\nForward(sih=:concrete, exp=:base, setops=:Interval)\n\nIn particular, the setops=:Interval flag specifies that intermediate computations in the discretization are done using interval arithmetic. This allows for some optimizations.\n\nReferences\n\nThis algorithm is essentially a non-decomposed version of the method in [BFFPSV18], using intervals as set representation. For a general introduction we refer to the dissertation [LG09].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in [FRE11].\n\nInterval arithmetic operations are performed using the IntervalArithmetic.jl package. Hence, the results are guaranteed to comply to the IEE754 standard with respect to the floating-point operations using intervals.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using ReachabilityAnalysis)","category":"page"},{"location":"#ReachabilityAnalysis.jl","page":"Home","title":"ReachabilityAnalysis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Methods to compute sets of states reachable by dynamical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nReachabilityAnalysis is still under development. If you have questions, find a bug, or have ideas for improvements, feel free to open an issue or make a pull request on the project's GitHub page. You can also find us at the JuliaReach gitter channel.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This library implements reachability analysis methods for systems of ordinary differential equations (ODEs), for both continuous and hybrid dynamical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following types of ODEs are currently supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Continuous ODEs with linear dynamics.\nContinuous ODEs with non-linear dynamics.\nHybrid systems with piecewise-affine dynamics.\nHybrid systems with non-linear dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For hybrid systems, the transitions may be space-triggered or time-triggered (or both).","category":"page"},{"location":"","page":"Home","title":"Home","text":"In all the problems mentioned above, the library can handle uncertainties in the sets of initial states, inputs, or parameter variation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We refer to the Algorithms section for detailed descriptions of the algorithms available, as well as the references to the technical literature.","category":"page"},{"location":"#What-can-ReachabilityAnalysis-do?","page":"Home","title":"What can ReachabilityAnalysis do?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Solve the same ODE repeatedly for an infinite number of different initial conditions.","category":"page"},{"location":"#How-to-install-the-package?","page":"Home","title":"How to install the package?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can easily install ReachabilityAnalysis.jl from your Julia console (press ] in the Julia REPL to enter the pkg> mode):","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add ReachabilityAnalysis","category":"page"},{"location":"#Application-domains","page":"Home","title":"Application domains","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Reachability analysis has applications in diverse domains such as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Safety verification: Determining whether a system is safe, i.e. to verify if it does not enter into a region of unsafe sets. Typical applications are assessing the critical distance between autonomous vehicles or robots, or critical concentration of chemicals in a reactor.\nValidation of control strategies: Checking if the system trajectories stay in a region around a reference trajectory, or reach a goal region around a setpoint, for any admissible value of the non-deterministic inputs, initial conditions or noise.\nController synthesis: Finding parameter sets of controllers that satisfy safety or performance constraints.\nDeep neural network verification: Providing formal guarantees for the network behavior subject to perturbations in the inputs, e.g. detecting that small changes in an input image do not cause the network o misclassify it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We refer to the technical literature for further applications.","category":"page"},{"location":"#What-is-the-verification-problem?","page":"Home","title":"What is the verification problem?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider a dynamical system over some state space mathcalX subset mathbbR^n defined via a differential equation of the form x(t) = f(x u), where u(t) in mathcalU(t) ranges over some specified set of admissible input signals. Given a set of initial states initial states mathcalX_0 subseteq mathcalX, a set of unsafe states, and a time bound, the time-bounded safety verification problem is to check if there exists an initial state and a time within the bound such that the solution of the system enters the unsafe set.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The safety verification problem applies for the generalized case in which the problem has uncertain parameters, or dynamical systems which are hybrid, i.e. mixing continuous dynamics and discrete transitions.","category":"page"},{"location":"#A-warning-note","page":"Home","title":"A warning note","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Users of the library should have in mind that parameter tuning is an essential ingredient to the successful application of reachability analysis. This is in part due to the \"cutting-edge research\" aspect of the methods available, i.e. the methods haven't yet been \"battle-tested\". Moreover, finding good algorithm heuristics – specially for hybrid systems – is a hard problem by itself.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On the other hand, our goal in designing and building the tools around JuliaReach has been to make the default settings already work, or at least, work reasonably well across a broad range of models: linear, hybrid, nonlinear, and so on. In the future, we hope that users won't have to know the details of how the different set-based reachability methods work under-the-hood in order to get new results. Eventually, users should know how to adjust some parameters associated to the algorithms in order to improve the precision, to formulate and solve verification problems, etc. inasmuch as effectively applying standard numerical integration requires some basic knowledge about stepsize control, interpolation, error calculation, etc.","category":"page"},{"location":"#How-to-read-this-manual","page":"Home","title":"How to read this manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please note that the manual contains a Frequently Asked Questions (FAQ) section with a selection of different questions and answers, many of them with working code so that you can also experiment with the answers.","category":"page"},{"location":"lib/discretize/","page":"Discretization","title":"Discretization","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/discretize/#Discretization","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"lib/discretize/","page":"Discretization","title":"Discretization","text":"Pages = [\"discretize.md\"]\nDepth = 3","category":"page"},{"location":"lib/discretize/#Discretize-API","page":"Discretization","title":"Discretize API","text":"","category":"section"},{"location":"lib/discretize/","page":"Discretization","title":"Discretization","text":"normalize\ndiscretize","category":"page"},{"location":"lib/discretize/#LinearAlgebra.normalize","page":"Discretization","title":"LinearAlgebra.normalize","text":"normalize(a::AbstractArray, p::Real=2)\n\nNormalize the array a so that its p-norm equals unity, i.e. norm(a, p) == 1. See also normalize! and norm.\n\nExamples\n\njulia> a = [1,2,4];\n\njulia> b = normalize(a)\n3-element Array{Float64,1}:\n 0.2182178902359924\n 0.4364357804719848\n 0.8728715609439696\n\njulia> norm(b)\n1.0\n\njulia> c = normalize(a, 1)\n3-element Array{Float64,1}:\n 0.14285714285714285\n 0.2857142857142857\n 0.5714285714285714\n\njulia> norm(c, 1)\n1.0\n\njulia> a = [1 2 4 ; 1 2 4]\n2×3 Array{Int64,2}:\n 1  2  4\n 1  2  4\n\njulia> norm(a)\n6.48074069840786\n\njulia> normalize(a)\n2×3 Array{Float64,2}:\n 0.154303  0.308607  0.617213\n 0.154303  0.308607  0.617213\n\n\n\n\n\n\nnormalize(hs::HalfSpace{N}, p=N(2)) where {N}\n\nNormalize a half-space.\n\nInput\n\nhs – half-space\np  – (optional, default: 2) norm\n\nOutput\n\nA new half-space whose normal direction a is normalized, i.e., such that a_p = 1 holds.\n\n\n\n\n\nnormalize(P::AbstractHPolygon{N}, p=N(2)) where {N}\n\nNormalize a polygon in constraint representation.\n\nInput\n\nP – polygon in constraint representation\np – (optional, default: 2) norm\n\nOutput\n\nA new polygon in constraint representation whose normal directions a_i are normalized, i.e., such that a_i_p = 1 holds.\n\n\n\n\n\nnormalize(P::HPoly{N}, p=N(2)) where {N}\n\nNormalize a polyhedron in constraint representation.\n\nInput\n\nP – polyhedron in constraint representation\np – (optional, default: 2) norm\n\nOutput\n\nA new polyhedron in constraint representation whose normal directions a_i are normalized, i.e., such that a_i_p = 1 holds.\n\n\n\n\n\nnormalize(L::Line, p::Real=2.0)\n\nNormalize the direction of a line.\n\nInput\n\nL – line\np – (optional, default: 2.0) vector p-norm used in the normalization\n\nOutput\n\nA line whose direction has unit norm w.r.t the given p-norm.\n\nNotes\n\nSee also normalize!(::Line, ::Real) for the in-place version.\n\n\n\n\n\nnormalize(system::AbstractSystem)\n\nTransform a mathematical system to a normalized (or canonical) form.\n\nInput\n\nsystem – system; it can be discrete or continuous\n\nOutput\n\nEither the same system if it already conforms to a canonical form, or a new system otherwise.\n\nNotes\n\nThe normalization procedure consists of transforming a given system type into a \"canonical\" format that is used internally. More details are given below.\n\nAlgorithm\n\nThe implementation of normalize exploits MathematicalSystems's' types, which carry information about the problem as a type parameter.\n\nHomogeneous ODEs of the form x = Ax x  mathcalX are canonical if the associated problem is a ConstrainedLinearContinuousSystem and A is a matrix. This type does not handle non-deterministic inputs.\n\nNote that a LinearContinuousSystem does not consider constraints on the state-space (such as an invariant); to specify state constraints, use a ConstrainedLinearContinuousSystem. If the passed system is a LinearContinuousSystem (i.e. no constraints) then the normalization fixes a universal set (Universe) as the constraint set.\n\nThe generalization to canonical systems with constraints and possibly time-varying non-deterministic inputs is considered next. These systems are of the form x = Ax + u u  mathcalU x  mathcalX. The system type is ConstrainedLinearControlContinuousSystem, where A is a matrix, X is a set and U is an input, that is, any concrete subtype of AbstractInput.\n\nIf U is not given as an input, normalization accepts either a LazySet, or a vector of LazySets. In these cases, the sets are wrapped around an appropriate concrete input type.\n\nIf the system does not conform to a canonical form, the implementation tries to make the transformation; otherwise an error is thrown. In particular, ODEs of the form x = Ax + Bu are mapped into x = Ax + u u  BmathcalU, where now u has the same dimensions as x.\n\nThe transformations described above are analogous in the discrete case, i.e. x_k+1 = A x_k and x_k+1 = Ax_k + u_k u_k  mathcalU x_k  mathcalX for the linear and affine cases respectively.\n\n\n\n\n\nnormalize(h::Histogram{T,N}; mode::Symbol=:pdf) where {T,N}\n\nNormalize the histogram h.\n\nValid values for mode are:\n\n:pdf: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.\n:density: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1. Will not modify the  histogram if it already represents a density (h.isdensity == 1).\n:probability: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.\n:none: Leaves histogram unchanged. Useful to simplify code that has to  conditionally apply different modes of normalization.\n\nSuccessive application of both :probability and :density normalization (in any order) is equivalent to :pdf normalization.\n\n\n\n\n\nnormalize(h::Histogram{T,N}, aux_weights::Array{T,N}...; mode::Symbol=:pdf) where {T,N}\n\nNormalize the histogram h and rescales one or more auxiliary weight arrays at the same time (aux_weights may, e.g., contain estimated statistical uncertainties). The values of the auxiliary arrays are scaled by the same factor as the corresponding histogram weight values. Returns a tuple of the normalized histogram and scaled auxiliary weights.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#MathematicalSystems.discretize","page":"Discretization","title":"MathematicalSystems.discretize","text":"discretize(system::AbstractContinuousSystem, ΔT::Real,\n           algorithm::AbstractDiscretizationAlgorithm=ExactDiscretization(),\n           constructor=_default_complementary_constructor(system))\n\nDiscretization of a isaffine AbstractContinuousSystem to a AbstractDiscreteSystem with sampling time ΔT using the discretization method algorithm.\n\nInput\n\nsystem      – an affine continuous system\nΔT          – sampling time\nalgorithm   – (optional, default: ExactDiscretization()) discretization algorithm\nconstructor – (optional, default: _default_complementary_constructor(system)) construction method\n\nOutput\n\nReturns a discretization of the input system system with discretization method algorithm and sampling time ΔT.\n\n\n\n\n\ndiscretize(ivp::IVP, δ, alg::AbstractApproximationModel)\n\nSet-based conservative discretization of a continuous-time initial value problem into a discrete-time problem.\n\nInput\n\nivp   – initial value problem for a linear ODE in canonical form (see Notes below)\nδ     – step size\nalg   – algorithm used to compute the approximation model\n\nOutput\n\nThe initial value problem of a discrete system.\n\nNotes\n\nDifferent approximation algorithms and their respective options are described in the docstring of each method, e.g. Forward. Here is a list of all the available approximation models:\n\njulia> subtypes(ReachabilityAnalysis.AbstractApproximationModel)\n5-element Vector{Any}:\n Backward\n CorrectionHull\n Forward\n NoBloating\n StepIntersect\n\nInitial-value problems considered in this function are of the form\n\nx = Ax(t) + u(t)qquad x(0)  mathcalX_0qquad (1)\n\nand where u(t)  U(k) add where U(k)_k is a sequence of sets of non-deterministic inputs and mathcalX_0 is the set of initial states. Other problems, e.g. x = Ax(t) + Bu(t) can be brought to the canonical form with the function normalize.\n\nFor references to the original papers introducing each algorithm, see the docstrings, e.g. ?Forward.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#Approximation-models","page":"Discretization","title":"Approximation models","text":"","category":"section"},{"location":"lib/discretize/","page":"Discretization","title":"Discretization","text":"Forward\nBackward\nCorrectionHull\nNoBloating","category":"page"},{"location":"lib/discretize/#ReachabilityAnalysis.Forward","page":"Discretization","title":"ReachabilityAnalysis.Forward","text":"Forward{EM, SO, SI, IT, BT} <: AbstractApproximationModel\n\nForward approximation model.\n\nFields\n\nexp     – exponentiation method\nsetops  – set operations method\nsih     – symmetric interval hull\ninv     – (optional, default: false) if true, assume that the state matrix              is invertible and use its inverse in the Φ functions\nbackend – (optional, default: nothing) used if the algorithm needs to apply              concrete polyhedral computations\n\nAlgorithm\n\nThe transformations are:\n\nΦ  exp(Aδ),\nΩ_0  CH(mathcalX_0 ΦmathcalX_0  δU(0)  E_ψ(U(0) δ)  E^+(mathcalX_0 δ)),\nV(k)  δU(k)  E_ψ(U(k) δ).\n\nHere we allow U to be a sequence of time varying non-deterministic input sets.\n\nFor the definition of the sets E_ψ and E^+ see [FRE11]. The Backward method uses E^-.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.Backward","page":"Discretization","title":"ReachabilityAnalysis.Backward","text":"Backward{EM, SO, SI, IT, BT} <: AbstractApproximationModel\n\nBackward approximation model.\n\nFields\n\nexp     – exponentiation method\nsetops  – set opertaions method\nsih     – symmetric interval hull\ninv     – (optional, default: false) if true, assume that the state matrix              is invertible and use its inverse in the Φ functions\nbackend – (optional, default: nothing) used if the algorithm needs to apply              concrete polyhedral computations\n\nAlgorithm\n\nThe transformations are:\n\nΦ  exp(Aδ),\nΩ_0  CH(mathcalX_0 ΦmathcalX_0  δU(0)  E_ψ(U(0) δ)  E^-(mathcalX_0 δ)),\nV(k)  δU(k)  E_ψ(U(k) δ).\n\nHere we allow U to be a sequence of time varying non-deterministic input sets.\n\nFor the definition of the sets E_ψ and E^- see [FRE11]. The Forward method uses E^+.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.CorrectionHull","page":"Discretization","title":"ReachabilityAnalysis.CorrectionHull","text":"CorrectionHull{EM} <: AbstractApproximationModel\n\nDiscretization using the correction hull of the matrix exponential.\n\nFields\n\nexp   – exponentiation method\norder – order of the Taylor series expansion of the matrix exponential\n\nAlgorithm\n\nFor the homogeneous case, this method implements the transformation:\n\nΩ_0 = CH(X_0 e^Aδ  X_0)  FX_0\n\nwhere F is the correction (interval) matrix.\n\nFor the inhomogeneous case, x = Ax + u,  x  X u  U, implements Ω_0 = CH(X_0 exp(Aδ)  X0)  FX0 where F is the correction (interval) matrix.\n\nIn both cases, if A is an interval matrix, the exponential is overapproximated using methods from IntervalMatrices.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#ReachabilityAnalysis.NoBloating","page":"Discretization","title":"ReachabilityAnalysis.NoBloating","text":"NoBloating{EM, SO, IT} <: AbstractApproximationModel\n\nNo bloating, or discrete-time, approximation model.\n\nFields\n\nexp     – exponentiation method\nsetops  – set operations method\ninv     – (optional, default: false) if true, assume that the state matrix              is invertible and use its inverse in the Φ functions\n\nAlgorithm\n\nThe transformations are:\n\nΦ  exp(Aδ)\nΩ_0  mathcalX_0\nV(k)  Φ₁(A δ)U(k), k  0.\n\nThe function Φ₁(A δ) is defined in Φ₁. We allow U to be a sequence of time varying non-deterministic input sets.\n\nSee also Eqs.(14) in [BFFPSV18].\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#Exponentiation","page":"Discretization","title":"Exponentiation","text":"","category":"section"},{"location":"lib/discretize/","page":"Discretization","title":"Discretization","text":"The state transition matrix of the linear ODE x(t) = Ax(t) + u(t) at time delta  0 is Phi = e^Adelta, hence the algorithms usually require to compute exponential matrices. There are distinct ways to compute the matrix exponential e^Adelta depending on the type of A (see e.g. [HIH08]). The available methods can be used through the (unexported) function _exp.","category":"page"},{"location":"lib/discretize/","page":"Discretization","title":"Discretization","text":"For high dimensional systems (typicall n > 2000), computing the matrix exponential is expensive hence it is preferable to compute the action of the matrix exponential over vectors when needed, that is, e^δA v for each v. This method is particularly well-suited if A is vert sparse. Use the option exp=:krylov (or exp=:lazy) for this purpose.","category":"page"},{"location":"lib/discretize/","page":"Discretization","title":"Discretization","text":"ReachabilityAnalysis._exp\nReachabilityAnalysis.Φ₁\nReachabilityAnalysis.Φ₂","category":"page"},{"location":"lib/discretize/#ReachabilityAnalysis._exp","page":"Discretization","title":"ReachabilityAnalysis._exp","text":"_exp(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp)\n\nCompute the matrix exponential e^Aδ.\n\nInput\n\nA    – matrix\nδ    – step size\nalg  – (optional, default: BaseExp) the algorithm used to take the matrix           exponential of Aδ, possible options are BaseExp, LazyExp, PadeExp and IntervalExp           see details in the Algorithm section below\n\nOutput\n\nA matrix or a lazy wrapper of the matrix exponential, depending on alg.\n\nAlgorithm\n\nBaseExp – (alias: :base) use Higham's scaling and squaring method implemented              in Julia standard library; see ?exp for details; if A is a static array,              uses the implementation in StaticArrays.jl\nLazyExp – (alias: :lazy) return a lazy wrapper type around the matrix exponential              using the implementation LazySets.SparseMatrixExp\nPadeExp – (alias: pade) apply Pade approximant method to compute the matrix              exponential of a sparse matrix (requires Expokit.jl)\nIntervalExp – (alias: interval, taylor) apply the Taylor series expansion of the matrix                   exponential with an interval remainder; works if A is an interval matrix\n\nNotes\n\nIf the algorithm LazyExp is used, evaluations of the action of the matrix exponential are done with the expmv implementation from Expokit (but see LazySets#1312 for the planned generalization to other backends).\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₁","page":"Discretization","title":"ReachabilityAnalysis.Φ₁","text":"Φ₁(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp, [isinv]::Bool=false, [Φ]=nothing)\n\nEvaluate the series\n\nΦ₁(A δ) = _i=0^ dfracδ^i+1(i+1)A^i\n\nwhere A is a square matrix of order n and δ  0.\n\nInput\n\nA      – coefficients matrix\nδ      – step size\nalg    – (optional, default: BaseExp) the method used to take the matrix              exponential of the coefficient matrix; see the documentation of              _exp for available options\nisinv  – (optional, default: false) if true, assume that the coefficients             matrix is invertible and compute A^-1\nΦ      – (optional, default: nothing) optionally pass the matrix exponential e^Aδ\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nIf A is invertible, Φ₁ can be computed as\n\nΦ₁(A δ) = A^-1(e^Aδ - I_n)\n\nwhere I_n is the identity matrix of order n.\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP_2n = exp beginpmatrix\nAδ  δI_n \n0  0\nendpmatrix\n\nIt can be shown that\n\nexp(P_2n) = beginpmatrix\nΦ(A δ)  Φ₁(A δ) \n0   δI_n\nendpmatrix\n\nwhere Φ(A δ) = e^Aδ. In particular, Φ₁(A, δ) = P[1:n, (n+1):2*n]. This method can be found in [FRE11].\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₂","page":"Discretization","title":"ReachabilityAnalysis.Φ₂","text":"Φ₂(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp, [isinv]::Bool=false, [Φ]=nothing)\n\nEvaluate the series\n\nΦ₂(A δ) = _i=0^ dfracδ^i+2(i+2)A^i\n\nwhere A is a square matrix of order n and δ  0.\n\nInput\n\nA      – coefficients smatrix\nδ      – step size\nalg    – (optional, default: BaseExp) the method used to take the matrix              exponential of the coefficient matrix; see the documentation of              _exp for available options\nisinv  – (optional, default: false) if true, assume that the coefficients             matrix is invertible and compute A^-1\nΦ      – (optional, default: nothing) optionally pass the matrix exponential e^Aδ\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nIf A is invertible, Φ₂ can be computed as\n\nΦ₂(A δ) = A^-2(e^δA - I_n - δA)\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP_3n = exp beginpmatrix\nAδ  δI_n  0 \n0  0  δI_n \n0  0  0\nendpmatrix\n\nIt can be shown that\n\nexp(P_3n) = beginpmatrix\nΦ(A δ)  Φ₁(A δ)  Φ₂(A δ) \n0  I_n      δI_n \n0  0      I_n\nendpmatrix\n\nwhere Φ(A δ) = e^Aδ. In particular, Φ₂ = P_{3n}[1:n, (2*n+1):3*n]. This method can be found in [FRE11].\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#References","page":"Discretization","title":"References","text":"","category":"section"},{"location":"lib/discretize/","page":"Discretization","title":"Discretization","text":"[HIH08]: Higham, Nicholas J. Functions of matrices: theory and computation. Society for Industrial and Applied Mathematics, 2008.","category":"page"},{"location":"references/#all_ref","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"This page includes references to the scientific works that we have applied throughout this library. Although the list is not meant to be exhaustive, we think it should give a solid starting place for those who want to explore further.","category":"page"},{"location":"references/","page":"References","title":"References","text":"If you use ReachabilityAnalysis.jl for your own work, please consider citing the appropriate original reference(s). For this purpose we provide the BibTeX citation in each case.","category":"page"},{"location":"references/","page":"References","title":"References","text":"If you find that a reference here is missing, if you spot a typo or want to update a reference, do not hesitate to contact us by email, or open an issue. Sorting is alphabetic.","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[AFG20]","page":"References","title":"[AFG20]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Althoff, Matthias, Goran Frehse, and Antoine Girard. Set Propagation Techniques for Reachability Analysis.. Annual Review of Control, Robotics, and Autonomous Systems 4 (2020).","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{althoff2020set,\n  title={Set Propagation Techniques for Reachability Analysis},\n  author={Althoff, Matthias and Frehse, Goran and Girard, Antoine},\n  journal={Annual Review of Control, Robotics, and Autonomous Systems},\n  volume={4},\n  year={2020},\n  publisher={Annual Reviews}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ALU95]","page":"References","title":"[ALU95]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Alur, R., Courcoubetis, C., Halbwachs, N., Henzinger, T. A., Ho, P. H., Nicollin, X., ... & Yovine, S. (1995). The algorithmic analysis of hybrid systems. Theoretical computer science, 138(1), 3-34.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{alur1995algorithmic,\n  title={The algorithmic analysis of hybrid systems},\n  author={Alur, Rajeev and Courcoubetis, Costas and Halbwachs, Nicolas and Henzinger, Thomas A and Ho, Pei-Hsin and Nicollin, Xavier and Olivero, Alfredo and Sifakis, Joseph and Yovine, Sergio},\n  journal={Theoretical computer science},\n  volume={138},\n  number={1},\n  pages={3--34},\n  year={1995},\n  publisher={Citeseer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ALT10]","page":"References","title":"[ALT10]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Althoff, Matthias. Reachability analysis and its application to the safety assessment of autonomous cars. Diss. Technische Universität München, 2010.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@phdthesis{althoff2010reachability,\n  title={Reachability analysis and its application to the safety assessment of autonomous cars},\n  author={Althoff, Matthias},\n  year={2010},\n  school={Technische Universit{\\\"a}t M{\\\"u}nchen}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ASB07]","page":"References","title":"[ASB07]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"M. Althoff, O. Stursberg, and M. Buss. Reachability analysis of linear systems with uncertain parameters and inputs. In Proc. of the 46th IEEE Conference on Decision and Control, pages 726–732, 2007.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@inproceedings{althoff2007reachability,\n  title={Reachability analysis of linear systems with uncertain parameters and inputs},\n  author={Althoff, Matthias and Stursberg, Olaf and Buss, Martin},\n  booktitle={2007 46th IEEE Conference on Decision and Control},\n  pages={726--732},\n  year={2007},\n  organization={IEEE}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[BFFPSV18]","page":"References","title":"[BFFPSV18]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Bogomolov, S., Forets, M., Frehse, G., Viry, F., Podelski, A., & Schilling, C. (2018, April). Reach set approximation through decomposition with low-dimensional sets and high-dimensional matrices. In Proceedings of the 21st International Conference on Hybrid Systems: Computation and Control (part of CPS Week) (pp. 41-50).","category":"page"},{"location":"references/","page":"References","title":"References","text":"@inproceedings{bogomolov2018reach,\n  title={Reach set approximation through decomposition with low-dimensional sets and high-dimensional matrices},\n  author={Bogomolov, Sergiy and Forets, Marcelo and Frehse, Goran and Viry, Fr{\\'e}d{\\'e}ric and Podelski, Andreas and Schilling, Christian},\n  booktitle={Proceedings of the 21st International Conference on Hybrid Systems: Computation and Control (part of CPS Week)},\n  pages={41--50},\n  year={2018}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[BFFPS19]","page":"References","title":"[BFFPS19]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Bogomolov, S., Forets, M., Frehse, G., Potomkin, K., & Schilling, C. (2020). Reachability analysis of linear hybrid systems via block decomposition. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 39(11), 4018-4029.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{bogomolov2020reachability,\n  title={Reachability analysis of linear hybrid systems via block decomposition},\n  author={Bogomolov, Sergiy and Forets, Marcelo and Frehse, Goran and Potomkin, Kostiantyn and Schilling, Christian},\n  journal={IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},\n  volume={39},\n  number={11},\n  pages={4018--4029},\n  year={2020},\n  publisher={IEEE}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[CHEN15]","page":"References","title":"[CHEN15]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Chen, Xin. Reachability Analysis of Non-Linear Hybrid Systems Using Taylor Models. Diss. Fachgruppe Informatik, RWTH Aachen University, 2015.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@phdthesis{chen2015reachability,\n  title={Reachability Analysis of Non-Linear Hybrid Systems Using Taylor Models},\n  author={Chen, Xin},\n  year={2015},\n  school={Fachgruppe Informatik, RWTH Aachen University}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[COMB03]","page":"References","title":"[COMB03]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Combastel, C. A state bounding observer based on zonotopes. 2003 European Control Conference (ECC). IEEE, 2003.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@inproceedings{combastel2003state,\n  title={A state bounding observer based on zonotopes},\n  author={Combastel, C},\n  booktitle={2003 European Control Conference (ECC)},\n  pages={2589--2594},\n  year={2003},\n  organization={IEEE}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[FRE11]","page":"References","title":"[FRE11]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Frehse, G., Le Guernic, C., Donzé, A., Cotton, S., Ray, R., Lebeltel, O., ... & Maler, O. (2011, July). SpaceEx: Scalable verification of hybrid systems. In International Conference on Computer Aided Verification (pp. 379-395). Springer, Berlin, Heidelberg. pdf, appendix, presentation","category":"page"},{"location":"references/","page":"References","title":"References","text":"@inproceedings{frehse2011spaceex,\n  title={SpaceEx: Scalable verification of hybrid systems},\n  author={Frehse, Goran and Le Guernic, Colas and Donz{\\'e}, Alexandre and Cotton, Scott and Ray, Rajarshi and Lebeltel, Olivier and Ripado, Rodolfo and Girard, Antoine and Dang, Thao and Maler, Oded},\n  booktitle={International Conference on Computer Aided Verification},\n  pages={379--395},\n  year={2011},\n  organization={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[FRE16]","page":"References","title":"[FRE16]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Frehse, G. (2016). Scalable verification of hybrid systems. (Habilitation á diriger des recherches, Univ. Grenoble Alpes).","category":"page"},{"location":"references/","page":"References","title":"References","text":"@phdthesis{frehse2016scalable,\n  title={Scalable verification of hybrid systems},\n  author={Frehse, Goran},\n  year={2016}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[FR12]","page":"References","title":"[FR12]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Frehse, Goran, and Rajarshi Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions. ADHS. 2012.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@inproceedings{frehse2012flowpipe,\n  title={Flowpipe-Guard Intersection for Reachability Computations with Support Functions.},\n  author={Frehse, Goran and Ray, Rajarshi},\n  booktitle={ADHS},\n  pages={94--101},\n  year={2012}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GIR04]","page":"References","title":"[GIR04]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Girard, Antoine. Analyse algorithmique des systemes hybrides. Diss. Institut National Polytechnique de Grenoble-INPG, 2004.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@phdthesis{girard2004analyse,\n  title={Analyse algorithmique des systemes hybrides},\n  author={Girard, Antoine},\n  year={2004},\n  school={Institut National Polytechnique de Grenoble-INPG}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GIR05]","page":"References","title":"[GIR05]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Girard, A. (2005, March). Reachability of uncertain linear systems using zonotopes. In International Workshop on Hybrid Systems: Computation and Control (pp. 291-305). Springer, Berlin, Heidelberg.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@inproceedings{girard2005reachability,\n  title={Reachability of uncertain linear systems using zonotopes},\n  author={Girard, Antoine},\n  booktitle={International Workshop on Hybrid Systems: Computation and Control},\n  pages={291--305},\n  year={2005},\n  organization={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GIR13]","page":"References","title":"[GIR13]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Girard, Antoine. Computational approaches to analysis and control of hybrid systems. Diss. 2013.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@phdthesis{girard2013computational,\n  title={Computational approaches to analysis and control of hybrid systems},\n  author={Girard, Antoine},\n  year={2013}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GLGM06]","page":"References","title":"[GLGM06]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Girard, A., Le Guernic, C., & Maler, O. (2006, March). Efficient computation of reachable sets of linear time-invariant systems with inputs. In International Workshop on Hybrid Systems: Computation and Control (pp. 257-271). Springer, Berlin, Heidelberg.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@inproceedings{girard2006efficient,\n  title={Efficient computation of reachable sets of linear time-invariant systems with inputs},\n  author={Girard, Antoine and Le Guernic, Colas and Maler, Oded},\n  booktitle={International Workshop on Hybrid Systems: Computation and Control},\n  pages={257--271},\n  year={2006},\n  organization={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[HG19]","page":"References","title":"[HG19]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"el Hakim, Viktorio S., and Marco JG Bekooij. Reachability Analysis of Hybrid Automata with Clocked Linear Dynamics. Proceedings of the 22nd International Workshop on Software and Compilers for Embedded Systems. 2019.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@inproceedings{el2019reachability,\n  title={Reachability Analysis of Hybrid Automata with Clocked Linear Dynamics},\n  author={el Hakim, Viktorio S and Bekooij, Marco JG},\n  booktitle={Proceedings of the 22nd International Workshop on Software and Compilers for Embedded Systems},\n  pages={27--36},\n  year={2019}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[JOL]","page":"References","title":"[JOL]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Joldes, M. M. (2011). Approximations polynomiales rigoureuses et applications. (Doctoral dissertation, Lyon, École normale supérieure).","category":"page"},{"location":"references/","page":"References","title":"References","text":"@phdthesis{joldes2011approximations,\n  title={Approximations polynomiales rigoureuses et applications},\n  author={Joldes, Mioara Maria},\n  year={2011},\n  school={Lyon, {\\'E}cole normale sup{\\'e}rieure}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[KEK18]","page":"References","title":"[KEK18]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Kekatos, Nikolaos. Vérification formelle des systèmes cyber-physiques dans le processus industriel de la conception basée sur modèle. Diss. Grenoble Alpes, 2018.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@phdthesis{kekatos2018verification,\n  title={V{\\'e}rification formelle des syst{\\`e}mes cyber-physiques dans le processus industriel de la conception bas{\\'e}e sur mod{\\`e}le},\n  author={Kekatos, Nikolaos},\n  year={2018},\n  school={Grenoble Alpes}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[LGG09]","page":"References","title":"[LGG09]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Le Guernic, Colas, and Antoine Girard. Reachability analysis of linear systems using support functions. Nonlinear Analysis: Hybrid Systems 4.2 (2010): 250-262. pdf","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{le2010reachability,\n  title={Reachability analysis of linear systems using support functions},\n  author={Le Guernic, Colas and Girard, Antoine},\n  journal={Nonlinear Analysis: Hybrid Systems},\n  volume={4},\n  number={2},\n  pages={250--262},\n  year={2010},\n  publisher={Elsevier}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[LGG09b]","page":"References","title":"[LGG09b]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Le Guernic, Colas, and Antoine Girard. Reachability analysis of hybrid systems using support functions. International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2009.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@inproceedings{le2009reachability,\n  title={Reachability analysis of hybrid systems using support functions},\n  author={Le Guernic, Colas and Girard, Antoine},\n  booktitle={International Conference on Computer Aided Verification},\n  pages={540--554},\n  year={2009},\n  organization={Springer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[LG09]","page":"References","title":"[LG09]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Le Guernic, Colas. Calcul d’Atteignabilité des Systemes Hybrides a Partie Continue Linéaire. Diss. PhD thesis, Université Grenoble I, 2009.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@phdthesis{le2009calcul,\n  title={Calcul d’Atteignabilit{\\'e} des Systemes Hybrides a Partie Continue Lin{\\'e}aire},\n  author={Le Guernic, Colas},\n  year={2009},\n  school={Citeseer}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[M65]","page":"References","title":"[M65]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Moore, Ramon E. Automatic local coordinate transformations to reduce the growth of error bounds in interval computation of solutions of ordinary differential equations. Error in digital computation 2 (1965): 103-140.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{moore1965automatic,\n  title={Automatic local coordinate transformations to reduce the growth of error bounds in interval computation of solutions of ordinary differential equations},\n  author={Moore, Ramon E},\n  journal={Error in digital computation},\n  volume={2},\n  pages={103--140},\n  year={1965}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[RAY12]","page":"References","title":"[RAY12]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Ray, Rajarshi. Calcul d'Atteignabilité des systèmes hybrides avec des fonctions de support. Diss. 2012.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@phdthesis{ray2012calcul,\n  title={Calcul d'Atteignabilit{\\'e} des syst{\\`e}mes hybrides avec des fonctions de support},\n  author={Ray, Rajarshi},\n  year={2012}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ROC18]","page":"References","title":"[ROC18]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Rocca, Alexandre. Formal methods for modelling and validation of biological models. Diss. Grenoble Alpes, 2018.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@phdthesis{rocca2018formal,\n  title={Formal methods for modelling and validation of biological models},\n  author={Rocca, Alexandre},\n  year={2018},\n  school={Grenoble Alpes}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[SCHI18]","page":"References","title":"[SCHI18]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Schilling, Christian-Matthias. Fundamental techniques for the scalable analysis of systems. Diss. University of Freiburg, Freiburg im Breisgau, Germany, 2018.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@phdthesis{schilling2018fundamental,\n  title={Fundamental techniques for the scalable analysis of systems.},\n  author={Schilling, Christian-Matthias},\n  year={2018},\n  school={University of Freiburg, Freiburg im Breisgau, Germany}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[SCHU19]","page":"References","title":"[SCHU19]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Schupp, Stefan. State set representations and their usage in the reachability analysis of hybrid systems. No. RWTH-2019-08875. Fachgruppe Informatik, 2019.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@techreport{schupp2019state,\n  title={State set representations and their usage in the reachability analysis of hybrid systems},\n  author={Schupp, Stefan},\n  year={2019},\n  institution={Fachgruppe Informatik}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[YS18]","page":"References","title":"[YS18]","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Yang, Xuejiao, and Joseph K. Scott. A comparison of zonotope order reduction techniques. Automatica 95 (2018): 378-384.","category":"page"},{"location":"references/","page":"References","title":"References","text":"@article{yang2018comparison,\n  title={A comparison of zonotope order reduction techniques},\n  author={Yang, Xuejiao and Scott, Joseph K},\n  journal={Automatica},\n  volume={95},\n  pages={378--384},\n  year={2018},\n  publisher={Elsevier}\n}","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"DocTestSetup  = quote\n    using ReachabilityAnalysis\nend\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"man/basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"man/basics/#Introduction","page":"Basics","title":"Introduction","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"In simple terms, reachability analysis is concerned with studying the sets of states that a system can reach, starting from a set of initial states and under the influence of a set of input trajectories and parameter values.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"To fix ideas, consider a purely continuous dynamical system over some state space mathcalX subset mathbbR^n defined via a differential equation of the form:","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"    x(t) = f(x u)","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"where u(t) in mathcalU(t) ranges over some specified set of admissible input signals. Given a set of initial states mathcalX_0 subseteq mathcalX, the problem we are interested in is to compute all the states visited by trajectories of the system starting from any x_0 in mathcalX_0 and for any admissible input function u(t). In other sections of this manual we also consider generalizations of this problem such as uncertain parameters, or dynamical systems which are hybrid, i.e. mixing continuous dynamics and discrete transitions.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"In order to compute with sets, we need to find convenient ways to represent and operate with them. In the next section we consider some common set representations and show how to work with LazySets.jl.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"More technically, we define the reachable set at a given time point delta in mathbbR, also known as the reach-set for the ODE","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"x(t) = f(x(t) u(t) p(t) t)","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"as given by","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"mathcalR(δ) = left x(δ) = int_0^δ f(x(t) u(t) p(t) t) dt x(0)  X_0 u(t)  mathcalU p(t)  mathcalP right","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Here X_0 denotes the set of initial states, mathcalU denotes the input set, and mathcalP denotes the parameter values. For practical problems, the set mathcalR(δ) cannot be obtained exactly, and reachability methods aim at computing suitable over-approximations (or under-approximations) of it.","category":"page"},{"location":"man/basics/#Set-representations","page":"Basics","title":"Set representations","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Subets of mathbbR^n can be represented in different ways. Depending on the type of operation that we want to apply, one set representation may be more convenient than another one. There are two important characteristics:","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Closure: A set representation is said to be closed under a given operation if the result of the operation is again a set in the same class.\nCost: To measure the cost of making a given operation on a set, we consider the total number of binary operations, denoted with mathrmOp(cdot). (....)","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"In the rest of this sectio we define the usual set representations used in reachability analysis and recall some fundamental properties. Moreover, we show how to define these sets using the library LazySets.jl.","category":"page"},{"location":"man/basics/#Over-and-under-approximations","page":"Basics","title":"Over- and under- approximations","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Given a set mathcalX subseteq mathbbR^n, any subset of mathcalX is said to be an underapproximation. Conversely, any set containing mathcalX is said to be an overapproximation.","category":"page"},{"location":"man/basics/#Polyhedra","page":"Basics","title":"Polyhedra","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"A hyperplane is the set mathcalH = x  mathbbR^n  a^Tx = b, where a  mathbbR^n is the normal vector and b  mathbbR is the displacement.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"In LazySets.jl, the type hyperplane can be used to define a hyperplane.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"A halfspace is the set mathcalH = x  mathbbR^n  a^Tx  b, where a  mathbbR^n is the normal vector and b  mathbbR is the displacement. Please note that a half-space defines the region on one side of the hyperplane a^Tx = b.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"In LazySets.jl, the type HalfSpace can be used to define a half-space.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"When we consider the intersection of a finite subset of half-spaces, we get a polyhedron. A polyhedron is thus the set defined as mathcalP  mathbbR^n,","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"    mathcalP = x in mathbbR^n  bigcap_i=1^m a^T_i x leq b_i ","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"where a_i in mathbbR^n and b_i in mathbbR. A polytope is a bounded polyhedron.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"In LazySets.jl, the types HPolyhedron and HPolytope representent polyhedron and polytopes respectively. For example, . . . .","category":"page"},{"location":"man/basics/#Support-functions","page":"Basics","title":"Support functions","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"The support function of a compact set mathcalX subseteq mathbbR^n attributes to a direction ell in mathbbR^n the real number","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"    rho_mathcalX (ell) = max ell^T x  x in mathcalX ","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"It is important to note that for a given direction ell, the support function defines the position of a halfspace","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"    mathcalH_ell = x in mathbbR^n  ell^T x leq rho_mathcalX(ell)","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"using LazySets, Plots\n\nE = Ellipsoid([1.0, 1.0], [2.7 0.28; 0.28 1.04])\n\nH1 = HalfSpace([1.0, 2.0], ρ([1.0, 2.0], E))\nH2 = HalfSpace([-1.0, -2.0], ρ([-1.0, -2.0], E))\nH3 = HalfSpace([-1.0, 2.0], ρ([-1.0, 2.0], E))\nH4 = HalfSpace([1.0, -2.0], ρ([1.0, -2.0], E))\n\n\nP = HPolytope([H1, H2, H3, H4])\n\nplot(E)\nplot!(P)\n\nplot!(Singleton(σ([1.0, 2.0], E)), lab=\"d1\")\nplot!(Singleton(σ([-1.0, -2.0], E)), lab=\"-d1\")\nplot!(Singleton(σ([-1.0, 2.0], E)), lab=\"d2\")\nplot!(Singleton(σ([1.0, -2.0], E)), lab=\"-d2\")","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"The following formulas hold:","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"\\\nrho_{\\mathcal{X} \\oplus \\mathcal{Y}}(\\ell) =\n\\\nrho_{M\\mathcal{X}}(\\ell) =  for any","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Here MmathcalX represents the linear map for M in mathbbR^m times n.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"\\\nrho_{CH(\\mathcal{X}, \\mathcal{Y})}(\\ell) =","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"The following table summarizes the number of | Operation                                     | Simplification rule | Cost  | |–––––––––––––––––––––––-|–––-|–––| | rho_mathcalX oplus mathcalY(ell) |rho_mathcalX(ell) + rho_mathcalY(ell)  |  1     | | rho_MmathcalX(ell)                   |rho_mathcalX(M^Tell)|   2mn   | | rho_CH(mathcalX mathcalY)(ell)   |maxrho_mathcalX(ell) rho_mathcalY(ell)|  1    |","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"which touches and contains mathcalX . If ell is of unit length, then rho_mathcalX(ell) is the signed distance of mathcalH_ell to the origin.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Evaluating the support function for a set of directions L  mathbbR^n provides an overapproximation","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"    lceil mathcalX rceil _L = bigcap_ell in L  x in mathbbR^n  ell^T x leq rho_mathcalX(ell) ","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"i.e., mathcalX  lceil mathcalX rceil _L. If L = mathbbR^n, then mathcalX = lceil mathcalX rceil _L, so the support function represents any convex set mathcalX exactly. If L is a finite set of directions L = ell_1     ell_m, then lceil mathcalX rceil _L is a polyhedron.","category":"page"},{"location":"man/basics/#Hyperrectangular-sets","page":"Basics","title":"Hyperrectangular sets","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"A special class of polyhedra are (...)","category":"page"},{"location":"man/basics/#Zonotopic-sets","page":"Basics","title":"Zonotopic sets","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Zonotopes are a sub-class of polytopes defined as the image of a unit cube under an affine transformation. An equivalent characterization of zonotopes is the generator representation. Here, Z  mathbbR^n is defined by a center c  mathbbR^n and a finite number of generators g_1     g_p  mathbbR^n such that","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Z =  c + sum_i=1^p xi_i g_i  xi_i  1 1","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"It is common to note Z = (c langle g_1     g_p rangle) or simply Z = (c G), where g_i is the i-th column of G.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"We introduce the order of a zonotope as o = frackn. The order of a Zonotope Z in LazySets can be calculated using the function order(Z).","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"using LazySets, Plots\nZ = Zonotope([1, 1.], [-1 0.3 1.5 0.3; 0 0.1 -0.3 0.3])\nplot(Z)\nquiver!(fill(1., 4), fill(1., 4), quiver=(genmat(Z)[1, :], genmat(Z)[2, :]), color=:black)","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"There are other useful characterization of zonotopes. A zonotope can be seen as the Minkowski addition of line segments resulting in centrally symmetric convex polytopes as shown in the following figure, which illustrates how each generator spans the zonotope.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"The cost is measured in terms of the number of binary operations, mathrmOp(cdot).","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Z_1 = (c langle v_1 dotsb v_k rangle) Z_2 = (d langle w_1 dotsb w_m rangle) subset mathbbR^n M in mathbbR^m times n","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Z_1 oplus Z_2 = (c+d langle v_1 dotsb v_k w_1 dotsb w_m rangle)","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"MZ_1 = (Mc langle Mv_1 dotsb Mv_k rangle)","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"CH(Z_1 e^AdeltaZ_1) subseteq frac12(c + e^Adeltaclangle v_1 + e^Adeltav_1 dotsb v_k+e^Adeltav_k v_1 - e^Adeltav_1 v_k - e^Adeltav_k c - e^Adeltac rangle )","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Operation Simplification Rule Cost\nZ_1 oplus Z_2  n\nMZ_1  2mn(k+1)\nCH(Z_1 e^AdeltaZ_1)  2n^2(k+1)+2n(k+2)","category":"page"},{"location":"man/basics/#Hausdorff-distance","page":"Basics","title":"Hausdorff distance","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Tthe notion of Hausdorff distance can be used to measure the distance between sets. It constitutes a practical theoretical tool to quantify the quality of an approximation.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"  d_H(mathcalX mathcalY) = max left( sup_x in mathcalXinf_y in mathcalY Vert x - y Vert sup_y in mathcalYinf_x in mathcalX Vert x - y Vert right)","category":"page"},{"location":"man/basics/#Taylor-models","page":"Basics","title":"Taylor models","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"#=\nusing ReachabilityAnalysis, Plots\n\nf(x) = -6x^3 + (13/3)x^2 + (31/3)x\ndom = -3.5 .. 3.5\n\nplot(f, -3.5, 3.5, lab=\"f\", xlab=\"x\")\n\nx = Taylor1(5)\nset_taylor1_varname(\"x\")\nf(x)\n\nrem = 0 .. 0\nx0 = 0.0\ndom = -3.5 .. 3.5\ntm = TaylorModel1(f(x), rem, x0, dom)\n=#","category":"page"},{"location":"man/basics/#Reach-sets","page":"Basics","title":"Reach-sets","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"We define the reachable set associated to a time interval 0 δ, also known as the flowpipe, as","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"mathcalF(0 δ) = _t in 0 δ mathcalR(t)","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"Reachability methods are used to compute rigorous approximations of the flowpipe for continuous or hybrid systems, in bounded time or unbounded time horizon. Here we use the term rigorous in the formal, or mathematical sense, that no solution \"escapes\" the flowpipe, for any trajectory that satisfies the constraints (initial states, inputs, and noise).","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"On the other hand, the amount of computation required depends heavily on the particular problem statement. One notable example is safety verification, which simply stated requires to prove that the flowpipe does not intersect a region of \"bad states\". In this setting, one can often reason about the flowpipe lazily, i.e. without actually computing it in full.","category":"page"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"We consider as a running example in this section the simple harmonic oscillator,","category":"page"},{"location":"man/basics/#Flowpipes","page":"Basics","title":"Flowpipes","text":"","category":"section"},{"location":"man/basics/","page":"Basics","title":"Basics","text":"A flowpipe represents a collection of reach-sets and behaves like their set union.","category":"page"},{"location":"models/DuffingOscillator/","page":"Duffing oscillator","title":"Duffing oscillator","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/DuffingOscillator/DuffingOscillator.jl\"","category":"page"},{"location":"models/DuffingOscillator/#Duffing-Oscillator","page":"Duffing oscillator","title":"Duffing Oscillator","text":"","category":"section"},{"location":"models/DuffingOscillator/","page":"Duffing oscillator","title":"Duffing oscillator","text":"(Image: )","category":"page"},{"location":"models/DuffingOscillator/","page":"Duffing oscillator","title":"Duffing oscillator","text":"note: Overview\nSystem type: nonlinear\nState dimension: 2\nApplication domain: Nonlinear physics","category":"page"},{"location":"models/DuffingOscillator/#Implementation","page":"Duffing oscillator","title":"Implementation","text":"","category":"section"},{"location":"models/DuffingOscillator/","page":"Duffing oscillator","title":"Duffing oscillator","text":"using ReachabilityAnalysis, Plots\n\n@taylorize function duffing!(du, u, p, t)\n    local α = -1.0\n    local β = 1.0\n    local δ = 0.3\n    local γ = 0.37\n\n    x, v = u\n    f = γ * cos(ω * t)\n\n    du[1] = u[2]\n    du[2] = - α*x - δ*v - β*x^3 + f\nend\n\nω = 1.2\nT = 2*pi / ω\nX0 = Singleton([1.0, 0.0]) ⊕ BallInf(zeros(2), 0.1)\nprob = @ivp(x' = duffing!(x), x(0) ∈ X0, dim=2);\nnothing #hide","category":"page"},{"location":"models/DuffingOscillator/#Results","page":"Duffing oscillator","title":"Results","text":"","category":"section"},{"location":"models/DuffingOscillator/","page":"Duffing oscillator","title":"Duffing oscillator","text":"sol = solve(prob, tspan=(0.0, 20*T), alg=TMJets21a());\nnothing #hide","category":"page"},{"location":"models/DuffingOscillator/","page":"Duffing oscillator","title":"Duffing oscillator","text":"plot(sol, vars=(0, 1), xlab=\"t\", ylab=\"x\", lw=0.2, color=:blue)","category":"page"},{"location":"models/DuffingOscillator/","page":"Duffing oscillator","title":"Duffing oscillator","text":"plot(sol, vars=(0, 2), xlab=\"t\", ylab=\"v\", lw=0.2, color=:blue)","category":"page"},{"location":"models/DuffingOscillator/","page":"Duffing oscillator","title":"Duffing oscillator","text":"plot(sol, vars=(1, 2), xlab=\"x\", ylab=\"v\", lw=0.5, color=:red)","category":"page"},{"location":"lib/operations/","page":"Further set operations","title":"Further set operations","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/operations/#Further-set-operations","page":"Further set operations","title":"Further set operations","text":"","category":"section"},{"location":"lib/operations/#Convexification","page":"Further set operations","title":"Convexification","text":"","category":"section"},{"location":"lib/operations/","page":"Further set operations","title":"Further set operations","text":"convexify","category":"page"},{"location":"lib/operations/#ReachabilityAnalysis.convexify","page":"Further set operations","title":"ReachabilityAnalysis.convexify","text":"convexify(fp::Flowpipe{N, <:AbstractLazyReachSet}) where {N}\n\nReturn a reach-set representing the convex hull array of the flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nA reach-set that contains the convex hull array, ConvexHullArray, of the given flowpipe.\n\nNotes\n\nThe time span of this reach-set is the same as the time-span of the flowpipe.\n\nThis function allocates an array to store the sets of the flowpipe.\n\n\n\n\n\nconvexify(fp::AbstractVector{<:AbstractLazyReachSet{N}}) where {N}\n\nReturn a reach-set representing the convex hull array of the array of the array of reach-sets.\n\nInput\n\nfp – array of reach-sets\n\nOutput\n\nA reach-set that contains the convex hull array, ConvexHullArray, of the given flowpipe.\n\nNotes\n\nThe time span of this reach-set corresponds to the minimum (resp. maximum) of the time span of each reach-set in fp.\n\nThis function allocates an array to store the sets of the flowpipe.\n\nThe function doesn't assume that the reach-sets are time ordered.\n\n\n\n\n\n","category":"function"},{"location":"lib/operations/#Quality-measures","page":"Further set operations","title":"Quality measures","text":"","category":"section"},{"location":"lib/operations/","page":"Further set operations","title":"Further set operations","text":"ReachabilityAnalysis.relative_error","category":"page"},{"location":"lib/operations/#ReachabilityAnalysis.relative_error","page":"Further set operations","title":"ReachabilityAnalysis.relative_error","text":"relative_error(x, x_ref)\n\nCompute the relative error between interval x and a reference interval xref.\n\nInput\n\nx    – interval\nxref – reference interval\n\nOutput\n\nAn interval representing the relative error (in percentage) of x with respect to the reference interval xref.\n\nAlgorithm\n\nIf x = x_L x_Handxref = [xref_L, xref_H], the output is the intervaly = 100 * [y_L, y_H]computed asy_L = -(x_L - xref_L) / denandy_H = (x_H - xref_H) / den, whereden = xref_H - xref_L`.\n\nThis function measures the relative error between an interval x and a reference interval x_ref accounting for it the lower and the upper range bounds separately (see  Eq. (20) in [1]).\n\nReferences\n\n[1] Althoff, Matthias, Dmitry Grebenyuk, and Niklas Kochdumper.     \"Implementation of Taylor models in CORA 2018.\"     Proc. of the 5th International Workshop on Applied Verification for Continuous     and Hybrid Systems. 2018. pdf\n\n\n\n\n\n","category":"function"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/LotkaVolterra/LotkaVolterra.jl\"","category":"page"},{"location":"models/LotkaVolterra/#Lotka-Volterra","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"","category":"section"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"(Image: )","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"note: Overview\nSystem type: Nonlinear system\nState dimension: 2\nApplication domain: Biological Systems","category":"page"},{"location":"models/LotkaVolterra/#Model-description","page":"Lotka-Volterra","title":"Model description","text":"","category":"section"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"The 2-dimensional Lotka-Volterra system depicts the populations change of a class of predators and a class of preys. The growth rate of preys’ population x over time is given by","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"    fracdxdt = α x - β xy","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"where  alpha, beta are constant parameters and y is the population of predators.","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"It gives that the number of preys grows exponentially without predation.","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"The population growth of predators is governed by the differential equation","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"fracdydt = δ xy - γy","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"where  gamma delta are constant parameters.","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"We set those parameters as alpha = 15  beta = 1  gamma = 3 and delta = 1.","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"using ReachabilityAnalysis, JLD2\n\n@taylorize function lotkavolterra!(dx, x, params, t)\n    local α, β, γ, δ = 1.5, 1., 3., 1.\n    dx[1] = α * x[1] - β * x[1] * x[2]\n    dx[2] = δ * x[1] * x[2] - γ * x[2]\n    return dx\nend","category":"page"},{"location":"models/LotkaVolterra/#Reachability-settings","page":"Lotka-Volterra","title":"Reachability settings","text":"","category":"section"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"We consider the initial set  xin 4852 y in 1822.","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"X0 = Hyperrectangle(low=[4.8, 1.8], high=[5.2, 2.2]);\nprob = @ivp(x' = lotkavolterra!(x), dim=2, x(0) ∈ X0)\nsol = solve(prob, T=8.0, alg=TMJets());\nsolz = overapproximate(sol, Zonotope);\nnothing #hide","category":"page"},{"location":"models/LotkaVolterra/#Results","page":"Lotka-Volterra","title":"Results","text":"","category":"section"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"using Plots\n\nplot(solz, vars=(1, 2), alpha=0.3,lw=0., xlab=\"x\", ylab=\"y\", label=\"Flowpipe\", legend=:bottomright)\nplot!(X0, label=\"X(0)\")","category":"page"},{"location":"models/LotkaVolterra/#Adding-parameter-variation","page":"Lotka-Volterra","title":"Adding parameter variation","text":"","category":"section"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"@taylorize function f(du, u, p, t)\n    du[1] = u[3] * u[1] - u[4] * (u[1] * u[2]) - u[7] * u[1]^2\n    du[2] = -u[5] * u[2] + u[6] * (u[1] * u[2])\n\n    #encode uncertain params\n    du[3] = zero(u[1]) # p[1]\n    du[4] = zero(u[1]) # p[2]\n    du[5] = zero(u[1]) # p[3]\n    du[6] = zero(u[1]) # p[4]\n    du[7] = zero(u[1]) # p[5]\nend","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"encode initial-value problem","category":"page"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"p_int = (0.99..1.01) × (0.99..1.01) × (2.99..3.01) × (0.99..1.01) × (0.099..0.101)\nU0 = Singleton([1.0, 1.0]) × convert(Hyperrectangle, p_int)\nprob = @ivp(u' = f(u), dim: 7, u(0) ∈ U0);\n\nsol = solve(prob, tspan=(0.0, 10.0));\nsolz = overapproximate(sol, Zonotope);\n\nplot(solz, vars=(1, 2), lw=0.3, title=\"Uncertain params\", lab=\"abstol = 1e-15\", xlab=\"u1\", ylab=\"u2\")","category":"page"},{"location":"models/LotkaVolterra/#Uncertain-initial-condition-(u0)","page":"Lotka-Volterra","title":"Uncertain initial condition (u0)","text":"","category":"section"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"Now we consider an initial box around u0","category":"page"},{"location":"models/LotkaVolterra/#\\epsilon-0.05","page":"Lotka-Volterra","title":"epsilon = 005","text":"","category":"section"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"u0 = Singleton([1.0, 1.0])\n□(ϵ) = BallInf(zeros(2), ϵ)\nU0 = (u0 ⊕ □(0.05)) × convert(Hyperrectangle, p_int)\n\nprob = @ivp(u' = f(u), dim: 7, u(0) ∈ U0)\n\nsol = solve(prob, tspan=(0.0, 10.0), TMJets(abstol=1e-10))\nsolz = overapproximate(sol, Zonotope)\nplot(solz, vars=(1, 2), color=:orange, lw=0.3,\n     lab=\"eps = 0.05\", title=\"Uncertain u0 and uncertain params\",\n     xlab=\"u1\", ylab=\"u2\")","category":"page"},{"location":"models/LotkaVolterra/#\\epsilon-0.01","page":"Lotka-Volterra","title":"epsilon = 001","text":"","category":"section"},{"location":"models/LotkaVolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"U0 = (u0 ⊕ □(0.01)) × convert(Hyperrectangle, p_int)\nprob = @ivp(u' = f(u), dim: 7, u(0) ∈ U0)\n\nsol = solve(prob, tspan=(0.0, 10.0), TMJets(abstol=1e-10))\nsolz = overapproximate(sol, Zonotope)\nplot!(solz, vars=(1, 2), color=:blue, lw=0.3,\n  lab=\"eps = 0.01\", title=\"Uncertain u0 and uncertain params\",\n  xlab=\"u1\", ylab=\"u2\")","category":"page"},{"location":"about/#About","page":"About","title":"About","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/#Contributing","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"If you like this package, consider contributing! We welcome bug reports, examples that can be added to the documentation, or new feature proposals.","category":"page"},{"location":"about/","page":"About","title":"About","text":"Below we list some conventions that we follow when contributing to this package. For specific guidelines on documentation see the JuliaReach Developer's Documentation.","category":"page"},{"location":"about/#Branches","page":"About","title":"Branches","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Each pull request (PR) should be pushed in a new branch with the name of the author followed by a descriptive name, e.g. mforets/my_feature. If the branch is associated to a previous discussion in an issue, we use the name of the issue for easier lookup, e.g. mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This project is synchronized with Travis CI, such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to understand and fix the failing tests if they exist. We support Julia v1.0 and develop in the latest stable release. For experimentation we also build on the nightly branch.","category":"page"},{"location":"about/","page":"About","title":"About","text":"To run the unit tests locally, you should do:","category":"page"},{"location":"about/","page":"About","title":"About","text":"$ julia --color=yes test/runtests.jl","category":"page"},{"location":"about/#Contributing-to-the-documentation","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This documentation is written in Markdown, and it relies on Documenter.jl to produce the HTML layout. To build the documentation, run make.jl:","category":"page"},{"location":"about/","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/LaubLoomis/LaubLoomis.jl\"","category":"page"},{"location":"models/LaubLoomis/#Laub-Loomis","page":"Laub-Loomis","title":"Laub-Loomis","text":"","category":"section"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"(Image: )","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"note: Overview\nSystem type: polynomial with quadratic nonlinearities\nState dimension: 7\nApplication domain: Molecular Biology","category":"page"},{"location":"models/LaubLoomis/#Model-description","page":"Laub-Loomis","title":"Model description","text":"","category":"section"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"The Laub-Loomis model is presented in [LL98] for studying a class of enzymatic activities. The dynamics can be defined by the following ODE with 7 variables.","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"using ReachabilityAnalysis, Plots\n\n@taylorize function laubloomis!(dx, x, params, t)\n    dx[1] = 1.4*x[3] - 0.9*x[1]\n    dx[2] = 2.5*x[5] - 1.5*x[2]\n    dx[3] = 0.6*x[7] - 0.8*(x[2]*x[3])\n    dx[4] = 2 - 1.3*(x[3]*x[4])\n    dx[5] = 0.7*x[1] - (x[4]*x[5])\n    dx[6] = 0.3*x[1] - 3.1*x[6]\n    dx[7] = 1.8*x[6] - 1.6*(x[2]*x[7])\n    return dx\nend","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"The system is asymptotically stable and the equilibrium is the origin.","category":"page"},{"location":"models/LaubLoomis/#Specifications","page":"Laub-Loomis","title":"Specifications","text":"","category":"section"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"The specification for the analysis is given next. The initial sets are defined according to the ones used in [TD13]. They are boxes centered at x_1(0) = 12, x_2(0) = 105, x_3(0) = 15, x_4(0) = 24, x_5(0) = 1, x_6(0) = 01, x_7 (0) = 045. The range of the box in the i-th dimension is defined by the interval x_i(0)  W x_i(0) + W. The width W of the initial set is vital to the difficulty of the reachability analysis job. The larger the initial set the harder the reachability analysis.","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"function laubloomis(; W=0.01)\n    # initial states\n    X0c = [1.2, 1.05, 1.5, 2.4, 1.0, 0.1, 0.45]\n    X0 = Hyperrectangle(X0c, fill(W, 7))\n\n    # initial-value problem\n    prob = @ivp(x' = laubloomis!(x), dim: 7, x(0) ∈ X0)\n\n    return prob\nend","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"We consider W = 001, W = 005, and W = 01. The specification for each scenario is the following:","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"W = 001 and W = 005: the unsafe region is defined by ``x_4 ≥ 4.5\nW = 01: the unsafe set is defined by x_4  5.","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"The time horizon for all cases is [0, 20].","category":"page"},{"location":"models/LaubLoomis/#Results","page":"Laub-Loomis","title":"Results","text":"","category":"section"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"The final widths of x_4 along with the computation times are provided for all three cases. A figure is provided in the (t x_4) axes, with t  0 20, x_4  15 5, where the three plots are overlaid.","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"Since the safety condition is only related to the variable x_4, we present the plots of projections of the overapproximations in the t - x_4 plane such that t is the time variable.","category":"page"},{"location":"models/LaubLoomis/#Case-1:-Smaller-initial-states","page":"Laub-Loomis","title":"Case 1: Smaller initial states","text":"","category":"section"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"In this case we consider thet the width of the initial states is W = 001.","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"prob = laubloomis(W=0.01)\nalg = TMJets(abstol=1e-11, orderT=7, orderQ=1, adaptive=true);\n\nsol_1 = solve(prob, T=20.0, alg=alg);\n\nsol_1z = overapproximate(sol_1, Zonotope);\nnothing #hide","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"Verifying that the specifications hold:","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"# canonical direction along x₄\nconst e4 = [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0];\n\nρ(e4, sol_1z)","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"ρ(e4, sol_1z) < 4.5","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"To compute the width of the final box width of the final box we use support functions:","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"@show ρ(e4, sol_1z[end]) + ρ(-e4, sol_1z[end])","category":"page"},{"location":"models/LaubLoomis/#Case-2:-Intermediate-initial-states","page":"Laub-Loomis","title":"Case 2: Intermediate initial states","text":"","category":"section"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"In this case we consider the the width of the initial states is W = 005.","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"prob = laubloomis(W=0.05)\nalg = TMJets(abstol=1e-12, orderT=7, orderQ=1, adaptive=false);\n\nsol_2 = solve(prob, T=20.0, alg=alg)\nsol_2z = overapproximate(sol_2, Zonotope);\nnothing #hide","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"Verifying that the specification holds:","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"ρ(e4, sol_2z)","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"ρ(e4, sol_2z) < 4.5\n\n# width of final box\n@show ρ(e4, sol_2z[end]) + ρ(-e4, sol_2z[end])","category":"page"},{"location":"models/LaubLoomis/#Case-3:-Larger-initial-states","page":"Laub-Loomis","title":"Case 3: Larger initial states","text":"","category":"section"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"In this case we consider that the width of the initial states is W = 01.","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"prob = laubloomis(W=0.1)\nalg = TMJets(abstol=1e-12, orderT=7, orderQ=1, adaptive=false);\n\nsol_3 = solve(prob, T=20.0, alg=alg)\nsol_3z = overapproximate(sol_3, Zonotope);\nnothing #hide","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"Verifying that the specification holds:","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"ρ(e4, sol_3z)","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"ρ(e4, sol_3z) < 5.0\n\n# width of final box\n@show ρ(e4, sol_3z[end]) + ρ(-e4, sol_3z[end])\n\nusing Plots, Plots.PlotMeasures, LaTeXStrings\n\nfig = plot()\nplot!(fig, sol_3z, vars=(0, 4), linecolor=\"green\", color=:green, alpha=0.8)\nplot!(fig, sol_2z, vars=(0, 4), linecolor=\"blue\",  color=:blue, alpha=0.8)\nplot!(fig, sol_1z, vars=(0, 4), linecolor=\"yellow\", color=:yellow, alpha=0.8,\n      tickfont=font(10, \"Times\"), guidefontsize=15,\n      xlab=L\"t\",\n      ylab=L\"x_4\",\n      xtick=[0., 5., 10., 15., 20.], ytick=[1.5, 2., 2.5, 3., 3.5, 4., 4.5, 5.],\n      xlims=(0., 20.), ylims=(1.5, 5.02),\n      bottom_margin=6mm, left_margin=2mm, right_margin=4mm, top_margin=3mm,\n      size=(600, 600))\n\nplot!(fig, x->x, x->4.5, 0., 20., line=2, color=\"red\", linestyle=:dash, legend=nothing)\nplot!(fig, x->x, x->5., 0., 20., line=2, color=\"red\", linestyle=:dash, legend=nothing)","category":"page"},{"location":"models/LaubLoomis/#References","page":"Laub-Loomis","title":"References","text":"","category":"section"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"[LL98]: M. T. Laub and W. F. Loomis. A molecular network that produces spontaneous oscillations in excitable cells of dictyostelium. Molecular Biology of the Cell, 9:3521–3532, 1998.","category":"page"},{"location":"models/LaubLoomis/","page":"Laub-Loomis","title":"Laub-Loomis","text":"[TD13]: R. Testylier and T. Dang. NLTOOLBOX: A library for reachability computation of nonlinear dynamical systems. In Proc. of ATVA’13, volume 8172 of LNCS, pages 469–473. Springer, 2013.","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"LGG09","category":"page"},{"location":"lib/algorithms/LGG09/#ReachabilityAnalysis.LGG09","page":"LGG09","title":"ReachabilityAnalysis.LGG09","text":"LGG09{N, AM, TN<:AbstractDirections} <: AbstractContinuousPost\n\nImplementation of Girard - Le Guernic algorithm for reachability analysis using support functions.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\ntemplate     – (alias: dirs) struct that holds the directions (either lazily or concretely)                   for each support function evaluation defining the template\nvars         – (optional, default: all variables are computed) an integer or a vector of integers                   specifying the variables of interest to automatically construct a template                   using canonical directions; requires that n (or dim) is specified as well\nstatic       – (optional, default: false) if true, use statically sized arrays\nthreaded     – (optional, default: false) if true, use multi-threading                   to compute different template directions in parallel\nsparse       – (optional, default: false) if true, convert the matrix exponential                   obtained after discretization to a sparse matrix\ncache        – (optional, default: true) if true, use a cache for intermediate                   computations in the set recurrence loop\nvars         – (optional, default: missing) used to specify the variables instead                   of passing the template\n\nNotes\n\nThe type fields are:\n\nN        – number type of the step-size\nAM       – type of the approximation model\nTN       – type of the abstract directions that define the template\n\nThe flag threaded=true specifies that the support functions along different directions should be computed in parallel. See the section on Multi-threading for details on how to setup the number of threads.\n\nReferences\n\nThis is an implementation of the algorithm from [LGG09].\n\nThese methods are described at length in the dissertation [LG09].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/LGG09/#Method","page":"LGG09","title":"Method","text":"","category":"section"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"In the following subsections we outline the method of [LGG09] to solve linear set-based recurrences using support functions, first the homogeneous case and then the inhomogeneous case without wrapping effect. We also discuss the special case of real eigenvalues.","category":"page"},{"location":"lib/algorithms/LGG09/#Homogeneous-case","page":"LGG09","title":"Homogeneous case","text":"","category":"section"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"Consider the set-based recurrence","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"X_k+1 = Phi X_kqquad 0 leq k leq N","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"where Phi in mathbbR^ntimes n and X_0 subseteq mathbbR^n are given. By unrwapping the recurrence, X_k = Phi^k X_0 for all k geq 0. Let d in mathbbR^n be a given template direction. Using the property of support functions rho(d A X) = rho(A^T d X) for any matrix A and set X, we have that","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"ρ(d X_k) = rho(d Phi^k X_0) = rho((Phi^T)^k d X_0)","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"In this way we are able to reason with the sequence X_0 X_1 X_2 ldots X_N by evaluating the support function of the initial set X_0 along the directions d Phi^T d (Phi^T)^2 d ldots (Phi^T)^N d.","category":"page"},{"location":"lib/algorithms/LGG09/#Inhomogeneous-case","page":"LGG09","title":"Inhomogeneous case","text":"","category":"section"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"The inhomogeneous case generalizes the previous case by taking, at each step, the Minkowski sum with an element from the sequence V_0 V_1 V_2 ldots V_N:","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"X_k+1 = Phi X_k oplus V_kqquad 0 leq k leq N","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"Let us write such recurrence in the unrapped form,","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"beginaligned\nquad X_1 = Phi X_0 oplus V_0 1mm\nquad X_2 = Phi X_1 oplus V_1 = Phi^2 X_0 oplus Phi V_0 oplus V_1 1mm\nquad X_3 = Phi X_2 oplus V_2 = Phi^3 X_0 oplus Phi^2 V_0 oplus Phi V_1  oplus V_2 1mm\nquad vdots 1mm\nquad X_k = Phi^k X_0 oplus left( bigoplus_i=0^k-1 Phi^k-i-1 V_i right)\nendaligned","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"where the big Minkowski sum is just an abbreviation for Phi^k-1 V_0 oplus Phi^k-2 V_1 oplus Phi^k-3 V_2 oplus ldots oplus Phi V_k-2 oplus V_k-1.","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"Let d in mathbbR^n be a given template direction. Using the additive property of support functions, rho(d X oplus Y) = rho(d X) + rho(d Y) for any sets X and Y, we have that","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"beginaligned\nquad rho(d X_1) = rho(Phi^T d X_0) + rho(d V_0) 1mm\nquad rho(d X_2) = rho((Phi^T)^2 d X_0) + rho(Phi^T d V_0) + rho(d V_1) 1mm\nquad rho(d X_3) = rho((Phi^T)^3 d X_0) + rho((Phi^T)^2 d V_0) + rho(Phi^T d V_1) + rho(d V_2) 1mm\nquad vdots 1mm\nquad rho(d X_k) = rho((Phi^T)^k d X_0) + sum_i=0^k-1 rho( (Phi^T)^k-i-1 d  V_i)\nendaligned","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"In a similar fashion to the homogeneous case, the method allows to efficiently reason about the the sequence X_0 X_1 X_2 ldots X_N by evaluating the support function of the initial set X_0 and the input sets V_k_k along the directions d Phi^T d (Phi^T)^2 d ldots (Phi^T)^N d. Implementation-wise, we update two sequences, one that accounts for the homogeneous term, and another sequence that accounts for the effect of the accumulated inputs.","category":"page"},{"location":"lib/algorithms/LGG09/#Implementation-details","page":"LGG09","title":"Implementation details","text":"","category":"section"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"The reach-set representation used is a TemplateReachSet, which stores the directions used (vector of vectors) and the support function evaluated at each direction (matrix, see below). The set representation, set(R::TemplateReachSet), is either a polyhedron in constraint form (HPolyhedron), or a polytope (HPolytope) if the directions are bounding, i.e. the template directions define a bounded set.","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"The computed support function values can accessed directly through the field sf::SN of each template reach-set. Here sf is an array view of type ::Matrix{N}(undef, length(dirs), NSTEPS): each row corresponds to one of the template directions and each column corresponds to a fixed iteration index k geq 0.","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"If you use directions from the canonical basis of mathbbR^n, it is recommended to define LazySets.Arrays.SingleEntryVector or \"one-hot\" arrays as they are commonly called, because there are methods that dispatch on such type of arrays efficiently.","category":"page"},{"location":"lib/algorithms/LGG09/#Parallel-formulation","page":"LGG09","title":"Parallel formulation","text":"","category":"section"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"The support functions of the sequence X_k_k along different directions can be computed in parallel. Indeed, if d_1 and d_2 are two given template directions, two different processes can independently compute rho(d_1 X_k) and rho(d_2 X_k) for all k = 0 1 ldots N using the methods described above. Once both computations have finished, we can store the resulting support functions in the same array. Use the flag threaded=true to use this method.","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"Implementation-wise the function _reach_homog_dir_LGG09! spawns differen threads which populate the matrix ρℓ::Matrix{N}(undef, length(dirs), NSTEPS) with the computed values. Hence each thread computes a subset of distinct rows of ρℓ.","category":"page"},{"location":"lib/algorithms/LGG09/#Real-eigenvalues","page":"LGG09","title":"Real eigenvalues","text":"","category":"section"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"If the spectrum of the state matrix only has real eigenvalues, the sequence of support functions can be computed efficiently if we work with a template consisting of eigenvectors of Phi^T. This idea is described in [LGG09] and we recall it here for convenience.","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"The method stems from the fact that if (lambda d) is an eigenvalue-eigenvector pair of the matrix Phi^T, with lambda in mathbbR, then Phi^T d = lambda d, and if we apply Phi^T on both sides of this identity, we get (Phi^T)^2 d = Phi^T (Phi^T d) = Phi^T(lambda d) = lambda^2 d. In more generality, it holds that (Phi^T)^k d  = lambda^k d for all k ge 1. Applying this relation to the support function recurrence described above, we get for the general inhomogeneous and possibly time-varying inputs case:","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"rho(d X_k) = rho(lambda^k d X_0) + sum_i=0^k-1 rho(lambda^k-i-1 d V_i)","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"To further simplify this formula, we analyze different cases of lambda. If lambda = 0, then rho(d X_k) = rho(d V_k) for all k geq 1, so we focus on either lambda being positive or negative. To further simplify the computation of rho(d X_k), we can use the property rho(lambda d X) = lambda rho(d X) if lambda geq 0. We now consider the cases lambda  0 and lambda  0.","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"Case lambda  0. Then lambda^k  0 for all k geq 1, and","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"rho(d X_k) = lambda^k rho(d X_0) +  sum_i=0^k-1 lambda^k-i-1 rho(d V_i)","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"We are left with evaluating the support function only at rho(d X_0)  and rho(d V_i) to construct the full sequence rho(d X_k)_k. Moreover, if the V_i's are constant we can extract them from the right-hand side sum and use that","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"sum_i=0^k-1 lambda^k-i-1 = 1 + lambda + ldots + lambda^k-1 = dfrac1 - lambda^k1 - lambda","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"Case lambda  0. Since lambda^k = (-1)^k (-lambda)^k and lambda  0, then lambda^k is positive if k is even, otherwise it is negative. So we can write:","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"rho(d X_k) = (-lambda)^k rho((-1)^k d X_0) + sum_i=0^k-1 (-lambda)^k-i-1 rho((-1)^k-i-1 d V_i)","category":"page"},{"location":"lib/algorithms/LGG09/","page":"LGG09","title":"LGG09","text":"The main difference between this case and the previus one is that now we have to evaluate support functions rho(pm d X_0) and rho(pm d V_i). Again, simplification takes place if the V_i's are constant and such special case is considered in the implementation.","category":"page"},{"location":"lib/reachsets/","page":"Reach-sets","title":"Reach-sets","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/reachsets/#Reach-sets","page":"Reach-sets","title":"Reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#Abstract-interface","page":"Reach-sets","title":"Abstract interface","text":"","category":"section"},{"location":"lib/reachsets/","page":"Reach-sets","title":"Reach-sets","text":"AbstractReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractReachSet","text":"AbstractReachSet{N}\n\nAbstract type for all reach-sets types.\n\nNotes\n\nA reach-set is a set representation X associated to a given time span Δt.\n\nIn its simplest form, we represent reach-sets with a struct that wraps the tuple (X, Δt), where X corresponds to a geometric set, eg. a polytope, and Δt is the interval with the time span associated to this reach-set.\n\nThis type is parametric in N. The parameter N represents for the type of numerical coefficient used in the representation (typically, N = Float64).\n\nAlthough concrete subtypes of AbstractReachSet may represent the set X in different ways, or carry additional information as an extra type field, they should all implement the AbstractReachSet interface to enable shared functionality for reach-set types. In particular, each concrete subtype should implement the following methods:\n\nset    – return the geometric set\nsetrep – return the type of the set representation\ntspan  – return the time interval span\ntstart – return the initial time\ntend   – return the final time\ndim    – return ambient dimension of the reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/","page":"Reach-sets","title":"Reach-sets","text":"The functions are available at the interface level.","category":"page"},{"location":"lib/reachsets/","page":"Reach-sets","title":"Reach-sets","text":"basetype(::Type{<:AbstractReachSet})\nset(::AbstractReachSet)\nsetrep(::AbstractReachSet)\ntspan(::AbstractReachSet)\ntstart(::AbstractReachSet)\ntend(::AbstractReachSet)\ndim(::AbstractReachSet)\ncopy(::AbstractReachSet)\nshift(::AbstractReachSet)","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.basetype-Tuple{Type{var\"#s217\"} where var\"#s217\"<:ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.basetype","text":"basetype(T::Type{<:AbstractReachSet})\n\nReturn the base type of the given reach-set type (i.e., without type parameters).\n\nInput\n\nT – reach-set type, used for dispatch\n\nOutput\n\nThe base type of T.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#LazySets.set-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"LazySets.set","text":"set(R::AbstractReachSet)\n\nReturn the geometric set represented by this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe set wrapped by the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.setrep-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.setrep","text":"setrep(R::AbstractReachSet)\n\nReturn the type of the set representation of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nType of the set representation of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tspan-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tspan","text":"tspan(R::AbstractReachSet)\n\nReturn time span of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe interval representing the time span of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tstart-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tstart","text":"tstart(R::AbstractReachSet)\n\nReturn the initial time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the initial time of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tend-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tend","text":"tend(R::AbstractReachSet)\n\nReturn the final time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the final time of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#LazySets.dim-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"LazySets.dim","text":"dim(R::AbstractReachSet)\n\nReturn the ambient dimension of the reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nAn integer corresponding to the ambient dimension of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#Base.copy-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"Base.copy","text":"copy(R::AbstractReachSet)\n\nReturn a copy of the given reach-set.\n\nInput\n\nR  – reach-set\n\nOutput\n\nA new reach-set of the sam type and the same field values as R.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.shift-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.shift","text":"shift(fp::Flowpipe{N, <:AbstractReachSet}, t0::Number) where {N}\n\nReturn the time-shifted flowpipe by the given number.\n\nInput\n\nfp – flowpipe\nt0 – time shift\n\nOutput\n\nA new flowpipe such that the time-span of each constituent reach-set has been shifted by t0.\n\nNotes\n\nSee also Shift for the lazy counterpart.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/","page":"Reach-sets","title":"Reach-sets","text":"AbstractLazyReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractLazyReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractLazyReachSet","text":"AbstractLazyReachSet{N} <: AbstractReachSet{N}\n\nAbstract type for all reach-set types that use a LazySet for the underlying set representation.\n\nNotes\n\nAn AbstractLazyReachSet is the interface for reach-sets such that the geometric set is represented by any subtype of LazySet.\n\nThis types implements the LazySets interface, namely support function (ρ), support vector (σ) and ambient dimension (dim) functions. Hence, these functions directly apply to concrete subtypes of an AbstractLazyReachSet. The set wrapped by this type is obtained through set(R).\n\nThe following functions should be implemented by any concrete subtype:\n\nreconstruct – create a new instance of the given reach-set with a different                  set representation but sharing the other fields, i.e. the same                  time span (and the same for other fields, if applicable)\n\nIn addition to the functions inherited from AbstractReachSet, the following are available:\n\nlinear_map  – concrete linear map of a reach-set\nproject     – projection of a reach-set\nshift       – time-shift of a reach-set\nvars        – tuple of integers associated to the variables of the given reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Reachable-set","page":"Reach-sets","title":"Reachable set","text":"","category":"section"},{"location":"lib/reachsets/","page":"Reach-sets","title":"Reach-sets","text":"ReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.ReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.ReachSet","text":"ReachSet{N, ST<:LazySet{N}} <: AbstractLazyReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation.\n\nFields\n\nX  – set\nΔt – time interval\n\nNotes\n\nA ReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype LazySet. For efficiency reasons, ST should be concretely typed.\n\nBy assumption the coordinates in this reach-set are associated to the integers 1, …, n. The function vars returns such tuple.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Sparse-reachable-set","page":"Reach-sets","title":"Sparse reachable set","text":"","category":"section"},{"location":"lib/reachsets/","page":"Reach-sets","title":"Reach-sets","text":"SparseReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.SparseReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.SparseReachSet","text":"SparseReachSet{N, ST<:LazySet{N}, D} <: AbstractReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation, together with a tuple of variables associated to this reach-set.\n\nFields\n\nX        – set\nΔt       – time interval\nvars – tuple of variable indices represented by the set X\n\nNotes\n\nA SparseReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype of LazySet (ideally, concrete). Moreover, this type also stores information about the variables (also named coordinates, or by abuse of notation, dimensions) corresponding to the set X.\n\nFor instance in the ambient space n=5, one may have a SparseReachSet whose variables tuple is vars = (4, 5, 6), i.e. representing a three-dimensional projection of the full-dimensional reach-set. In consequence, the dimension of X doesn't match the length of vars, in general\n\nIn this type, the parameter N represents the numerical type of the LazySet (typically, Float64), the type ST represents the set representation used, and D denotes the dimension of this sparse reach set. Note that, in contrast to ReachSet, for SparseReachSet the number of dimensions is part of the type information.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Taylor-model-reach-sets","page":"Reach-sets","title":"Taylor model reach-sets","text":"","category":"section"},{"location":"lib/reachsets/","page":"Reach-sets","title":"Reach-sets","text":"AbstractTaylorModelReachSet\nTaylorModelReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractTaylorModelReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractTaylorModelReachSet","text":"AbstractTaylorModelReachSet{N}\n\nAbstract type for all reach sets types that represent a Taylor model.\n\nNotes\n\nThe parameter N refers to the numerical type of the representation.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#ReachabilityAnalysis.TaylorModelReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.TaylorModelReachSet","text":"TaylorModelReachSet{N} <: AbstractTaylorModelReachSet{N}\n\nReach-set representation consisting of a vector of taylor models in one variable (the \"time\" variable) whose coefficients are multivariate polynomials (the \"space\" variables).\n\nNotes\n\nThe parameter N refers to the numerical type of the representation. The space variables are assumed to be normalized to the interval [-1, 1]. It is assumed that the time domain is the same for all components.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Template-reach-sets","page":"Reach-sets","title":"Template reach-sets","text":"","category":"section"},{"location":"lib/reachsets/","page":"Reach-sets","title":"Reach-sets","text":"TemplateReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.TemplateReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.TemplateReachSet","text":"TemplateReachSet{N, VN, TN<:AbstractDirections{N, VN}, SN<:AbstractVector{N}} <: AbstractLazyReachSet{N}\n\nReach set that stores the support function of a set at a give set of directions.\n\nNotes\n\nThe struct has the following parameters:\n\nN  – refers to the numerical type of the representation.\nVN – refers to the vector type of the template\nTN – refers to the template type\nSN – vector type that holds the support function evaluations\n\nConcrete subtypes of AbstractDirections are defined in the LazySets library.\n\nThis reach-set implicitly represents a set by a set of directions and support functions. set(R::TemplateReachSet) returns a polyhedron in half-space representation.\n\nApart from the getter functions inherited from the AbstractReachSet interface, the following methods are available:\n\ndirections(R)           – return the set of directions normal to the faces of this reach-set\nsupport_functions(R)    – return the vector of support function evaluations\nsupport_functions(R, i) – return the i-th coordinate of the vector of support function evaluatons\n\n\n\n\n\n","category":"type"},{"location":"lib/distributed/","page":"Distributed computations","title":"Distributed computations","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/distributed/#Distributed-computations","page":"Distributed computations","title":"Distributed computations","text":"","category":"section"},{"location":"lib/distributed/","page":"Distributed computations","title":"Distributed computations","text":"This section of the manual gives additional pointers on making use of distributed computation within the library.","category":"page"},{"location":"lib/distributed/","page":"Distributed computations","title":"Distributed computations","text":"Pages = [\"distributed.md\"]\nDepth = 3","category":"page"},{"location":"lib/distributed/#Multi-threading","page":"Distributed computations","title":"Multi-threading","text":"","category":"section"},{"location":"lib/distributed/","page":"Distributed computations","title":"Distributed computations","text":"Since version 1.3, Julia has built-in multi-threaded parallelism and we have applied such feature at different levels in the library:","category":"page"},{"location":"lib/distributed/","page":"Distributed computations","title":"Distributed computations","text":"Multi-threaded implementations of reachability algorithms. This approach relies on the particular structure of each algorithm and hence it doesn't generalize to different algorithms. An example is the exploration of template directions in simultaneous with LGG09. Details are included in the documentation page of each algorithm.\nParallel solve, with split initial conditions. This approach applies to all algorithms, because we can always split an initial domain into smaller subdomains, and run solve on each of these regions in parallel. See Parallel solve below for details.","category":"page"},{"location":"lib/distributed/","page":"Distributed computations","title":"Distributed computations","text":"Julia's documentation on multi-threading describes how to check the number of threads available in the current session, Threads.nthreads(), and how to control the number of threads e.g. by starting Julia with $ julia --threads 4 to use four threads. Please note that to make the number of threads persistent across different Julia sessions you should export an environment variable, export JULIA_NUM_THREADS=4 to be added in your .bashrc or .bash_profile files, or setting ENV[\"JULIA_NUM_THREADS\"]=4 in your .julia/config/startup.jl file.","category":"page"},{"location":"lib/distributed/#GPGPU-computing","page":"Distributed computations","title":"GPGPU computing","text":"","category":"section"},{"location":"lib/distributed/","page":"Distributed computations","title":"Distributed computations","text":"The recommended entry point for using general-purpose graphical processing units (GPGPU) in Julia is the library CUDA.jl. The package exports an array type CuArray used as an abstraction to perform array operations on the GPU device; common linear algebra operations are readily available through dispatch on CuArray. Apart from convenient high-level syntax to do basic linear algebra on GPUs; more advanced kernel functions can be implemented as well as it is explained in the CUDA.jl documentation.","category":"page"},{"location":"lib/distributed/#Parallel-solve","page":"Distributed computations","title":"Parallel solve","text":"","category":"section"},{"location":"lib/distributed/","page":"Distributed computations","title":"Distributed computations","text":"Reachability computations can be computed in parallel using Julia's built-in multithreaded parallelism. This feature is available formulating and solving an initial-value problem with an array of initial conditions.","category":"page"},{"location":"lib/distributed/#About-BLAS-threads","page":"Distributed computations","title":"About BLAS threads","text":"","category":"section"},{"location":"lib/distributed/","page":"Distributed computations","title":"Distributed computations","text":"To control the number of threads used by your BLAS library, use the function Base.LinAlg.BLAS.set_num_threads(n), where n is an integer. Furthermore, the function get_num_threads() defined below will return the current value.","category":"page"},{"location":"lib/distributed/","page":"Distributed computations","title":"Distributed computations","text":"Note. If you are using Julia v\"0.7-\" (run the command VERSION to find this), instead of Base.LinAlg below use LinearAlgebra, and this module should have been loaded in the current scope with using LinearAlgebra.","category":"page"},{"location":"lib/distributed/","page":"Distributed computations","title":"Distributed computations","text":"#\n# This function is a part of Julia. License is MIT: https://julialang.org/license\n#\nfunction get_num_threads() # anonymous so it will be serialized when called\n    blas = Base.LinAlg.BLAS.vendor()\n    # Wrap in a try to catch unsupported blas versions\n    try\n        if blas == :openblas\n            return ccall((:openblas_get_num_threads, Base.libblas_name), Cint, ())\n        elseif blas == :openblas64\n            return ccall((:openblas_get_num_threads64_, Base.libblas_name), Cint, ())\n        elseif blas == :mkl\n            return ccall((:MKL_Get_Max_Num_Threads, Base.libblas_name), Cint, ())\n        end\n\n        # OSX BLAS looks at an environment variable\n        if Sys.isapple()\n            return ENV[\"VECLIB_MAXIMUM_THREADS\"]\n        end\n    end\n\n    return nothing\nend","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/Spacecraft/Spacecraft.jl\"","category":"page"},{"location":"models/Spacecraft/#Spacecraft","page":"Spacecraft","title":"Spacecraft","text":"","category":"section"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"(Image: )","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"note: Overview\nSystem type: hybrid system with nonlinear dynamics\nState dimension: 4 + 1\nApplication domain: Flight Dynamics, Switched Controllers","category":"page"},{"location":"models/Spacecraft/#Model-description","page":"Spacecraft","title":"Model description","text":"","category":"section"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"Spacecraft rendezvous is a perfect use case for formal veriﬁcation of hybrid systems with nonlinear dynamics since mission failure can cost lives and is extremely expensive. This benchmark is taken from [1].","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"The nonlinear dynamic equations describe the two-dimensional, planar motion of the space-craft on an orbital plane towards a space station:","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"  left beginarraylcl\n  dotx  =  v_x \n  doty  =  v_y \n  dotv_x  =  n^2x + 2nv_y + fracmur^2 - fracmur^3 (r +x) + fracu_xm_c \n  dotv_y  =  n^2y - 2nv_x - fracmur^3_cy + fracu_ym_c\n  endarray right","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"The model consists of position (relative to the target) x, y [m], time t [min], as well as horizontal and vertical velocity v_x, v_y [m / min]. The parameters are µ = 3986  10^14  60^2 [m^3  min^2], r = 42164  10^3 m m_c = 500 kg n = sqrtfracmur^3 and r_c = sqrt(r + x)^2 + y^2.","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"The hybrid nature of this benchmark originates from a switched controller. In particular, the modes are approaching (x  1000 100 m), rendezvous attempt (x  100 m), and aborting. A transition to mode aborting occurs nondeterministically at t  120 150 min.","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"The linear feedback controllers for the diﬀerent modes are deﬁned as binomu_xu_y = K_1underlinex for mode approaching, and binomu_xu_y = K_2underlinex for mode rendezvous attempt, where underlinex = (x y v_x v_y)^T is the vector of system states. The feedback matrices K_i were determined with an LQR-approach applied to the linearized system dynamics, which resulted in the following numerical values:","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"K_1 =\nbeginpmatrix\n288287  01005  14499754  00046 \n0087  332562  000462  14515013\nendpmatrix","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"K_2 =\nbeginpmatrix\n2880288  01312  96149898  0 \n01312  288  0  96149883\nendpmatrix","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"In the mode aborting, the system is uncontrolled binomu_xu_y = binom00.","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"using ReachabilityAnalysis\n\nconst μ = 3.986e14 * 60^2\nconst r = 42164.0e3\nconst r² = r^2\nconst mc = 500.0\nconst n² = μ / r^3\nconst n = sqrt(n²)\n\nconst two_n = 2*n\nconst μ_r² = μ/r²;\nnothing #hide","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"const K₁ = [-28.8287 0.1005 -1449.9754 0.0046 0.0;\n            -0.087 -33.2562 0.00462 -1451.5013 0.0]\nconst K₂ = [-288.0288 0.1312 -9614.9898 0.0 0.0;\n            -0.1312 -288.0 0.0 -9614.9883   0.0]\n\nconst K₁mc = K₁/mc\nconst K₂mc = K₂/mc\n\nfunction mymul!(v, A, x)\n    @inbounds for ind = 1:length(v)\n        v[ind] = zero(x[1])\n        for jind = 1:length(x)\n            v[ind] += A[ind, jind] * x[jind]\n        end\n    end\n    return nothing\nend","category":"page"},{"location":"models/Spacecraft/#Dynamics-in-the-'approaching'-mode","page":"Spacecraft","title":"Dynamics in the 'approaching' mode","text":"","category":"section"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"@taylorize function spacecraft_approaching!(du, u, p, t)\n    x, y, vx, vy, t = u\n\n    rx = r + x\n    rx² = rx^2\n    y² = y^2\n    rc = sqrt(rx² + y²)\n    rc³ = rc^3\n    μ_rc³ = μ / rc³\n\n    uxy = Vector{typeof(x)}(undef, 2)\n    mymul!(uxy, K₁mc, u)\n\n    # x' = vx\n    du[1] = vx\n\n    # y' = vy\n    du[2] = vy\n\n    # vx' = n²x + 2n*vy + μ/(r^2) - μ/(rc^3)*(r+x) + ux/mc\n    du[3] = (n²*x + two_n*vy) + ((μ_r² - μ_rc³*rx) + uxy[1])\n\n    # vy' = n²y - 2n*vx - μ/(rc^3)y + uy/mc\n    du[4] = (n²*y - two_n*vx) - (μ_rc³*y - uxy[2])\n\n    # t' = 1\n    du[5] = one(x)\n\n    return du\nend","category":"page"},{"location":"models/Spacecraft/#Dynamics-in-the-'rendezvous-attempt'-mode","page":"Spacecraft","title":"Dynamics in the 'rendezvous attempt' mode","text":"","category":"section"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"@taylorize function spacecraft_attempt!(du, u, p, t)\n    x, y, vx, vy, t = u\n\n    rx = r + x\n    rx² = rx^2\n    y² = y^2\n    rc = sqrt(rx² + y²)\n    rc³ = rc^3\n    μ_rc³ = μ / rc³\n\n    uxy = Vector{typeof(x)}(undef, 2)\n    mymul!(uxy, K₂mc, u)\n\n    # x' = vx\n    du[1] = vx\n\n    # y' = vy\n    du[2] = vy\n\n    # vx' = n²x + 2n*vy + μ/(r^2) - μ/(rc^3)*(r+x) + ux/mc\n    du[3] = (n²*x + two_n*vy) + ((μ_r² - μ_rc³*rx) + uxy[1])\n\n    # vy' = n²y - 2n*vx - μ/(rc^3)y + uy/mc\n    du[4] = (n²*y - two_n*vx) - (μ_rc³*y - uxy[2])\n\n    # t' = 1\n    du[5] = one(x)\n\n    return du\nend","category":"page"},{"location":"models/Spacecraft/#Dynamics-in-the-'aborting'-mode","page":"Spacecraft","title":"Dynamics in the 'aborting' mode","text":"","category":"section"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"@taylorize function spacecraft_aborting!(du, u, p, t)\n    x, y, vx, vy, t = u\n\n    rx = r + x\n    rx² = rx^2\n    y² = y^2\n    rc = sqrt(rx² + y²)\n    rc³ = rc^3\n    μ_rc³ = μ / rc³\n\n    # x' = vx\n    du[1] = vx\n\n    # y' = vy\n    du[2] = vy\n\n    # vx' = n²x + 2n*vy + μ/(r^2) - μ/(rc^3)*(r+x)\n    du[3] = (n²*x + two_n*vy) + (μ_r² - μ_rc³*rx)\n\n    # vy' = n²y - 2n*vx - μ/(rc^3)y\n    du[4] = (n²*y - two_n*vx) - μ_rc³*y\n\n    # t' = 1\n    du[5] = one(x)\n\n    return du\nend","category":"page"},{"location":"models/Spacecraft/#Hybrid-System-setup","page":"Spacecraft","title":"Hybrid System setup","text":"","category":"section"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"To model the system as a hybrid automaton, it is useful to work with symbolic state variables.","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"using Symbolics\n\nconst var = @variables x y vx vy t\n\nfunction spacecraft(; abort_time=(120.0, 150.0))\n\n    n = 4 + 1  # number of variables\n    t_abort_lower, t_abort_upper = abort_time\n\n    automaton = LightAutomaton(3)\n\n    # mode 1 \"approaching\"\n    invariant = HalfSpace(x <= -100, var)\n    approaching = @system(x' = spacecraft_approaching!(x), dim:5, x ∈ invariant)\n\n    # mode 2 \"rendezvous attempt\"\n    invariant = HalfSpace(x >= -100, var)\n    attempt = @system(x' = spacecraft_attempt!(x), dim:5, x ∈ invariant)\n\n    # mode 3 \"aborting\"\n    invariant = Universe(n)\n    aborting = @system(x' = spacecraft_aborting!(x), dim: 5, x ∈ invariant)\n\n    # transition \"approach\" -> \"attempt\"\n    add_transition!(automaton, 1, 2, 1)\n    guard = HalfSpace(x >= -100, var)\n    t1 = @map(x -> x, dim: n, x ∈ guard)\n\n    # transition \"approach\" -> \"abort\"\n    add_transition!(automaton, 1, 3, 2)\n    guard_time = HPolyhedron([t >= t_abort_lower, t <= t_abort_upper], var)\n    t2 = @map(x -> x, dim: n, x ∈ guard_time)\n\n    # transition \"attempt\" -> \"abort\"\n    add_transition!(automaton, 2, 3, 3)\n    t3 = @map(x -> x, dim: n, x ∈ guard_time)\n\n    H = HybridSystem(automaton=automaton,\n                     modes=[approaching, attempt, aborting],\n                     resetmaps=[t1, t2, t3])\n\n     # initial condition in mode 1\n     X0 = Hyperrectangle([-900., -400., 0., 0., 0.], [25., 25., 0., 0., 0.])\n     init = [(1, X0)]\n\n     return InitialValueProblem(H, init)\nend","category":"page"},{"location":"models/Spacecraft/#Reachability-settings","page":"Spacecraft","title":"Reachability settings","text":"","category":"section"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"The spacecraft starts from the initial set x  925 875 m, y  425 375 m vx = 0 mmin and vy = 0 mmin. For the considered time horizon of t  0 200 min, the following speciﬁcations have to be satisﬁed:","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"Line-of-sight: In mode rendezvous attempt, the spacecraft has to stay    inside line-of-sight cone L = binomxy  (x  100)  (y  x tan(30))  (y  x tan(30)).\nCollision avoidance: In mode aborting, the spacecraft has to avoid a    collision with the target, which is modeled as a box B with 02m    edge length and the center placed at the origin.\nVelocity constraint: In mode rendezvous attempt, the absolute velocity    has to stay below 33 mmin: sqrtv^2_x + v^2_y  33 mmin.","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"note: Remark on velocity constraint\nIn the original benchmark [1], the constraint on the velocity was set to 0.05 m/s, but it can be shown (by a counterexample) that this constraint cannot be satisﬁed. We therefore use the relaxed constraint 0055 ms = 33 mmin.","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"const tan30 = tand(30)\n\nLineOfSightCone = HPolyhedron([x >= -100, y >= x*tan30, -y >= x*tan30], var)\n\nTarget = Hyperrectangle(zeros(2), [0.2, 0.2]);\nnothing #hide","category":"page"},{"location":"models/Spacecraft/#Auxiliary-functions","page":"Spacecraft","title":"Auxiliary functions","text":"","category":"section"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"function line_of_sight(sol)\n    all_idx = findall(x -> x == 2, location.(sol))  # attempt\n    for idx in all_idx\n        verif = all(set(R) ⊆ LineOfSightCone for R in sol[idx][2:end])\n        !verif && return false\n    end\n    return true\nend\n\nfunction absolute_velocity(R)\n    vx, vy = 3, 4\n    vx2 = set(overapproximate(project(R, vars=(vx,)), Interval))\n    vy2 = set(overapproximate(project(R, vars=(vy,)), Interval))\n    return sqrt(vx2.dat + vy2.dat)\nend\n\nfunction velocity_constraint(sol)\n    all_idx = findall(x -> x == 2, location.(sol)) # attempt mode\n    for idx in all_idx\n        # maximum velocity measured in m/min\n        verif = all(absolute_velocity(R) < 0.055 * 60. for R in sol[idx])\n        !verif && return false\n    end\n    return true\nend\n\nfunction target_avoidance(sol)\n    all_idx = findall(x -> x == 3, location.(sol)) # aborting mode\n    for idx in all_idx\n        verif = all(is_intersection_empty(set(Projection(R, [x, y])), Target) for R in sol[idx])\n        !verif && return false\n    end\n    return true\nend","category":"page"},{"location":"models/Spacecraft/#Results","page":"Spacecraft","title":"Results","text":"","category":"section"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"We used n_Q = 1 and n_T = 5. The transition to the aborting mode is handled by clustering the flowpipe into 29 boxes.","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"using Plots\n\nfunction solve_spacecraft(prob; k=25, s=missing)\n\n    # template directions\n    boxdirs = BoxDirections(5)\n\n    # transition from mode 1 to mode 2\n    sol12 = solve(prob,\n                tspan=(0.0, 200.0),\n                alg=TMJets20(abstol=1e-5, maxsteps=10_000, orderT=5, orderQ=1, disjointness=BoxEnclosure()),\n                max_jumps=1,\n                intersect_source_invariant=false,\n                intersection_method=TemplateHullIntersection(boxdirs),\n                clustering_method=LazyClustering(1),\n                disjointness_method=BoxEnclosure())\n\n    sol12jump = overapproximate(sol12[2](120 .. 150), Zonotope)\n    t0 = tstart(sol12jump[1])\n    sol12jump_c = cluster(sol12jump, 1:length(sol12jump), BoxClustering(k, s))\n\n    # transition from mode 2 to mode 3\n    H = system(prob)\n    sol3 = solve(IVP(mode(H, 3), [set(X) for X in sol12jump_c]),\n                 tspan=(t0, 200.0),\n                 alg=TMJets20(abstol=1e-10, orderT=7, orderQ=1, disjointness=BoxEnclosure()))\n    d = Dict{Symbol, Any}(:loc_id => 3)\n\n    F12 = [fp for fp in sol12.F]\n    F23 = [Flowpipe(fp.Xk, d) for fp in sol3.F]\n    return HybridFlowpipe(vcat(F12, F23))\nend\n\nprob = spacecraft()\nsol = solve_spacecraft(prob; k=25, s=missing)\nsolz = overapproximate(sol, Zonotope);\nnothing #hide","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"plot(solz, vars=(1, 2), xlab=\"x\", ylab=\"y\")","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"Note that in the previous plot, it is not specified which reach-set corresponds to which mode. After finding the location (mode of the hybrid system) associated to each reach-set of the solution, we can plot each one using different colors. The plotting code is more sophisticated than before, but is an example of finer control of the options used to plot the flowpipes.","category":"page"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"idx_approaching = findall(x -> x == 1, location.(solz))\nidx_attempt = findall(x -> x == 2, location.(solz))\nidx_aborting = findall(x -> x == 3, location.(solz))\n\nusing Plots, Plots.PlotMeasures, LaTeXStrings\n\nfig = plot(legend=:bottomright, tickfont=font(10, \"Times\"), guidefontsize=15,\n           xlab=L\"x\", ylab=L\"y\", lw=0.0,\n           xtick=[-750, -500, -250, 0, 250.], ytick=[-400, -300, -200, -100, 0.],\n           xlims=(-1000.0, 400.0), ylims=(-450.0, 0.0), size=(600, 600),\n           bottom_margin=6mm, left_margin=2mm, right_margin=4mm, top_margin=3mm)\n\nplot!(fig, solz[idx_approaching[1]], vars=(1, 2), lw=0.0, color=:lightgreen, alpha=1., lab=\"Approaching\")\nfor k in 2:length(idx_approaching)\n    plot!(fig, solz[idx_approaching[k]], vars=(1, 2), lw=0.0, color=:lightgreen, alpha=1.)\nend\n\nplot!(fig, solz[idx_attempt[1]], vars=(1, 2), lw=0.0, color=:red, alpha=1., lab=\"Attempt\")\nfor k in 2:length(idx_attempt)\n    plot!(fig, solz[idx_attempt[k]], vars=(1, 2), lw=0.0, color=:red, alpha=1.)\nend\n\nplot!(fig, solz[idx_aborting[1]], vars=(1, 2), lw=0.0, color=:cyan, alpha=1., lab=\"Aborting\")\nfor k in 2:length(idx_aborting)\n    plot!(fig, solz[idx_aborting[k]], vars=(1, 2), lw=0.0, color=:cyan, alpha=1.)\nend\n\nfig","category":"page"},{"location":"models/Spacecraft/#References","page":"Spacecraft","title":"References","text":"","category":"section"},{"location":"models/Spacecraft/","page":"Spacecraft","title":"Spacecraft","text":"[1] N. Chan and S. Mitra. Verifying safety of an autonomous spacecraft rendezvous mission. In ARCH17. 4th International Workshop on Applied Veriﬁcation of Continuous and Hybrid Systems, collocated with Cyber-Physical Systems Week (CPSWeek) on April 17, 2017 in Pittsburgh, PA, USA, pages 20–32, 2017.","category":"page"},{"location":"man/structure/","page":"Exploiting structure","title":"Exploiting structure","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"man/structure/#Exploiting-structure","page":"Exploiting structure","title":"Exploiting structure","text":"","category":"section"},{"location":"man/structure/","page":"Exploiting structure","title":"Exploiting structure","text":"In this section we explore different techniques that in one way or another exploit the structure of the initial-value problem, or the type of verification that we want to perform on the outputs.","category":"page"},{"location":"man/structure/#On-the-fly-property-checking","page":"Exploiting structure","title":"On-the-fly property checking","text":"","category":"section"},{"location":"man/structure/","page":"Exploiting structure","title":"Exploiting structure","text":"In this section we consider reachability analysis for subsets of variables","category":"page"},{"location":"man/structure/","page":"Exploiting structure","title":"Exploiting structure","text":"of a given linear system.","category":"page"},{"location":"man/structure/","page":"Exploiting structure","title":"Exploiting structure","text":"Method to lazily compute the flowpipe when we are only interested in outputs.\nExample with linear combination of state varibles with LGG09 (eg. some of SLICOT benchmaris properties).","category":"page"},{"location":"man/structure/#State-space-decomposition","page":"Exploiting structure","title":"State-space decomposition","text":"","category":"section"},{"location":"man/structure/","page":"Exploiting structure","title":"Exploiting structure","text":"A section about BFFPSV18.","category":"page"},{"location":"man/structure/","page":"Exploiting structure","title":"Exploiting structure","text":"(Image: Cartesian decomposition)","category":"page"},{"location":"man/structure/#Sparse-systems","page":"Exploiting structure","title":"Sparse systems","text":"","category":"section"},{"location":"man/structure/","page":"Exploiting structure","title":"Exploiting structure","text":"Show option when Phi is sparse.","category":"page"},{"location":"man/structure/#Krylov-subspace-iterations","page":"Exploiting structure","title":"Krylov subspace iterations","text":"","category":"section"},{"location":"man/structure/","page":"Exploiting structure","title":"Exploiting structure","text":"Show case using Krylov when the state matrix is sparse.","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/EMBrake/EMBrake.jl\"","category":"page"},{"location":"models/EMBrake/#Electromechanic-break","page":"Electromechanic break","title":"Electromechanic break","text":"","category":"section"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"(Image: )","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"note: Overview\nSystem type: Affine system\nState dimension: 48\nApplication domain: Mechanical Engineering","category":"page"},{"location":"models/EMBrake/#Model-description","page":"Electromechanic break","title":"Model description","text":"","category":"section"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"The system is described by the linear differential equations:","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"  beginarraylcl\n  dotx(t) = Ax(t) + Bu(t)qquad u(t) in mathcalU \n  y(t) = C x(t)\n  endarray","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"There are two versions of this benchmark:","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"(time-varying inputs): The inputs can change arbitrarily over time: forall t u(t)in mathcalU.\n(constant inputs): The inputs are uncertain only in their initial value, and  constant over time: u(0)in mathcalU, dot u (t)= 0.","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"using ReachabilityAnalysis, SparseArrays, JLD2","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"adapt default LazySets tolerances","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"set_rtol(Float64, 1e-12)\nset_ztol(Float64, 1e-13)\n\n# Fixed parameters","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"The model without parameter variation is defined below.","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"function embrake_no_pv(; Tsample=1.E-4, ζ=1e-6, x0=0.05)\n    # model's constants\n    L = 1.e-3\n    KP = 10000.\n    KI = 1000.\n    R = 0.5\n    K = 0.02\n    drot = 0.1\n    i = 113.1167\n\n    # state variables: [I, x, xe, xc]\n    A = Matrix([-(R+K^2/drot)/L 0      KP/L  KI/L;\n                          K/i/drot      0      0      0;\n                          0             0      0      0;\n                          0             0      0      0])\n\n    EMbrake = @system(x' = Ax)\n\n    # initial conditions\n    I₀  = Singleton([0.0])\n    x₀  = Singleton([0.0])\n    xe₀ = Singleton([0.0])\n    xc₀ = Singleton([0.0])\n    X₀ = I₀ × x₀ × xe₀ × xc₀\n\n    # reset map\n    Ar = sparse([1, 2, 3, 4, 4], [1, 2, 2, 2, 4], [1., 1., -1., -Tsample, 1.], 4, 4)\n    br = sparsevec([3, 4], [x0, Tsample*x0], 4)\n    reset_map(X) = Ar * X + br\n\n    # hybrid system with clocked linear dynamics\n    ha = HACLD1(EMbrake, reset_map, Tsample, ζ)\n    return IVP(ha, X₀)\nend\n\n# Parameter variation","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"The model with parameter variation described below consists of changing only one coefficient, which corresponds to the Flow* settings in [SO15].","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"function embrake_pv_1(; Tsample=1.E-4, ζ=1e-6, Δ=3.0, x0=0.05)\n    # model's constants\n    L = 1.e-3\n    KP = 10000.\n    KI = 1000.\n    R = 0.5\n    K = 0.02\n    drot = 0.1\n    i = 113.1167\n    p = 504. + (-Δ .. Δ)\n\n    # state variables: [I, x, xe, xc]\n    A = IntervalMatrix([-p            0      KP/L   KI/L;\n                        K/i/drot      0      0      0;\n                        0             0      0      0;\n                        0             0      0      0])\n\n    EMbrake = @system(x' = Ax)\n\n    # initial conditions\n    I₀  = Singleton([0.0])\n    x₀  = Singleton([0.0])\n    xe₀ = Singleton([0.0])\n    xc₀ = Singleton([0.0])\n    X₀ = I₀ × x₀ × xe₀ × xc₀\n\n    # reset map\n    Ar = sparse([1, 2, 3, 4, 4], [1, 2, 2, 2, 4], [1., 1., -1., -Tsample, 1.], 4, 4)\n    br = sparsevec([3, 4], [x0, Tsample*x0], 4)\n    reset_map(X) = Ar * X + br\n\n    # hybrid system with clocked linear dynamics\n    ha = HACLD1(EMbrake, reset_map, Tsample, ζ)\n    return IVP(ha, X₀)\nend\n\n# Extended parameter variation","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"In the following model, considered in [...], we vary all constants by χ% with respect to their nominal values. The variation percentage defaults to 5%.","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"function embrake_pv_2(; Tsample=1.E-4, ζ=1e-6, x0=0.05, χ=5.0)\n    # model's constants\n    Δ = -χ/100 .. χ/100\n    L = 1.e-3 * (1 + Δ)\n    KP = 10000. * (1 + Δ)\n    KI = 1000. * (1 + Δ)\n    R = 0.5 * (1 + Δ)\n    K = 0.02 * (1 + Δ)\n    drot = 0.1 * (1 + Δ)\n    i = 113.1167 * (1 + Δ)\n\n    # state variables: [I, x, xe, xc]\n    A = IntervalMatrix([-(R+K^2/drot)/L 0      KP/L  KI/L;\n                          K/i/drot      0      0      0;\n                          0             0      0      0;\n                          0             0      0      0])\n\n    EMbrake = @system(x' = Ax)\n\n    # initial conditions\n    I₀  = Singleton([0.0])\n    x₀  = Singleton([0.0])\n    xe₀ = Singleton([0.0])\n    xc₀ = Singleton([0.0])\n    X₀ = I₀ × x₀ × xe₀ × xc₀\n\n    # reset map\n    Ar = sparse([1, 2, 3, 4, 4], [1, 2, 2, 2, 4], [1., 1., -1., -Tsample, 1.], 4, 4)\n    br = sparsevec([3, 4], [x0, Tsample*x0], 4)\n    reset_map(X) = Ar * X + br\n\n    # hybrid system with clocked linear dynamics\n    ha = HACLD1(EMbrake, reset_map, Tsample, ζ)\n    return IVP(ha, X₀)\nend","category":"page"},{"location":"models/EMBrake/#References","page":"Electromechanic break","title":"References","text":"","category":"section"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"[SO15]: Strathmann, Thomas, and Jens Oehlerking. Verifying Properties of an Electro-Mechanical Braking System. ARCH CPSWeek. 2015.","category":"page"},{"location":"models/EMBrake/","page":"Electromechanic break","title":"Electromechanic break","text":"[]:","category":"page"},{"location":"lib/algorithms/ASB07/","page":"ASB07","title":"ASB07","text":"ASB07","category":"page"},{"location":"lib/algorithms/ASB07/#ReachabilityAnalysis.ASB07","page":"ASB07","title":"ReachabilityAnalysis.ASB07","text":"ASB07{N, AM, RM, S, R} <: AbstractContinuousPost\n\nImplementation of Althoff - Stursberg - Buss algorithm for reachability of linear systems with uncertain parameters and inputs using zonotopes.\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: Forward) approximation model;                       see Notes below for possible options\nmax_order        – (optional, default: 5) maximum zonotope order\nreduction_method – (optional, default: GIR05()) zonotope order reduction method used\nstatic           – (optional, default: false) if true, convert the problem data                       to statically sized arrays\nrecursive        – (optional default: true) if true, use the implementation that                       recursively computes each reach-set; otherwise, use the implementation                       that unwraps the sequence until the initial set\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – type of the approximation model\nRM – type associated to the reduction method\nS  – value type associated to the static option\nR  – value type associated to the recursive option\n\nThe sole parameter which doesn't have a default value is the step-size, associated to the type parameter N.\n\nThe default approximation model is\n\napprox_model=CorrectionHull(order=10, exp=:base)\n\nHere, CorrectionHull refers to an implementation of the interval matrix approximation method described in [ASB07]. For technicalities on interval matrix operations, we refer to the package IntervalMatrices.jl.\n\nReferences\n\nThe main ideas behind this algorithm can be found in [ASB07]. These methods are discussed at length in the dissertation [ALT10].\n\nRegarding the zonotope order reduction methods, we refer to [COMB03], [GIR05] and the review article [YS18].\n\n\n\n\n\n","category":"type"},{"location":"lib/clustering/","page":"Clustering","title":"Clustering","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/clustering/#Clustering","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"lib/clustering/#Abstract-interface","page":"Clustering","title":"Abstract interface","text":"","category":"section"},{"location":"lib/clustering/","page":"Clustering","title":"Clustering","text":"AbstractClusteringMethod","category":"page"},{"location":"lib/clustering/#ReachabilityAnalysis.AbstractClusteringMethod","page":"Clustering","title":"ReachabilityAnalysis.AbstractClusteringMethod","text":"AbstractClusteringMethod{P}\n\nAbstract supertype for all clustering types, with partition of type P.\n\nNotes\n\nA clustering method defines a function which maps reach-sets to one or several reach-sets. The mapping can possibly be over-approximative, i.e. such that the set union of the input reach-sets is included in the set union of the output reach-sets.\n\nBy taking the convex hull of the input reach-sets one can reduce the number of outputs sets to a single one, overapproximately. This is the method that corresponds to the LazyClustering type. However, in some cases it is conveinent to do other types of transformations, such as:\n\nReturn several reach-sets that are obtained by grouping the input in a way defined by a partition. For example, a vector of ten input sets can be clustered in two groups of five sets each, or five groups of two sets each, etc.\nUse different set representations such as boxes or zonotopes.\nFurther post-process the output of the convexification by splitting into smaller sets, eg. box splitting.\n\nEach concrete subtype of AbstractClusteringMethod has a parameter P that defines what type of clustering strategy is applied. The method should be accessed with the partition getter function.\n\nThe following strategies are implemented at the interface level:\n\nIf P is of type Missing: no partition is applied\nIf P is of type integer: the partition corresponds to gruping the into the given integer                            number of sets (or as close as possible)\nIf P is of type vector of vectors: the given partition is applied\n\nExamples\n\nLazyClustering([1:2, 3:10]) groups the first two reach-sets in one cluster and the third to tenth reach-sets in another cluster.\n\n\n\n\n\n","category":"type"},{"location":"lib/clustering/#No-clustering","page":"Clustering","title":"No clustering","text":"","category":"section"},{"location":"lib/clustering/","page":"Clustering","title":"Clustering","text":"NoClustering","category":"page"},{"location":"lib/clustering/#ReachabilityAnalysis.NoClustering","page":"Clustering","title":"ReachabilityAnalysis.NoClustering","text":"NoClustering{P} <: AbstractClusteringMethod{P}\n\nNo-op clustering method.\n\n\n\n\n\n","category":"type"},{"location":"lib/clustering/","page":"Clustering","title":"Clustering","text":"The following methods are available.","category":"page"},{"location":"lib/clustering/#Lazy-convexification","page":"Clustering","title":"Lazy convexification","text":"","category":"section"},{"location":"lib/clustering/","page":"Clustering","title":"Clustering","text":"LazyClustering","category":"page"},{"location":"lib/clustering/#ReachabilityAnalysis.LazyClustering","page":"Clustering","title":"ReachabilityAnalysis.LazyClustering","text":"LazyClustering{P} <: AbstractClusteringMethod{P}\n\nCluster according to the given partition by applying a lazy representation of the convex hull.\n\n\n\n\n\n","category":"type"},{"location":"lib/clustering/#Box-clustering","page":"Clustering","title":"Box clustering","text":"","category":"section"},{"location":"lib/clustering/","page":"Clustering","title":"Clustering","text":"BoxClustering","category":"page"},{"location":"lib/clustering/#ReachabilityAnalysis.BoxClustering","page":"Clustering","title":"ReachabilityAnalysis.BoxClustering","text":"BoxClustering{PI, PO} <: AbstractClusteringMethod{P}\n\nNotes\n\nThis method first takes a lazy convex hull for the given partition, then computes a tight hyperrectangular approximation for each element in the partition.\n\n\n\n\n\n","category":"type"},{"location":"lib/clustering/#Zonotope-clustering","page":"Clustering","title":"Zonotope clustering","text":"","category":"section"},{"location":"lib/clustering/","page":"Clustering","title":"Clustering","text":"ZonotopeClustering","category":"page"},{"location":"lib/clustering/#ReachabilityAnalysis.ZonotopeClustering","page":"Clustering","title":"ReachabilityAnalysis.ZonotopeClustering","text":"ZonotopeClustering{P} <: AbstractClusteringMethod{P}\n\nNotes\n\nThis method first takes a lazy convex hull for the given partition, then computes a zonotope overapproximation of the convex hull.\n\n\n\n\n\n","category":"type"},{"location":"lib/clustering/#Lazy-union","page":"Clustering","title":"Lazy union","text":"","category":"section"},{"location":"lib/clustering/","page":"Clustering","title":"Clustering","text":"UnionClustering","category":"page"},{"location":"lib/clustering/#ReachabilityAnalysis.UnionClustering","page":"Clustering","title":"ReachabilityAnalysis.UnionClustering","text":"UnionClustering{P} <: AbstractClusteringMethod{P}\n\nCluster according to the given partition by applying a lazy representation of the set union.\n\n\n\n\n\n","category":"type"},{"location":"models/Building/","page":"Building","title":"Building","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/Building/Building.jl\"","category":"page"},{"location":"models/Building/#Building","page":"Building","title":"Building","text":"","category":"section"},{"location":"models/Building/","page":"Building","title":"Building","text":"(Image: )","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"note: Overview\nSystem type: Affine system\nState dimension: 48\nApplication domain: Mechanical Engineering","category":"page"},{"location":"models/Building/#Model-description","page":"Building","title":"Model description","text":"","category":"section"},{"location":"models/Building/","page":"Building","title":"Building","text":"The model corresponds to a building (the Los Angeles University Hospital) with 8 floors each having 3 degrees of freedom, namely displacements in x and y directions, and rotation [ASG00]. Such 24 variables evolve according to","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"  Mddotq(t) + Cdotq(t) + Kq(t) = vu(t)","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"where u(t) is the input. This system can be put into a traditional state-space form of order 48 by defining x = (q dotq)^T. We are interested in the motion of the first coordinate q_1(t), hence we choose v = (1 0 ldots 0)^T and the output y(t) = dotq_1(t) = x_25(t). In canonical form,","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"  beginarraylcl\n  dotx(t) = Ax(t) + Bu(t)qquad u(t) in mathcalU \n  y(t) = C x(t)\n  endarray","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"where x(t) in mathbbR^48 is the state vector, mathcalU in subseteq mathbbR is the input set, and A in mathbbR^48  48 and B  mathbbR^48  1 are matrices given in the file building.jld2. Here y(t) is the output with C in mathbbR^1  48 is the projection onto the coordinate 25.","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"There are two versions of this benchmark:","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"Time-varying inputs: The inputs can change arbitrarily over time: forall t u(t)in mathcalU.\nConstant inputs: The inputs are uncertain only in their initial value, and  constant over time: u(0)in mathcalU, dot u (t)= 0.","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"In both cases the input set mathcalU is the interval 08 10 is, and the initial states are taken from Table 2.2 in [TLT16].","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"using ReachabilityAnalysis, SparseArrays, JLD2\n\nLazySets.set_ztol(Float64, 1e-14)\n\nconst x25 = [zeros(24); 1.0; zeros(23)]\nconst x25e = vcat(x25, 0.0)\n\nexamples_dir = normpath(@__DIR__, \"..\", \"..\", \"..\", \"examples\")\nbuilding_path = joinpath(examples_dir, \"Building\", \"building.jld2\")\n\nfunction building_BLDF01()\n    @load building_path A B\n    n = size(A, 1)\n    U = Interval(0.8, 1.0)\n    S = @system(x' = Ax + Bu, u ∈ U, x ∈ Universe(n))\n\n    # initial states\n    center_X0 = [fill(0.000225, 10); fill(0.0, 38)]\n    radius_X0 = [fill(0.000025, 10); fill(0.0, 14); 0.0001; fill(0.0, 23)]\n    X0 = Hyperrectangle(center_X0, radius_X0)\n\n    prob_BLDF01 = InitialValueProblem(S, X0)\nend\n\nusing ReachabilityAnalysis: add_dimension\n\nfunction building_BLDC01()\n    @load building_path A B\n    n = size(A, 1)\n    U = Interval(0.8, 1.0)\n\n    # initial states\n    center_X0 = [fill(0.000225, 10); fill(0.0, 38)]\n    radius_X0 = [fill(0.000025, 10); fill(0.0, 14); 0.0001; fill(0.0, 23)]\n    X0 = Hyperrectangle(center_X0, radius_X0)\n\n    Ae = add_dimension(A)\n    Ae[1:n, end] = B\n    prob_BLDC01 = @ivp(x' = Ae * x, x(0) ∈ X0 × U)\nend","category":"page"},{"location":"models/Building/#Reachability-settings","page":"Building","title":"Reachability settings","text":"","category":"section"},{"location":"models/Building/","page":"Building","title":"Building","text":"The verification goal is to check whether the displacement y_1 of the top floor of the building remains below a given bound. In addition to the safety specification from the original benchmark, there are two UNSAT instances that serve as sanity checks to ensure that the model and the tool work as intended. But there is a caveat: In principle, verifying an UNSAT instance only makes sense formally if a witness is provided (counter-example, under-approximation, etc.). Since most of the participating tools do not have this capability, we run the tools with the same accuracy settings on an SAT-UNSAT pair of instances. The SAT instance demonstrates that the over-approximation is not too coarse, and the UNSAT instance indicates that the over-approximation is indeed conservative.","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"BDS01: Bounded time, safe property: For all t in 0 20,  y_1(t) leq 51cdot 10^-3. This property is assumed to be satisfied.\nBDU01: Bounded time, unsafe property: For all t in 0 20,  y_1(t) leq 4cdot 10^-3. This property is assumed to be violated.  Property BDU01 serves as a sanity check. A tool should be run with the same  accuracy settings on BLDF01-BDS01 and BLDF01-BDU01, returning UNSAT on the  former and SAT on the latter.\nBDU02: Bounded time, unsafe property: The forbidden states are   y_1(t) leq -078cdot 10^-3 wedge t = 20. This property is  assumed to be violated for BLDF01 and satisfied for BLDC01. Property BDU02  serves as a sanity check to confirm that time-varying inputs are taken into  account. A tool should be run with the same accuracy settings on BLDF01-BDU02  and BLDC01-BDU02, returning UNSAT on the former and SAT on the latter.","category":"page"},{"location":"models/Building/#Results","page":"Building","title":"Results","text":"","category":"section"},{"location":"models/Building/","page":"Building","title":"Building","text":"For the discrete-time analysis we use a step size of 001.","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"using Plots","category":"page"},{"location":"models/Building/#BLDF01","page":"Building","title":"BLDF01","text":"","category":"section"},{"location":"models/Building/","page":"Building","title":"Building","text":"prob_BLDF01 = building_BLDF01()","category":"page"},{"location":"models/Building/#Dense-time","page":"Building","title":"Dense time","text":"","category":"section"},{"location":"models/Building/","page":"Building","title":"Building","text":"sol_BLDF01_dense = solve(prob_BLDF01, T=20.0, alg=LGG09(δ=0.004, vars=(25), n=48));\n\nplot(sol_BLDF01_dense, vars=(0, 25), linecolor=:blue, color=:blue, alpha=0.8, lw=1.0, xlab=\"t\", ylab=\"x25\")","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"Safety properties","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_dense)","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_dense) <= 5.1e-3 # BLDF01 - BDS01","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_dense) <= 4e-3 # BLDF01 - BDU01","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_dense(20.0))","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_dense(20.0)) <= -0.78e-3 # BLDF01 - BDU02","category":"page"},{"location":"models/Building/#Discrete-time","page":"Building","title":"Discrete time","text":"","category":"section"},{"location":"models/Building/","page":"Building","title":"Building","text":"sol_BLDF01_discrete = solve(prob_BLDF01, T=20.0, alg=LGG09(δ=0.01, vars=(25), n=48, approx_model=NoBloating()));\n\nplot(sol_BLDF01_discrete, vars=(0, 25), linecolor=:blue, color=:blue, alpha=0.8, lw=1.0, xlab=\"t\", ylab=\"x25\")","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"Safety properties","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_discrete)","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_discrete) <= 5.1e-3 # BLDF01 - BDS01","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_discrete)","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_discrete) <= 4e-3 # BLDF01 - BDU01","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_discrete(20.0))","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_discrete(20.0)) <= -0.78e-3 # BLDF01 - BDU02","category":"page"},{"location":"models/Building/#BLDC01","page":"Building","title":"BLDC01","text":"","category":"section"},{"location":"models/Building/","page":"Building","title":"Building","text":"prob_BLDC01 = building_BLDC01()","category":"page"},{"location":"models/Building/#Dense-time-2","page":"Building","title":"Dense time","text":"","category":"section"},{"location":"models/Building/","page":"Building","title":"Building","text":"sol_BLDC01_dense = solve(prob_BLDC01, T=20.0, alg=LGG09(δ=0.005, vars=(25), n=49))\n\nplot(sol_BLDC01_dense, vars=(0, 25), linecolor=:blue, color=:blue, alpha=0.8, lw=1.0, xlab=\"t\", ylab=\"x25\")","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"Safety properties","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25e, sol_BLDC01_dense)","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25e, sol_BLDC01_dense) <= 5.1e-3 # BLDC01 - BDS01","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25e, sol_BLDC01_dense) <= 4e-3 # BLDC01 - BDU01","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25, sol_BLDF01_discrete(20.0))","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25e, sol_BLDC01_dense(20.0)) <= -0.78e-3 # BLDC01 - BDU02","category":"page"},{"location":"models/Building/#Discrete-time-2","page":"Building","title":"Discrete time","text":"","category":"section"},{"location":"models/Building/","page":"Building","title":"Building","text":"sol_BLDC01_discrete = solve(prob_BLDC01, T=20.0, alg=LGG09(δ=0.01, vars=(25), n=49, approx_model=NoBloating()))\n\nplot(sol_BLDC01_discrete, vars=(0, 25), linecolor=:blue, color=:blue, alpha=0.8, lw=1.0, xlab=\"t\", ylab=\"x25\")","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"Safety properties","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25e, sol_BLDC01_discrete)","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25e, sol_BLDC01_discrete) <= 5.1e-3 # BLDC01 - BDS01","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25e, sol_BLDC01_discrete)","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25e, sol_BLDC01_discrete) <= 4e-3 # BLDC01 - BDU01","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25e, sol_BLDC01_discrete(20.0))","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"ρ(x25e, sol_BLDC01_discrete(20.0)) <= -0.78e-3 # BLDC01 - BDU02","category":"page"},{"location":"models/Building/#References","page":"Building","title":"References","text":"","category":"section"},{"location":"models/Building/","page":"Building","title":"Building","text":"[ASG00]: Antoulas, Athanasios C., Danny C. Sorensen, and Serkan Gugercin. A survey of model reduction methods for large-scale systems. 2000.","category":"page"},{"location":"models/Building/","page":"Building","title":"Building","text":"[TLT16]: Tran, Hoang-Dung, Luan Viet Nguyen, and Taylor T. Johnson. Large-scale linear systems from order-reduction (benchmark proposal). 3rd Applied Verification for Continuous and Hybrid Systems Workshop (ARCH), Vienna, Austria. 2016.","category":"page"},{"location":"lib/algorithms/CARLIN/#CARLIN","page":"CARLIN","title":"CARLIN","text":"","category":"section"},{"location":"lib/algorithms/CARLIN/","page":"CARLIN","title":"CARLIN","text":"Reachability algorithm based on conservative Carleman linearization procedure.","category":"page"},{"location":"lib/algorithms/CARLIN/#Kronecker-product","page":"CARLIN","title":"Kronecker product","text":"","category":"section"},{"location":"lib/algorithms/CARLIN/","page":"CARLIN","title":"CARLIN","text":"ReachabilityAnalysis.kron_pow\nReachabilityAnalysis.kron_pow_stack\nReachabilityAnalysis.kron_id\nReachabilityAnalysis.kron_sandwich\nReachabilityAnalysis.kron_sum","category":"page"},{"location":"lib/algorithms/CARLIN/#ReachabilityAnalysis.kron_pow","page":"CARLIN","title":"ReachabilityAnalysis.kron_pow","text":"kron_pow(x::IA.Interval, pow::Int)\n\nGiven an interval x and an integer pow, compute x^pow.\n\nInput\n\nx   – interval\npow – integer\n\nOutput\n\nAn interval enclosure of x^pow.\n\nExamples\n\njulia> [kron_pow(2 .. 3, i) for i in 1:3]\n3-element Array{IntervalArithmetic.Interval{Float64},1}:\n  [2, 3]\n  [4, 9]\n [8, 27]\n\n\n\n\n\nkron_pow(x::Interval, pow::Int)\n\nGiven an interval x and an integer pow, compute x^pow.\n\nInput\n\nx   – interval\npow – integer\n\nOutput\n\nAn interval enclosure of x^pow as a LazySets Interval.\n\n\n\n\n\nkron_pow(H::AbstractHyperrectangle, pow::Int)\n\nGiven hyperrectangular set H and an integer pow, compute the Kronecker power H^{⊗ pow}.\n\nInput\n\nH   – hyperrectangular set\npow – integer power\n\nOutput\n\nA hyperrectangle.\n\nAlgorithm\n\nWe compute H^{⊗ pow} where H is a hyperrectangular set by working with H as a product of intervals.\n\nSee also kron_pow which requires DynamicPolynomials.jl.\n\n\n\n\n\nkron_pow(x::Vector{<:AbstractVariable}, pow::Int)\n\nCompute the higher order concrete Kronecker power: x ⊗ x ⊗ ... ⊗ x, pow times for a vector of symbolic monomials.\n\nInput\n\nx   – polynomial variable\npow – integer\n\nOutput\n\nVector of multivariate monomial corresponding to x^{⊗ pow}.\n\nExamples\n\njulia> using DynamicPolynomials\n\njulia> @polyvar x[1:2]\n(PolyVar{true}[x₁, x₂],)\n\njulia> x\n2-element Array{PolyVar{true},1}:\n x₁\n x₂\n\njulia> kron_pow(x, 2)\n4-element Array{Monomial{true},1}:\n x₁²\n x₁x₂\n x₁x₂\n x₂²\n\n\n\n\n\n","category":"function"},{"location":"lib/algorithms/CARLIN/#ReachabilityAnalysis.kron_pow_stack","page":"CARLIN","title":"ReachabilityAnalysis.kron_pow_stack","text":"kron_pow_stack(x::Union{<:Interval, <:IA.Interval}, pow::Int)\n\nReturn an array with the interval powers [x, x^2, …, x^pow].\n\nInput\n\nx   – interval\npow – integer power\n\nOutput\n\nA vector of elements of the same type as x such that the i-th element is the interval x^i.\n\n\n\n\n\nkron_pow_stack(H::AbstractHyperrectangle, pow::Int)\n\nReturn the Cartesian product array H  H^2    H^pow where H is a hyperrectangular set and H^ i is the i-th Kronecker power of H.\n\nInput\n\nH   – hyperrectangular set\npow – integer power\n\nOutput\n\nA Cartesian product array of hyperrectangles.\n\n\n\n\n\n","category":"function"},{"location":"lib/algorithms/CARLIN/#Error-bounds","page":"CARLIN","title":"Error bounds","text":"","category":"section"},{"location":"lib/algorithms/CARLIN/#References","page":"CARLIN","title":"References","text":"","category":"section"},{"location":"lib/algorithms/QINT/","page":"QINT","title":"QINT","text":"QINT","category":"page"},{"location":"lib/algorithms/QINT/#ReachabilityAnalysis.QINT","page":"QINT","title":"ReachabilityAnalysis.QINT","text":"QINT{N, AM} <: AbstractContinuousPost\n\nReachability method for one-dimensional quadratic ODEs with non-deterministic inputs.\n\nFields\n\nThe type fields are:\n\nN   – number type of the step-size\nAM  – type of the approximation model\n\nNotes\n\n\n\n\n\n","category":"type"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"man/faq/#Frequently-Asked-Questions-(FAQ)","page":"Frequently Asked Questions","title":"Frequently Asked Questions (FAQ)","text":"","category":"section"},{"location":"man/faq/#General-questions","page":"Frequently Asked Questions","title":"General questions","text":"","category":"section"},{"location":"man/faq/#What-are-good-introductory-papers-on-the-subject?","page":"Frequently Asked Questions","title":"What are good introductory papers on the subject?","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"An elementary introduction to the principles of set-based numerical integration can be found in Oded Maler's article Computing Reachable Sets: An Introduction. For an introduction to hybrid systems reachability we recommend the lecture notes of Prof. Goran Frehse, Formal Verification of Piecewise Affine Hybrid Systems (DigiCosme Spring School, Paris, May 2016). Most up-to-date material related to reachability analysis can be found in journals, conference articles or in PhD theses. For a comprehensive review of different set propagation techniques for linear, nonlinear and hybrid systems see [AFG20]. The article also contains a discussion of successful applications of reachability analysis to real-world problems. We refer to the References section of this manual for further links to the relevant literature.","category":"page"},{"location":"man/faq/#Are-there-other-tools-that-perform-reachability-analysis?","page":"Frequently Asked Questions","title":"Are there other tools that perform reachability analysis?","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The wiki Related Tools contains an extensive list of pointers related to reachability analysis tools for dynamical systems. Languages and tools for hybrid systems design are described in the review article [CPPSV06] (a bit outdated with respect to the tools since it is of 2006).","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"A subset of such tools has participated in recent editions of of the Friendly Competition for Applied Reachability of Continuous and Hybrid Systems, ARCH-COMP. In alphabetic order: Ariadne, CORA, C2E2, DynIbex, Flow*, HyDRA, Hylaa, Isabelle/HOL-ODE-Numerics, SpaceEx and XSpeed. A paragraph describing each tool's main characteristics can be found in the ARCH-COMP articles for each category (AFF for linear and NLN for nonlinear).","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The IEEE Control Systems Society (CSS) has a Technical Committee on Hybrid Systems that is dedicated to providing informational forums, meetings for technical discussion, and information over the web to researchers in the IEEE CSS who are interested in the field of hybrid systems and its applications. A list of actively-maintained tools for the analysis and synthesis of hybrid systems, compiled by members of such committee, can be found here.","category":"page"},{"location":"man/faq/#Why-did-you-choose-Julia-to-write-this-library?","page":"Frequently Asked Questions","title":"Why did you choose Julia to write this library?","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The language choice when programming for research purposes usually depends on the developers' background knowledge which directly impacts convenience during development and output performance in the final product. On the one hand, compiled languages such as C++ offer high performance, but the compilation overhead is inconvenient for prototyping. On the other hand, interpreted languages such as Python offer an interactive session for convenient prototyping, but these languages fall behind in performance or need to extend the code to work with another lower-layer program such as Numba or Cython (known as the two-language problem). A compromise between the two worlds are just-in-time (JIT) compiled languages such as MATLAB. Last but not least, the ecosystem of libraries available and the user base is also an important consideration.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In our case, we began to develop the JuliaReach stack in 2017 and quickly adopted the language when it was at its v0.5 [v1]. Julia is a general-purpose programming language but it was conceived with high-performance scientific computing in mind, and it reconciles the two advantages of compiled and interpreted languages described above, as it comes with an interactive read-evaluate-print loop (REPL) front-end, but is JIT compiled to achieve performance that is competitive with compiled languages such as C [BEKS17]. A distinctive feature of Julia is multiple dispatch (i.e., the function to execute is chosen based on each argument type), which allows to write efficient machine code based on a given type, e.g., of the set. As additional features, Julia is platform independent, has an efficient interface to C and FORTRAN, is supported in Jupyter notebooks (the \"Ju\" in Jupyter is for Julia) and well-suited for parallel computing. Julia has a determined and quickly-growing community, especially for scientific tools (see the JuliaLang Community webpage). All this makes Julia an interesting programming language for writing a library for reachability analysis.","category":"page"},{"location":"man/faq/#What-is-the-wrapping-effect?","page":"Frequently Asked Questions","title":"What is the wrapping effect?","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Quoting a famous paper by R. E. Moore [M65]:","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Under the flow itself a box is carried after certain time into a set of points which will in general not remain a box excepted for a few simple flows.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The wrapping effect is associated to error propagation that arises from the inability of a set representation to accurately abstract some properties of system under study. Wrapping-free methods only exist for linear systems. Nonlinear reachability methods control, but do not totally elimitate, the wrapping effect in different ways.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"As a simple illustration of the wrapping effect, consider the image of a box through a rotation in discrete time-steps. Box enclosures (full line) introduce a strong wrapping effect. On the other hand, had we represented the sequence using zonotopes (dashed lines), the result would be exact, i.e. without wrapping, since the image of a hyperrectangular set under an affine map is a zonotope.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using LazySets, Plots\n\nR(θ) = [cos(θ) -sin(θ); sin(θ) cos(θ)]\n\nB = BallInf(ones(2), 0.1)\nB′ = R(π/4) * B\nB′′ = R(π/2) * B\n\n□B = box_approximation(B)\n□B′ = box_approximation(B′)\n□B′′ = box_approximation(R(π/4) * □B′)\n\nplot(B, ratio=1, lw=2.0, style=:dash)\nplot!(B′, lw=2.0, style=:dash)\nplot!(B′′, lw=2.0, style=:dash)\n\nplot!(□B, lw=2.0, style=:solid)\nplot!(□B′, lw=2.0, style=:solid)\nplot!(□B′′, lw=2.0, style=:solid)","category":"page"},{"location":"man/faq/#Does-reachability-solve-for-the-vertices-of-the-set?","page":"Frequently Asked Questions","title":"Does reachability solve for the vertices of the set?","text":"","category":"section"},{"location":"man/faq/#What-happens-if-you-consider-a-chaotic-system?","page":"Frequently Asked Questions","title":"What happens if you consider a chaotic system?","text":"","category":"section"},{"location":"man/faq/#Can-reachability-analysis-be-used-to-solve-large-problems?","page":"Frequently Asked Questions","title":"Can reachability analysis be used to solve large problems?","text":"","category":"section"},{"location":"man/faq/#Solving-capabilities","page":"Frequently Asked Questions","title":"Solving capabilities","text":"","category":"section"},{"location":"man/faq/#How-can-I-visualize-trajectories?","page":"Frequently Asked Questions","title":"How can I visualize trajectories?","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"It is often necessary to plot a \"bunch\" of trajectories starting from a set of initial conditions. The parallel ensemble simulations capabilities from the Julia DifferentialEquations.jl suite can be used to numerically simulate a given number of trajectories and it counts with state-of-the-art algorithms for stiff and non-stiff ODEs as well as many other advanced features, such as distributed computing, multi-threading and GPU support. See EnsembleAlgorithms for details.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"As a simple example consider the scalar ODE x(t) = 101x(t) with initial condition on the interval x(0) in 0 05. To solve it using ensemble simulations, pass the ensemble=true keyword argument to the solve function (if the library DifferentialEquations was not loaded in your current session, an error is triggered). The number of trajectories can be specified with the trajectories keyword argument.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using ReachabilityAnalysis, DifferentialEquations\n\n# to avoid namespace conflicts\nusing ReachabilityAnalysis: solve\n\n# formulate initial-value problem\nprob = @ivp(x' = 1.01x, x(0) ∈ 0 .. 0.5)\n\n# solve the flowpipe using a default algorithm, and also compute trajectories\nsol = solve(prob, tspan=(0.0, 1.0), ensemble=true, trajectories=250)\n\n# plot flowpipe and the ensemble solution\nusing Plots\n\nplot(sol, vars=(0, 1), linewidth=0.2, xlab=\"t\", ylab=\"x(t)\")\nplot!(ensemble(sol), vars=(0, 1), linealpha=1.0)","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Please note that the latency (compilation time) of the first using line is long, typically one minute with Julia v1.5.3.","category":"page"},{"location":"man/faq/#Can-I-solve-a-for-a-single-initial-condition?","page":"Frequently Asked Questions","title":"Can I solve a for a single initial condition?","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"To solve for a single initial condition, i.e. a \"point\", use Singleton as the initial set (singleton means a set with one element). For example, here we plot the free vibration solution of a standard single degree of freedom system without physical damping,","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"    x(t) + 4x(t) = 0 qquad x(0) = 1qquad x(0) = 0","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In this initial-value problem, the initial condition is given as a point that we can model as X0 = Singleton([1.0, 0.0]), where we associate the first coordinate to position, x(t), and the second coordinate to velocity, x'(t).","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"note: Note\nUsual Julia vectors such as X0 = [1.0, 0.0] are also valid input, and are treated as a singleton. It is also valid to use tuples in second order systems, e.g. prob = @ivp(X' = AX, X(0) ∈ ([1.0], [0.0])).","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Below we plot the flowpipe for the same initial condition and different step sizes.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using ReachabilityAnalysis, Plots\n\n# x' = v\n# v' = -4x\nA = [0 1; -4. 0]\nX0 = Singleton([1.0, 0.0])\nprob = @ivp(X' = AX, X(0) ∈ X0)\n\nf(ΔT) = solve(prob, tspan=(0.0, 5.0), alg=GLGM06(δ=ΔT))\n\nplot(f(0.3), vars=(0, 1), lab=\"ΔT=0.3\", color=:yellow)\nplot!(f(0.1), vars=(0, 1), lab=\"ΔT=0.1\", color=:lightblue)\nplot!(f(0.05), vars=(0, 1), xlab=\"time\", ylab=\"x(t)\", lab=\"ΔT=0.05\", color=:green)\n\ndom = 0:0.01:5.0\nplot!(dom, cos.(2.0 * dom), lab=\"Analytic\", color=:magenta)","category":"page"},{"location":"man/faq/#Why-do-I-see-boxes-for-single-initial-conditions?","page":"Frequently Asked Questions","title":"Why do I see boxes for single initial conditions?","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"As it is seen in the question Can I solve a for a single initial condition?, even if the initial condition is a singleton, the obtained flowpipe is a sequence of boxes in the x-t plane, i.e. we obtain sets with non-zero width both in time and in space. This behavior may seem confusing at first, because the initial conditions where determinitic. The catch is that reach-sets represents a set of states reachable over a time interval, that certainly contains the exact solution for the time-span associated to the reach-set, tspan(R). The projection of the flowpipe on the time axis thus returns a sequence of intervals, their width being the step size of the method (in case the method has fixed step size). When we take the Cartesian product of each time span with the projection of the flowpipe in x(t), we obtain a box.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If we consider two different step-sizes, the area of the boxes shrinks. It is known theoretically that the flowpipe converges, in Hausdorff norm, to the exact flowpipe. The plot below illustrates the convergence for aspects for two different step sizes, ΔT=0.1 and ΔT=0.05, evaluating the solution around the time point 3.0. The projection onto x(t) (vertical axis) shows that dividing the step size by half, we can more accurately know the exact value of the solution, and the width of the boxes intersecting the time point 3.0 decrease by a factor 2.5x.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"plot(f(0.1)(3.0), vars=(0, 1), xlab=\"time\", ylab=\"x(t)\", lab=\"ΔT=0.1\", color=:lightblue)\n\nI(Δt, t) = -ρ([-1.0, 0.0], f(Δt)(t)) .. ρ([1.0, 0.0], f(Δt)(t)) |> Interval\n\nI01 = I(0.1, 3.0)\nplot!(y -> max(I01), xlims=(2.9, 3.1), lw=3.0, style=:dash, color=:lightblue, lab=\"Δx = $(I01.dat)\")\nplot!(y -> min(I01), xlims=(2.9, 3.1), lw=3.0, style=:dash, color=:lightblue, lab=\"\")\nplot!(f(0.05)(3.0), vars=(0, 1), xlab=\"time\", ylab=\"x(t)\", lab=\"ΔT=0.05\", color=:green)\n\nI005 = I(0.05, 3.0)\nplot!(y -> max(I005), xlims=(2.9, 3.1), lw=3.0, style=:dash, color=:green, lab=\"Δx = $(I005.dat)\")\nplot!(y -> min(I005), xlims=(2.9, 3.1), lw=3.0, style=:dash, color=:green, lab=\"\")\n\ndom = 2.9:0.01:3.1\nplot!(dom, cos.(2.0 * dom), lab=\"Analytic\", color=:magenta, legend=:bottomright)","category":"page"},{"location":"man/faq/#Why-do-some-trajectories-escape-the-flowpipe?","page":"Frequently Asked Questions","title":"Why do some trajectories escape the flowpipe?","text":"","category":"section"},{"location":"man/faq/#Can-I-compute-solutions-using-parallel-programming?","page":"Frequently Asked Questions","title":"Can I compute solutions using parallel programming?","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Yes. You can compute multiple flowpipes in parallel by defining an initial-value problem with an array of initial conditions. This methods uses Julia's multithreaded parallelism, so you have to set the number of threads to use before starting Julia. The following example illustrates this point. For further details we refer to the section Distributed computations.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using ReachabilityAnalysis, Plots\n\nA = [0.0 1.0; -1.0 0.0]\n\nB = [BallInf([0,0.] .+ k, 0.1) for k in 1:5]\nprob = @ivp(x' = Ax, x(0) ∈ B)\n\n# multi-threaded solve\nsol = solve(prob, T=12.0, alg=GLGM06(δ=0.02));\nplot(sol, vars=(0, 2), c=:red, alpha=.5, lw=0.2, xlab=\"t\", ylab=\"y\")","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"On the other hand, please note that in the example of above, you can compute with a single integration the flowpipe corresponding to the convex hull of the elements in the array B.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"prob = @ivp(x' = Ax, x(0) ∈ ConvexHullArray(B))\nsol = solve(prob, T=12.0, alg=GLGM06(δ=0.02));\nplot!(sol, vars=(0, 2), c=:lightgreen, alpha=.5, lw=0.2, xlab=\"t\", ylab=\"y\")","category":"page"},{"location":"man/faq/#Modeling-questions","page":"Frequently Asked Questions","title":"Modeling questions","text":"","category":"section"},{"location":"man/faq/#Can-I-use-ODE-solvers-with-interval-initial-conditions?","page":"Frequently Asked Questions","title":"Can I use ODE solvers with interval initial conditions?","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Although it is in principle possible to  ODE solvers for","category":"page"},{"location":"man/faq/#How-do-I-use-the-@taylorize-macro?","page":"Frequently Asked Questions","title":"How do I use the @taylorize macro?","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The section Some common gotchas of the user manual details do's and dont's for the @taylorize macro to speedup reachability computations using Taylor models.","category":"page"},{"location":"man/faq/#A-note-on-interval-types","page":"Frequently Asked Questions","title":"A note on interval types","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"When using intervals as set representation, ReachabilityAnalysis.jl relies on rigorous floating-point arithmetic implemented in pure Julia in the library IntervalArithmetic.jl (we often use const IA = IntervalArithmetic as an abbreviation). The main struct defined in the library is IA.Interval (and the corresponding multi-dimensional interval is IA.IntervalBox). Internally, the set LazySets.Interval is wrapper-type of IA.Interval and these two types should not be confused, although our user APIs extensively use duck typing, in the sense that x(0) ∈ 0 .. 1 (IA.Interval type) and x(0) ∈ Interval(0, 1) are valid.","category":"page"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"On a technical level, the reason to have LazySets.Interval as a wrapper type of IA.Interval is that Julia doesn't allow multiple inheritance, but it was a design choice that intervals should belong to the LazySets type hierarchy.","category":"page"},{"location":"man/faq/#References","page":"Frequently Asked Questions","title":"References","text":"","category":"section"},{"location":"man/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"[v1] Version 1.0 of the lanuage was released in August 2018, see https://julialang.org/blog/2018/08/one-point-zero/\n[BEKS17] Bezanson, J., Edelman, A., Karpinski, S., & Shah, V. B. (2017). Julia: A fresh approach to numerical computing. SIAM review, 59(1), 65-98.","category":"page"},{"location":"lib/flowpipes/","page":"Flowpipes","title":"Flowpipes","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/flowpipes/#Flowpipes","page":"Flowpipes","title":"Flowpipes","text":"","category":"section"},{"location":"lib/flowpipes/#Abstract-interface","page":"Flowpipes","title":"Abstract interface","text":"","category":"section"},{"location":"lib/flowpipes/","page":"Flowpipes","title":"Flowpipes","text":"AbstractFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.AbstractFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.AbstractFlowpipe","text":"AbstractFlowpipe\n\nAbstract type representing a flowpipe.\n\nNotes\n\nA flowpipe is the set union of an array of reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/","page":"Flowpipes","title":"Flowpipes","text":"The following functions are available at the interface level.","category":"page"},{"location":"lib/flowpipes/","page":"Flowpipes","title":"Flowpipes","text":"basetype(::Type{<:AbstractFlowpipe})\nLazySets.ρ(::AbstractVector, ::AbstractFlowpipe)\nLazySets.σ(::AbstractVector, ::AbstractFlowpipe)\nLazySets.dim(::AbstractFlowpipe)\nset(::AbstractFlowpipe, ::Integer)\nset(::AbstractFlowpipe, ::AbstractVector)\nset(::AbstractFlowpipe)\ntstart(::AbstractFlowpipe)\ntend(::AbstractFlowpipe)\ntspan(::AbstractFlowpipe)\nvars(::AbstractFlowpipe)","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.basetype-Tuple{Type{var\"#s217\"} where var\"#s217\"<:ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.basetype","text":"basetype(T::Type{<:AbstractFlowpipe})\n\nReturn the base type of the given flowpipe type (i.e., without type parameters).\n\nInput\n\nT – flowpipe type, used for dispatch\n\nOutput\n\nThe base type of T.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.ρ-Tuple{AbstractArray{T,1} where T,ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.ρ","text":"LazySets.ρ(d::AbstractVector, fp::AbstractFlowpipe)\n\nInput\n\nd  – direction\nfp – flowpipe\n\nOutput\n\nThe support function of the flowpipe along the given direction d.\n\nNotes\n\nIn this fallback implementation, the flowpipe behaves like the union of the reach-sets, i.e. the implementation is analogue to that of a LazySet.UnionSetArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.σ-Tuple{AbstractArray{T,1} where T,ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.σ","text":"LazySets.σ(d::AbstractVector, fp::AbstractFlowpipe)\n\nInput\n\nd  – direction\nfp – flowpipe\n\nOutput\n\nThe support vector of the flowpipe along the given direction d.\n\nNotes\n\nIn this fallback implementation, the flowpipe behaves like the union of the reach-sets, i.e. the implementation is analogue to that of a LazySet.UnionSetArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.dim-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.dim","text":"LazySets.dim(fp::AbstractFlowpipe)\n\nInput\n\nfp – flowpipe\n\nOutput\n\nAn integer representing the ambient dimension of the flowpipe.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.set-Tuple{ReachabilityAnalysis.AbstractFlowpipe,Integer}","page":"Flowpipes","title":"LazySets.set","text":"set(fp::AbstractFlowpipe, ind::Integer)\n\nReturn the geometric set represented by this flowpipe at the given index.\n\nInput\n\nfp  – flowpipe\nind – index (from 1 to length(flowpipe))\n\nOutput\n\nThe set wrapped by the flowpipe at the given index.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.set-Tuple{ReachabilityAnalysis.AbstractFlowpipe,AbstractArray{T,1} where T}","page":"Flowpipes","title":"LazySets.set","text":"set(fp::AbstractFlowpipe, ind::AbstractVector)\n\nReturn the union of set represented by this flowpipe at the given indices.\n\nInput\n\nfp  – flowpipe\nind – vector of indices\n\nOutput\n\nThe set union stored in the flowpipe at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.set-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.set","text":"set(fp::AbstractFlowpipe)\n\nReturn the geometric set represented by this flowpipe as the union of reach-sets.\n\nInput\n\nfp  – flowpipe\n\nOutput\n\nThe set union of the array of reach-sets of the flowpipe.\n\nNotes\n\nTo retrieve the array of sets stored in the flowpipe use array(fp). To get a set at a particular index, use set(F[ind]) or set(F, ind).\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tstart-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tstart","text":"tstart(fp::AbstractFlowpipe)\n\nReturn the initial time of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nA float representing the initial time of the given flowpipe. The fallback is computed by taking the initial time of the first reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tend-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tend","text":"tend(fp::AbstractFlowpipe)\n\nReturn the final time of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nA float representing the initial time of the given flowpipe. The fallback is computed by taking the final time of the last reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tspan-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tspan","text":"tspan(fp::AbstractFlowpipe)\n\nReturn time span of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nThe interval representing the time span of the given flowpipe. The fallback is computed as (tstart(fp), tend(fp)), see tstart(::AbstractFlowpipe) and tend(::AbstractFlowpipe) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.vars-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.vars","text":"vars(fp::AbstractFlowpipe)\n\nReturn the tuple of variable indices of the flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nTuple of integers with the variable indices of the flowpipe, typically 1 2  n where n is the dimension of the flowpipe.\n\nNotes\n\nThe fallback implementation assumes first reach-set is representative.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#Flowpipe","page":"Flowpipes","title":"Flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/","page":"Flowpipes","title":"Flowpipes","text":"Flowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.Flowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.Flowpipe","text":"Flowpipe{N, RT<:AbstractReachSet{N}, VRT<:AbstractVector{RT}} <: AbstractFlowpipe\n\nType that wraps a flowpipe, which is an iterable collection of reach-sets that behaves like their set union.\n\nFields\n\nXk  – array of reach-sets\next – extension dictionary; field used by extensions\n\nNotes\n\nThe dimension of the flowpipe corresponds to the dimension of the underlying reach-sets; in this type, it is is assumed that the dimension is the same for the different reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/","page":"Flowpipes","title":"Flowpipes","text":"The following methods are available.","category":"page"},{"location":"lib/flowpipes/","page":"Flowpipes","title":"Flowpipes","text":"shift","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.shift","page":"Flowpipes","title":"ReachabilityAnalysis.shift","text":"shift(R::AbstractReachSet, t0::Number)\n\nPerform a time-shift of the given reach-set.\n\nInput\n\nR  – reach-set\nt0 – number that corresponds to the time-shift\n\nOutput\n\nA new reach-set of the same type of R such that its time-span has been shifted by t0.\n\n\n\n\n\nshift(fp::Flowpipe{N, <:AbstractReachSet}, t0::Number) where {N}\n\nReturn the time-shifted flowpipe by the given number.\n\nInput\n\nfp – flowpipe\nt0 – time shift\n\nOutput\n\nA new flowpipe such that the time-span of each constituent reach-set has been shifted by t0.\n\nNotes\n\nSee also Shift for the lazy counterpart.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#Hybrid-flowpipe","page":"Flowpipes","title":"Hybrid flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/","page":"Flowpipes","title":"Flowpipes","text":"HybridFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.HybridFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.HybridFlowpipe","text":"HybridFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of the same type, such that they are contiguous in time.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\nThe evaluation functions (in time) for this type do not assume that the flowpipes are contiguous in time. That is, the final time of the i-th flowpipe does not match the start time of the i+1-th flowpipe.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Mixed-flowpipe","page":"Flowpipes","title":"Mixed flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/","page":"Flowpipes","title":"Flowpipes","text":"MixedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.MixedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.MixedFlowpipe","text":"MixedFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of the same time, such that they are not necessarily contiguous in time.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\nThis type does not assume that the flowpipes are contiguous in time.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Shifted-flowpipe","page":"Flowpipes","title":"Shifted flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/","page":"Flowpipes","title":"Flowpipes","text":"ShiftedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.ShiftedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.ShiftedFlowpipe","text":"ShiftedFlowpipe{FT<:AbstractFlowpipe, NT<:Number} <: AbstractFlowpipe\n\nType that lazily represents a flowpipe that has been shifted in time.\n\nFields\n\nF  – original flowpipe\nt0 – time shift\n\nNotes\n\nThis type can wrap any concrete subtype of AbstractFlowpipe, and the extra field t0 is such that the time spans of each reach-set in F are shifted by the amount t0 (which should be a subtype of Number).\n\nA convenience constructor alias Shift is given.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Partitioned-flowpipe","page":"Flowpipes","title":"Partitioned flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/","page":"Flowpipes","title":"Flowpipes","text":"PartitionedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.PartitionedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.PartitionedFlowpipe","text":"PartitionedFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of possibly different types.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\n\n\n\n\n","category":"type"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Discretization · ReachabilityAnalysis.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/juliareach-light.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ReachabilityAnalysis.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">ReachabilityAnalysis.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/basics/">Basics</a></li><li><a class="tocitem" href="../../man/linear/">Linear ODEs</a></li><li><a class="tocitem" href="../../man/nonlinear/">Nonlinear ODEs</a></li><li><a class="tocitem" href="../../man/hybrid/">Hybrid systems</a></li><li><a class="tocitem" href="../../man/clocked/">Clocked systems</a></li><li><a class="tocitem" href="../../man/structure/">Exploiting structure</a></li><li><a class="tocitem" href="../../man/parametric/">Parametric reachability</a></li><li><a class="tocitem" href="../../man/backwards/">Backwards reachability</a></li><li><a class="tocitem" href="../../man/benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../man/library/">Model library</a></li><li><a class="tocitem" href="../../man/faq/">Frequently Asked Questions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/examples_overview/">Overview</a></li><li><a class="tocitem" href="../../models/OpAmp/">Operational amplifier</a></li><li><a class="tocitem" href="../../models/SquareWaveOscillator/">Square wave oscillator</a></li><li><a class="tocitem" href="../../models/VanDerPol/">Van der Pol oscillator</a></li><li><a class="tocitem" href="../../models/DuffingOscillator/">Duffing oscillator</a></li><li><a class="tocitem" href="../../models/TransmissionLine/">Transmision line</a></li><li><a class="tocitem" href="../../models/LaubLoomis/">Laub-Loomis</a></li><li><a class="tocitem" href="../../models/Building/">Building</a></li><li><a class="tocitem" href="../../models/ProductionDestruction/">Production-Destruction</a></li><li><a class="tocitem" href="../../models/LotkaVolterra/">Lotka-Volterra</a></li><li><a class="tocitem" href="../../models/Brusselator/">Brusselator</a></li><li><a class="tocitem" href="../../models/ISS/">Structural Model</a></li><li><a class="tocitem" href="../../models/Lorenz/">Lorenz system</a></li><li><a class="tocitem" href="../../models/Platoon/">Platoon</a></li><li><a class="tocitem" href="../../models/Quadrotor/">Quadrotor</a></li><li><a class="tocitem" href="../../models/SEIR/">SEIR model</a></li><li><a class="tocitem" href="../../models/Spacecraft/">Spacecraft</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../algorithms/ASB07/">ASB07</a></li><li><a class="tocitem" href="../algorithms/BFFPSV18/">BFFPSV18</a></li><li><a class="tocitem" href="../algorithms/BOX/">BOX</a></li><li><a class="tocitem" href="../algorithms/CARLIN/">CARLIN</a></li><li><a class="tocitem" href="../algorithms/GLGM06/">GLGM06</a></li><li><a class="tocitem" href="../algorithms/INT/">INT</a></li><li><a class="tocitem" href="../algorithms/LGG09/">LGG09</a></li><li><a class="tocitem" href="../algorithms/ORBIT/">ORBIT</a></li><li><a class="tocitem" href="../algorithms/QINT/">QINT</a></li><li><a class="tocitem" href="../algorithms/TMJets/">TMJets</a></li><li><a class="tocitem" href="../algorithms/VREP/">VREP</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../reachsets/">Reach-sets</a></li><li><a class="tocitem" href="../flowpipes/">Flowpipes</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../systems/">Systems</a></li><li class="is-active"><a class="tocitem" href>Discretization</a><ul class="internal"><li><a class="tocitem" href="#Discretize-API"><span>Discretize API</span></a></li><li><a class="tocitem" href="#Approximation-models"><span>Approximation models</span></a></li><li><a class="tocitem" href="#Exponentiation"><span>Exponentiation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../projections/">Projections</a></li><li><a class="tocitem" href="../clustering/">Clustering</a></li><li><a class="tocitem" href="../operations/">Further set operations</a></li><li><a class="tocitem" href="../distributed/">Distributed computations</a></li><li><a class="tocitem" href="../internals/">Internal functions and macros</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Discretization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Discretization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/docs/src/lib/discretize.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h1><ul><li><a href="#Discretization">Discretization</a></li><ul><li><a href="#Discretize-API">Discretize API</a></li><li><a href="#Approximation-models">Approximation models</a></li><li><a href="#Exponentiation">Exponentiation</a></li><li><a href="#References">References</a></li></ul></ul><h2 id="Discretize-API"><a class="docs-heading-anchor" href="#Discretize-API">Discretize API</a><a id="Discretize-API-1"></a><a class="docs-heading-anchor-permalink" href="#Discretize-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize" href="#LinearAlgebra.normalize"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalize(a::AbstractArray, p::Real=2)</code></pre><p>Normalize the array <code>a</code> so that its <code>p</code>-norm equals unity, i.e. <code>norm(a, p) == 1</code>. See also <a href="lib/@ref"><code>normalize!</code></a> and <a href="lib/@ref"><code>norm</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1,2,4];

julia&gt; b = normalize(a)
3-element Array{Float64,1}:
 0.2182178902359924
 0.4364357804719848
 0.8728715609439696

julia&gt; norm(b)
1.0

julia&gt; c = normalize(a, 1)
3-element Array{Float64,1}:
 0.14285714285714285
 0.2857142857142857
 0.5714285714285714

julia&gt; norm(c, 1)
1.0

julia&gt; a = [1 2 4 ; 1 2 4]
2×3 Array{Int64,2}:
 1  2  4
 1  2  4

julia&gt; norm(a)
6.48074069840786

julia&gt; normalize(a)
2×3 Array{Float64,2}:
 0.154303  0.308607  0.617213
 0.154303  0.308607  0.617213
</code></pre></div></section><section><div><pre><code class="language-none">normalize(hs::HalfSpace{N}, p=N(2)) where {N}</code></pre><p>Normalize a half-space.</p><p><strong>Input</strong></p><ul><li><code>hs</code> – half-space</li><li><code>p</code>  – (optional, default: <code>2</code>) norm</li></ul><p><strong>Output</strong></p><p>A new half-space whose normal direction <span>$a$</span> is normalized, i.e., such that <span>$‖a‖_p = 1$</span> holds.</p></div></section><section><div><pre><code class="language-none">normalize(P::AbstractHPolygon{N}, p=N(2)) where {N}</code></pre><p>Normalize a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polygon in constraint representation</li><li><code>p</code> – (optional, default: <code>2</code>) norm</li></ul><p><strong>Output</strong></p><p>A new polygon in constraint representation whose normal directions <span>$a_i$</span> are normalized, i.e., such that <span>$‖a_i‖_p = 1$</span> holds.</p></div></section><section><div><pre><code class="language-none">normalize(P::HPoly{N}, p=N(2)) where {N}</code></pre><p>Normalize a polyhedron in constraint representation.</p><p><strong>Input</strong></p><ul><li><code>P</code> – polyhedron in constraint representation</li><li><code>p</code> – (optional, default: <code>2</code>) norm</li></ul><p><strong>Output</strong></p><p>A new polyhedron in constraint representation whose normal directions <span>$a_i$</span> are normalized, i.e., such that <span>$‖a_i‖_p = 1$</span> holds.</p></div></section><section><div><pre><code class="language-none">normalize(L::Line, p::Real=2.0)</code></pre><p>Normalize the direction of a line.</p><p><strong>Input</strong></p><ul><li><code>L</code> – line</li><li><code>p</code> – (optional, default: <code>2.0</code>) vector <code>p</code>-norm used in the normalization</li></ul><p><strong>Output</strong></p><p>A line whose direction has unit norm w.r.t the given <code>p</code>-norm.</p><p><strong>Notes</strong></p><p>See also <a href="lib/@ref"><code>normalize!(::Line, ::Real)</code></a> for the in-place version.</p></div></section><section><div><pre><code class="language-none">normalize(system::AbstractSystem)</code></pre><p>Transform a mathematical system to a normalized (or canonical) form.</p><p><strong>Input</strong></p><ul><li><code>system</code> – system; it can be discrete or continuous</li></ul><p><strong>Output</strong></p><p>Either the same system if it already conforms to a canonical form, or a new system otherwise.</p><p><strong>Notes</strong></p><p>The normalization procedure consists of transforming a given system type into a &quot;canonical&quot; format that is used internally. More details are given below.</p><p><strong>Algorithm</strong></p><p>The implementation of <code>normalize</code> exploits <code>MathematicalSystems</code>&#39;s&#39; types, which carry information about the problem as a type parameter.</p><p>Homogeneous ODEs of the form <span>$x&#39; = Ax, x ∈ \mathcal{X}$</span> are canonical if the associated problem is a <code>ConstrainedLinearContinuousSystem</code> and <code>A</code> is a matrix. This type does not handle non-deterministic inputs.</p><p>Note that a <code>LinearContinuousSystem</code> does not consider constraints on the state-space (such as an invariant); to specify state constraints, use a <code>ConstrainedLinearContinuousSystem</code>. If the passed system is a <code>LinearContinuousSystem</code> (i.e. no constraints) then the normalization fixes a universal set (<code>Universe</code>) as the constraint set.</p><p>The generalization to canonical systems with constraints and possibly time-varying non-deterministic inputs is considered next. These systems are of the form <span>$x&#39; = Ax + u, u ∈ \mathcal{U}, x ∈ \mathcal{X}$</span>. The system type is <code>ConstrainedLinearControlContinuousSystem</code>, where <code>A</code> is a matrix, <code>X</code> is a set and <code>U</code> is an input, that is, any concrete subtype of <code>AbstractInput</code>.</p><p>If <code>U</code> is not given as an input, normalization accepts either a <code>LazySet</code>, or a vector of <code>LazySet</code>s. In these cases, the sets are wrapped around an appropriate concrete input type.</p><p>If the system does not conform to a canonical form, the implementation tries to make the transformation; otherwise an error is thrown. In particular, ODEs of the form <span>$x&#39; = Ax + Bu$</span> are mapped into <span>$x&#39; = Ax + u, u ∈ B\mathcal{U}$</span>, where now <span>$u$</span> has the same dimensions as <span>$x$</span>.</p><p>The transformations described above are analogous in the discrete case, i.e. <span>$x_{k+1} = A x_k$</span> and <span>$x_{k+1} = Ax_{k} + u_k, u_k ∈ \mathcal{U}, x_k ∈ \mathcal{X}$</span> for the linear and affine cases respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/5d1b77e104d32a82e920395513514ac425f7849e/src/Continuous/normalization.jl#L231-L283">source</a></section><section><div><pre><code class="language-none">normalize(h::Histogram{T,N}; mode::Symbol=:pdf) where {T,N}</code></pre><p>Normalize the histogram <code>h</code>.</p><p>Valid values for <code>mode</code> are:</p><ul><li><code>:pdf</code>: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.</li><li><code>:density</code>: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1. Will not modify the  histogram if it already represents a density (<code>h.isdensity == 1</code>).</li><li><code>:probability</code>: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.</li><li><code>:none</code>: Leaves histogram unchanged. Useful to simplify code that has to  conditionally apply different modes of normalization.</li></ul><p>Successive application of both <code>:probability</code> and <code>:density</code> normalization (in any order) is equivalent to <code>:pdf</code> normalization.</p></div></section><section><div><pre><code class="language-none">normalize(h::Histogram{T,N}, aux_weights::Array{T,N}...; mode::Symbol=:pdf) where {T,N}</code></pre><p>Normalize the histogram <code>h</code> and rescales one or more auxiliary weight arrays at the same time (<code>aux_weights</code> may, e.g., contain estimated statistical uncertainties). The values of the auxiliary arrays are scaled by the same factor as the corresponding histogram weight values. Returns a tuple of the normalized histogram and scaled auxiliary weights.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ReachabilityAnalysis.discretize" href="#ReachabilityAnalysis.discretize"><code>ReachabilityAnalysis.discretize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">discretize(ivp::IVP, δ, alg::AbstractApproximationModel)</code></pre><p>Set-based conservative discretization of a continuous-time initial value problem into a discrete-time problem.</p><p><strong>Input</strong></p><ul><li><code>ivp</code>   – initial value problem for a linear ODE in canonical form (see <code>Notes</code> below)</li><li><code>δ</code>     – step size</li><li><code>alg</code>   – algorithm used to compute the approximation model, choose among:</li></ul><pre><code class="language-julia-repl">julia&gt; subtypes(ReachabilityAnalysis.AbstractApproximationModel)
5-element Vector{Any}:
 Backward
 CorrectionHull
 Forward
 NoBloating
 StepIntersect</code></pre><p>Different approximation algorithms and their respective options are described in the docstring of each method, e.g. <a href="#ReachabilityAnalysis.Forward"><code>Forward</code></a>.</p><p><strong>Output</strong></p><p>The initial value problem of a discrete system.</p><p><strong>Notes</strong></p><p>Initial-value problems considered in this function are of the form</p><p class="math-container">\[x&#39; = Ax(t) + u(t),\qquad x(0) ∈ \mathcal{X}_0,\qquad (1)\]</p><p>and where <span>$u(t) ∈ U(k)$</span> add where <span>$\{U(k)\}_k$</span> is a sequence of sets of non-deterministic inputs and <span>$\mathcal{X}_0$</span> is the set of initial states. Recall that this initial-value problem is called homogeneous whenever <code>U</code> is the empty set. Other problems, e.g. <span>$x&#39; = Ax(t) + Bu(t)$</span> can be brought to the canonical form with the function <a href="#LinearAlgebra.normalize"><code>normalize</code></a>.</p><p>The initial value problem returned by this function consists of a set discretized (also called <em>bloated</em>) initial states <span>$Ω₀$</span>, together with the coefficient matrix <span>$Φ = e^{Aδ}$</span> and a transformed sequence of inputs if <span>$U$</span> is non-empty.</p><p>Two main variations of this algorithm are considered: dense time case and discrete time case.</p><ul><li><p>In the dense time case, the transformation is such that the trajectories of the given continuous system are included in the computed flowpipe of the discretized system. More precisely, given a step size <span>$δ$</span> and the system (1) conservative set-based discretization function computes a set, <span>$Ω₀$</span>, that guarantees to contain all the trajectories of (1) starting at any <span>$x(0) ∈ \mathcal{X}_0$</span> and for any input function that satisfies <span>$u(t) ∈ U(1)$</span>, for any <span>$t ∈ [0, δ]$</span>. If <span>$U$</span> is time-varying, this function also discretizes the inputs for <span>$k ≥ 0$</span>.</p></li><li><p>In the discrete time case, there is no bloating of the initial states and the input is assumed to remain constant between sampled times. Use the algorithm <code>NoBloating()</code> for this setting. If <span>$U$</span> is time-varying, this function also discretizes the inputs for <span>$k ≥ 0$</span>.</p></li></ul><p>There are algorithms to obatin such transformations, called <em>approximation models</em> in the technical literature. For references to the original papers, see the docstring of each concrete subtype of <code>AbstractApproximationModel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/5d1b77e104d32a82e920395513514ac425f7849e/src/Discretization/discretization.jl#L32-L97">source</a></section></article><h2 id="Approximation-models"><a class="docs-heading-anchor" href="#Approximation-models">Approximation models</a><a id="Approximation-models-1"></a><a class="docs-heading-anchor-permalink" href="#Approximation-models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ReachabilityAnalysis.Forward" href="#ReachabilityAnalysis.Forward"><code>ReachabilityAnalysis.Forward</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Forward{EM, SO, SI, IT, BT} &lt;: AbstractApproximationModel</code></pre><p>Forward approximation model.</p><p><strong>Fields</strong></p><ul><li><code>exp</code>     – exponentiation method</li><li><code>setops</code>  – set operations method</li><li><code>sih</code>     – symmetric interval hull</li><li><code>inv</code>     – (optional, default: <code>false</code>) if <code>true</code>, assume that the state matrix              is invertible and use its inverse in the <code>Φ</code> functions</li><li><code>backend</code> – (optional, default: <code>nothing</code>) used if the algorithm needs to apply              concrete polyhedral computations</li></ul><p><strong>Algorithm</strong></p><p>The transformations are:</p><ul><li><span>$Φ ← \exp(Aδ)$</span>,</li><li><span>$Ω_0 ← CH(\mathcal{X}_0, Φ\mathcal{X}_0 ⊕ δU(0) ⊕ E_ψ(U(0), δ) ⊕ E^+(\mathcal{X}_0, δ))$</span>,</li><li><span>$V(k) ← δU(k) ⊕ E_ψ(U(k), δ)$</span>.</li></ul><p>Here we allow <span>$U$</span> to be a sequence of time varying non-deterministic input sets.</p><p>For the definition of the sets <span>$E_ψ$</span> and <span>$E^+$</span> see <a href="../../references/#[FRE11]">[FRE11]</a>. The <code>Backward</code> method uses <span>$E^-$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/5d1b77e104d32a82e920395513514ac425f7849e/src/Discretization/Forward.jl#L5-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReachabilityAnalysis.Backward" href="#ReachabilityAnalysis.Backward"><code>ReachabilityAnalysis.Backward</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Backward{EM, SO, SI, IT, BT} &lt;: AbstractApproximationModel</code></pre><p>Backward approximation model.</p><p><strong>Fields</strong></p><ul><li><code>exp</code>     – exponentiation method</li><li><code>setops</code>  – set opertaions method</li><li><code>sih</code>     – symmetric interval hull</li><li><code>inv</code>     – (optional, default: <code>false</code>) if <code>true</code>, assume that the state matrix              is invertible and use its inverse in the <code>Φ</code> functions</li><li><code>backend</code> – (optional, default: <code>nothing</code>) used if the algorithm needs to apply              concrete polyhedral computations</li></ul><p><strong>Algorithm</strong></p><p>The transformations are:</p><ul><li><span>$Φ ← \exp(Aδ)$</span>,</li><li><span>$Ω_0 ← CH(\mathcal{X}_0, Φ\mathcal{X}_0 ⊕ δU(0) ⊕ E_ψ(U(0), δ) ⊕ E^-(\mathcal{X}_0, δ))$</span>,</li><li><span>$V(k) ← δU(k) ⊕ E_ψ(U(k), δ)$</span>.</li></ul><p>Here we allow <span>$U$</span> to be a sequence of time varying non-deterministic input sets.</p><p>For the definition of the sets <span>$E_ψ$</span> and <span>$E^-$</span> see <a href="../../references/#[FRE11]">[FRE11]</a>. The <code>Forward</code> method uses <span>$E^+$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/5d1b77e104d32a82e920395513514ac425f7849e/src/Discretization/Backward.jl#L5-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReachabilityAnalysis.CorrectionHull" href="#ReachabilityAnalysis.CorrectionHull"><code>ReachabilityAnalysis.CorrectionHull</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CorrectionHull{EM} &lt;: AbstractApproximationModel</code></pre><p>Discretization using the correction hull of the matrix exponential.</p><p><strong>Fields</strong></p><ul><li><code>exp</code>   – exponentiation method</li><li><code>order</code> – order of the Taylor series expansion of the matrix exponential</li></ul><p><strong>Algorithm</strong></p><p>For the homogeneous case, this method implements the transformation:</p><p class="math-container">\[Ω_0 = CH(X_0, e^{Aδ}  X_0) ⊕ FX_0\]</p><p>where <span>$F$</span> is the correction (interval) matrix.</p><p>For the inhomogeneous case, <span>$x&#39; = Ax + u$</span>,  <span>$x ∈ X, u ∈ U$</span>, implements <span>$Ω_0 = CH(X_0, exp(Aδ)  X0) ⊕ FX0$</span> where <span>$F$</span> is the correction (interval) matrix.</p><p>In both cases, if <span>$A$</span> is an interval matrix, the exponential is overapproximated using methods from <code>IntervalMatrices.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/5d1b77e104d32a82e920395513514ac425f7849e/src/Discretization/CorrectionHull.jl#L5-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReachabilityAnalysis.NoBloating" href="#ReachabilityAnalysis.NoBloating"><code>ReachabilityAnalysis.NoBloating</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoBloating{EM, SO, IT} &lt;: AbstractApproximationModel</code></pre><p>No bloating, or discrete-time, approximation model.</p><p><strong>Fields</strong></p><ul><li><code>exp</code>     – exponentiation method</li><li><code>setops</code>  – set operations method</li><li><code>inv</code>     – (optional, default: <code>false</code>) if <code>true</code>, assume that the state matrix              is invertible and use its inverse in the <code>Φ</code> functions</li></ul><p><strong>Algorithm</strong></p><p>The transformations are:</p><ul><li><span>$Φ ← \exp(Aδ)$</span></li><li><span>$Ω_0 ← \mathcal{X}_0$</span></li><li><span>$V(k) ← Φ₁(A, δ)U(k)$</span>, <span>$k ≥ 0$</span>.</li></ul><p>The function <span>$Φ₁(A, δ)$</span> is defined in <a href="#ReachabilityAnalysis.Φ₁"><code>Φ₁</code></a>. We allow <span>$U$</span> to be a sequence of time varying non-deterministic input sets.</p><p>See also Eqs.(14) in <a href="../../references/#[BFFPSV18]">[BFFPSV18]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/5d1b77e104d32a82e920395513514ac425f7849e/src/Discretization/NoBloating.jl#L5-L29">source</a></section></article><h2 id="Exponentiation"><a class="docs-heading-anchor" href="#Exponentiation">Exponentiation</a><a id="Exponentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Exponentiation" title="Permalink"></a></h2><p>The state transition matrix of the linear ODE <span>$x&#39;(t) = Ax(t) + u(t)$</span> at time <span>$\delta &gt; 0$</span> is <span>$\Phi = e^{A\delta}$</span>, hence the algorithms usually require to compute exponential matrices. There are distinct ways to compute the matrix exponential <span>$e^{A\delta}$</span> depending on the type of <span>$A$</span> (see e.g. <sup class="footnote-reference"><a id="citeref-HIH08" href="#footnote-HIH08">[HIH08]</a></sup>). The available methods can be used through the (unexported) function <code>_exp</code>.</p><p>For high dimensional systems (typicall <code>n &gt; 2000</code>), computing the matrix exponential is expensive hence it is preferable to compute the action of the matrix exponential over vectors when needed, that is, <span>$e^{δA} v$</span> for each <span>$v$</span>. This method is particularly well-suited if <code>A</code> is vert sparse. Use the option <code>exp=:krylov</code> (or <code>exp=:lazy</code>) for this purpose.</p><article class="docstring"><header><a class="docstring-binding" id="ReachabilityAnalysis._exp" href="#ReachabilityAnalysis._exp"><code>ReachabilityAnalysis._exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_exp(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp)</code></pre><p>Compute the matrix exponential <span>$e^{Aδ}$</span>.</p><p><strong>Input</strong></p><ul><li><code>A</code>    – matrix</li><li><code>δ</code>    – step size</li><li><code>alg</code>  – (optional, default: <code>BaseExp</code>) the algorithm used to take the matrix           exponential of <code>Aδ</code>, possible options are <code>BaseExp</code>, <code>LazyExp</code>, <code>PadeExp</code> and <code>IntervalExp</code>           see details in the <em>Algorithm</em> section below</li></ul><p><strong>Output</strong></p><p>A matrix or a lazy wrapper of the matrix exponential, depending on <code>alg</code>.</p><p><strong>Algorithm</strong></p><ul><li><p><code>BaseExp</code> – (alias: <code>:base</code>) use Higham&#39;s scaling and squaring method implemented              in Julia standard library; see <code>?exp</code> for details; if <code>A</code> is a static array,              uses the implementation in <code>StaticArrays.jl</code></p></li><li><p><code>LazyExp</code> – (alias: <code>:lazy</code>) return a lazy wrapper type around the matrix exponential              using the implementation <code>LazySets.SparseMatrixExp</code></p></li><li><p><code>PadeExp</code> – (alias: <code>pade</code>) apply Pade approximant method to compute the matrix              exponential of a sparse matrix (requires <code>Expokit.jl</code>)</p></li><li><p><code>IntervalExp</code> – (alias: <code>interval</code>, <code>taylor</code>) apply the Taylor series expansion of the matrix                   exponential with an interval remainder; works if <code>A</code> is an interval matrix</p></li></ul><p><strong>Notes</strong></p><p>If the algorithm <code>LazyExp</code> is used, evaluations of the action of the matrix exponential are done with the <code>expmv</code> implementation from <code>Expokit</code> (but see <code>LazySets#1312</code> for the planned generalization to other backends).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/5d1b77e104d32a82e920395513514ac425f7849e/src/Discretization/exponentiation.jl#L126-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReachabilityAnalysis.Φ₁" href="#ReachabilityAnalysis.Φ₁"><code>ReachabilityAnalysis.Φ₁</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Φ₁(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp, [isinv]::Bool=false, [Φ]=nothing)</code></pre><p>Evaluate the series</p><p class="math-container">\[Φ₁(A, δ) = ∑_{i=0}^∞ \dfrac{δ^{i+1}}{(i+1)!}A^i,\]</p><p>where <span>$A$</span> is a square matrix of order <span>$n$</span> and <span>$δ &gt; 0$</span>.</p><p><strong>Input</strong></p><ul><li><code>A</code>      – coefficients matrix</li><li><code>δ</code>      – step size</li><li><code>alg</code>    – (optional, default: <code>BaseExp</code>) the method used to take the matrix              exponential of the coefficient matrix; see the documentation of              <a href="#ReachabilityAnalysis._exp"><code>_exp</code></a> for available options</li><li><code>isinv</code>  – (optional, default: <code>false</code>) if <code>true</code>, assume that the coefficients             matrix is invertible and compute <span>$A^{-1}$</span></li><li><code>Φ</code>      – (optional, default: <code>nothing</code>) optionally pass the matrix exponential <span>$e^{Aδ}$</span></li></ul><p><strong>Output</strong></p><p>A matrix.</p><p><strong>Algorithm</strong></p><p>If <span>$A$</span> is invertible, <span>$Φ₁$</span> can be computed as</p><p class="math-container">\[Φ₁(A, δ) = A^{-1}(e^{Aδ} - I_n),\]</p><p>where <span>$I_n$</span> is the identity matrix of order <span>$n$</span>.</p><p>In the general case, implemented in this function, it can be computed as submatrices of the block matrix</p><p class="math-container">\[P_{2n} = \exp \begin{pmatrix}
Aδ &amp;&amp; δI_n \\
0 &amp;&amp; 0
\end{pmatrix}.\]</p><p>It can be shown that</p><p class="math-container">\[\exp(P_{2n}) = \begin{pmatrix}
Φ(A, δ) &amp;&amp; Φ₁(A, δ) \\
0 &amp;&amp;  δI_n
\end{pmatrix}.\]</p><p>where <span>$Φ(A, δ) = e^{Aδ}$</span>. In particular, <code>Φ₁(A, δ) = P[1:n, (n+1):2*n]</code>. This method can be found in <a href="../../references/#[FRE11]">[FRE11]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/5d1b77e104d32a82e920395513514ac425f7849e/src/Discretization/exponentiation.jl#L197-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReachabilityAnalysis.Φ₂" href="#ReachabilityAnalysis.Φ₂"><code>ReachabilityAnalysis.Φ₂</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Φ₂(A::AbstractMatrix, δ, [alg]::AbstractExpAlg=BaseExp, [isinv]::Bool=false, [Φ]=nothing)</code></pre><p>Evaluate the series</p><p class="math-container">\[Φ₂(A, δ) = ∑_{i=0}^∞ \dfrac{δ^{i+2}}{(i+2)!}A^i,\]</p><p>where <span>$A$</span> is a square matrix of order <span>$n$</span> and <span>$δ &gt; 0$</span>.</p><p><strong>Input</strong></p><ul><li><code>A</code>      – coefficients smatrix</li><li><code>δ</code>      – step size</li><li><code>alg</code>    – (optional, default: <code>BaseExp</code>) the method used to take the matrix              exponential of the coefficient matrix; see the documentation of              <a href="#ReachabilityAnalysis._exp"><code>_exp</code></a> for available options</li><li><code>isinv</code>  – (optional, default: <code>false</code>) if <code>true</code>, assume that the coefficients             matrix is invertible and compute <span>$A^{-1}$</span></li><li><code>Φ</code>      – (optional, default: <code>nothing</code>) optionally pass the matrix exponential <span>$e^{Aδ}$</span></li></ul><p><strong>Output</strong></p><p>A matrix.</p><p><strong>Algorithm</strong></p><p>If <span>$A$</span> is invertible, <span>$Φ₂$</span> can be computed as</p><p class="math-container">\[Φ₂(A, δ) = A^{-2}(e^{δA} - I_n - δA).\]</p><p>In the general case, implemented in this function, it can be computed as submatrices of the block matrix</p><p class="math-container">\[P_{3n} = \exp \begin{pmatrix}
Aδ &amp;&amp; δI_n &amp;&amp; 0 \\
0 &amp;&amp; 0 &amp;&amp; δI_n \\
0 &amp;&amp; 0 &amp;&amp; 0
\end{pmatrix}.\]</p><p>It can be shown that</p><p class="math-container">\[\exp(P_{3n}) = \begin{pmatrix}
Φ(A, δ) &amp;&amp; Φ₁(A, δ) &amp;&amp; 0 \\
0 &amp;&amp; 0     &amp;&amp; δI_n \\
0 &amp;&amp; 0     &amp;&amp; 0
\end{pmatrix}.\]</p><p>where <span>$Φ(A, δ) = e^{Aδ}$</span>. In particular, <code>Φ₂ = P_{3n}[1:n, (2*n+1):3*n]</code>. This method can be found in <a href="../../references/#[FRE11]">[FRE11]</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/5d1b77e104d32a82e920395513514ac425f7849e/src/Discretization/exponentiation.jl#L325-L378">source</a></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-HIH08"><a class="tag is-link" href="#citeref-HIH08">HIH08</a>Higham, Nicholas J. Functions of matrices: theory and computation. Society for Industrial and Applied Mathematics, 2008.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../systems/">« Systems</a><a class="docs-footer-nextpage" href="../projections/">Projections »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 4 June 2021 21:58">Friday 4 June 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
